<!DOCTYPE html>




<html lang="en">

<head>
	<meta name="generator" content="Hugo 0.57.2" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    Filecoin Specification
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="./book.min.dd7edd971a70e42d8b77dee6408ce13a65b881f03c3da4d4895f894b428e6946.css">


<link rel="icon" href="./favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="./index.xml" title="Filecoin Spec" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="./css/syntax.css">
<link href="./mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="./mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="">Filecoin Spec</a>
</h2>



    
  
  
  
    
    
  

  <style>
  nav ul a[href="\2f "] {
      color: #0b3a53;
  }
  </style>


  <div>
  <ul>
    
      
      <li>
        











<a href="./#intro">    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="./#intro__arch">    
    
        Architecture Diagram
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__concepts">    
    
        Key Concepts
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__filecoin_vm">    
    
        Filecoin VM
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process">    
    
        Spec Process
    
</a>



    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="./#algorithms">    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="./#algorithms__expected_consensus">    
    
        Expected Consensus
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__proof_of_replication">    
    
        Proof of Replication
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__proof_of_spacetime">    
    
        Proof of Spacetime
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__payment_channels">    
    
        Payment Channels
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__vdf">    
    
        Verifiable Delay Functions
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__crypto">    
    
        Cryptographic Primitives
    
</a>



    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="./#subsystems">    
    
    <strong>
    
        Subsystems
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__blockchain">    
    
        Blockchain
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__blockchain__components">    
    
        Blockchain Components
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__blockchain__components__block_receiver">    
    
        Block Receiver
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__blockchain__components__block_propagator">    
    
        Block Propagator
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__blockchain__components__chain_manager">    
    
        Chain Manager
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__blockchain__components__block_producer">    
    
        Block Producer
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__blockchain__libp2p">    
    
        libp2p Protocols
    
</a>


<ul>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__vm">    
    
        Filecoin VM
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__vm__components">    
    
        Filecoin VM Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="./#subsystems__vm__components__vm_interpreter">    
    
        VM Interpreter
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__vm__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__vm__actors__standard">    
    
        Standard Actors
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__vm__actors__singleton">    
    
        Singleton Actors
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__storage">    
    
        Storage Market
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="./#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__storage__components">    
    
        Storage Market Components
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__storage__components__storage_provider">    
    
        Storage Provider
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__storage__libp2p">    
    
        libp2p Protocols
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__retrieval">    
    
        Retrieval Market
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="./#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__retrieval__components">    
    
        Retrieval Market Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__mining">    
    
        Storage Mining
    
</a>


<ul>

    <li>
    
      











<a href="./#subsystems__mining__actors">    
    
        Storage Mining Actors
    
</a>


<ul>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__mining__components">    
    
        Storage Mining Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="./#subsystems__mining__components__proof_generator">    
    
        Proof Generator
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#subsystems__network">    
    
        Network Interface
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#subsystems__repository">    
    
        Repository
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="./#listings">    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="./#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__data_structures">    
    
        Data Structures
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__components">    
    
        Components
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__libp2p_protocols">    
    
        libp2p Protocols
    
</a>


<ul>

</ul>


    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="./#glossary">    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>


<ul>

</ul>


      </li>
    
      
      <li>
        











<a href="./#appendix">    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



      </li>
    
  </ul>
</div>








</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="./svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    Filecoin Specification
  
</strong>
</header>

      
<article class="markdown"><script>
  structSet = new Set([
    "Actor",
    "Address",
    "Bitfield",
    "Block",
    "BytesAmount",
    "ElectionProof",
    "FaultSet",
    "Message",
    "MessageReceipt",
    "PeerId",
    "PoSTProof",
    "PublicKey",
    "SealProof",
    "SectorID",
    "SectorSet",
    "Signature",
    "SignedMessage",
    "StateTree",
    "Ticket",
    "TipSet",
    "TokenAmount",
    "UnsignedMessage",
  ]);

  structRefs = {
    "AddressId":               "Address",
    "AddressSecp256k1":        "Address",
    "AddressActor":            "Address",
    "AddressBLS12_381":        "Address",
    "Bls12_381Signature":      "Signature",
    "Secp256k1Signature":      "Signature",
    "TxMeta":                  "Block",
    "VDFProof":                "Ticket",
    "VDFResult":               "Ticket",
    "VRFProof":                "Ticket",
  };

  fillSingleCodeRef = (x, isTokenDef) => {
    let origKey = x.innerText;
    let key = origKey;
    let newKey = structRefs[key];
    if (newKey !== undefined) {
      key = newKey;
    }
    if (structSet.has(key)) {
      if (x.className == "nx" && isTokenDef) {
        x.innerHTML = "<span id=go__" + origKey + "><a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a></div>";
      } else {
        x.innerHTML = "<a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a>";
      }
    }
  };

  fillCodeRefs = (xs, parent) => {
    if (xs.length == 0 && parent.innerText.length != 0) {
      fillSingleCodeRef(parent);
      return;
    }

    let isTokenDef = false;

    for (let x of xs) {
      if (x.className == "kd" && x.innerHTML == "type") {
        isTokenDef = true;
        continue;
      }

      if (x.className != "nx" && x.className != "codeRef") {
        isTokenDef = false;
        continue;
      }

      fillSingleCodeRef(x, isTokenDef);
      isTokenDef = false;
    }
  };

  window.onload = (event) => {
    let codeBlocks = document.getElementsByTagName("code");
    for (let codeBlock of codeBlocks) {
      fillCodeRefs(codeBlock.children, codeBlock);
    }

    let hashPrev = location.hash;
    if ((typeof hashPrev) == "string" && hashPrev != "") {
      location.hash = "";
      location.hash = hashPrev;
    }
  };
</script>





<div>
  
    
    








<div id="intro">

<h1>
  Introduction
</h1>

<div class="notices warning" ><strong>Warning:</strong> This draft of the Filecoin protocol specification is a work in progress.
It is intended to establish the rough overall structure of the document,
enabling experts to fill in different sections in parallel.
However, within each section, content may be out-of-order, incorrect, and/or incomplete.
The reader is advised to refer to the
<a href="https://filecoin-project.github.io/specs/">official Filecoin spec document</a>
for specification and implementation questions.</div>

<p>Filecoin is a distributed storage network based on a blockchain mechanism.
Filecoin <em>miners</em> can elect to provide storage capacity for the network, and thereby
earn units of the Filecoin cryptocurrency (FIL) by periodically producing
cryptographic proofs that certify that they are providing the capacity specified.
In addition, Filecoin enables parties to exchange FIL currency
through transactions recorded in a shared ledger on the Filecoin blockchain.
Rather than using Nakamoto-style proof of work to maintain consensus on the chain, however,
Filecoin uses proof of storage itself: a miner&rsquo;s power in the consensus protocol
is proportional to the amount of storage it provides.</p>

<p>The Filecoin blockchain not only maintains the ledger for FIL transactions and
accounts, but also implements the Filecoin VM, a replicated state machine which executes
a variety of cryptographic contracts and market mechanisms among participants
on the network.
These contracts include <em>storage deals</em>, in which clients pay FIL currency to miners
in exchange for storing the specific file data that the clients request.
Via the distributed implementation of the Filecoin VM, storage deals
and other contract mechanisms recorded on the chain continue to be processed
over time, without requiring further interaction from the original parties
(such as the clients who requested the data storage).</p>



  
    








<div id="intro__arch">

<h2>
  Architecture Diagram
</h2>

<p>TODO</p>




</div>

  

  
    








<div id="intro__concepts">

<h2>
  Key Concepts
</h2>

<p>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:</p>

<ul>
<li><p><strong><em>Data structures</em></strong> are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).</p></li>

<li><p><strong><em>Functions</em></strong> are computational procedures that do not depend on external state (i.e., mathematical functions,
or programming language functions that do not refer to global variables).</p></li>

<li><p><strong><em>Components</em></strong> are sets of functionality that are intended to be represented as single software units
in the implementation structure.
Depending on the choice of language and the particular component, this might
correspond to a single software module,
a thread or process running some main loop, a disk-backed database, or a variety of other design choices.
For example, the <a href="./#subsystems__blockchain__components__block_propagator">Block Propagator</a> is a component: it could be implemented
as a process or thread running a single specified main loop, which waits for network messages
and responds accordingly by recording and/or forwarding block data.</p></li>

<li><p><strong><em>APIs</em></strong> are messages that can be sent to components.
A client&rsquo;s view of a given sub-protocol, such as a request to a miner node&rsquo;s
<a href="./#subsystems__storage__components__storage_provider">Storage Provider</a> component to store files in the storage market,
may require the execution of a series of APIs.</p></li>

<li><p><strong><em>Nodes</em></strong> are complete software and hardware systems that interact with the protocol.
A node might be constantly running several of the above <em>components</em>, participating in several <em>subsystems</em>,
and exposing <em>APIs</em> locally and/or over the network,
depending on the node configuration.
The term <em>full node</em> refers to a system that runs all of the above components, and supports all of the APIs detailed in the spec.</p></li>

<li><p><strong><em>Subsystems</em></strong> are conceptual divisions of the entire Filecoin protocol, either in terms of complete protocols
(such as the <a href="./#subsystems__storage">Storage Market</a> or <a href="./#subsystems__retrieval">Retrieval Market</a>), or in terms of functionality
(such as the <a href="./#subsystems__vm">Filecoin VM</a>). They do not necessarily correspond to any particular node or software component.</p></li>

<li><p><strong><em>Actors</em></strong> are virtual entities embodied in the state of the Filecoin VM.
Protocol actors are analogous to participants in smart contracts;
an actor carries a FIL currency balance and can interact with other actors
via the operations of the VM, but does not necessarily correspond to any particular node or software component.</p></li>
</ul>




</div>

  

  
    








<div id="intro__filecoin_vm">

<h2>
  Filecoin VM
</h2>

<p>The majority of Filecoin&rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &lsquo;chain&rsquo; of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p>

<p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p>

<p>An <code>actor</code> is the Filecoin equivalent of Ethereum&rsquo;s smart contracts, it is essentially an &lsquo;object&rsquo; in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p>

<p>There are two routes to calling a method on an <code>actor</code>. First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>.  The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of &lsquo;gas&rsquo;. We also use &lsquo;gas&rsquo;).</p>

<p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods.  However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p>

<p>For full implementation details, see the <a href="./#subsystems__vm">VM subsystem</a>.</p>




</div>

  

  
    








<div id="intro__process">

<h2>
  Spec Process
</h2>




  
    








<div id="intro__process__about">

<h3>
  About this specification
</h3>

<p>TODO</p>




</div>

  

  
    








<div id="intro__process__fip">

<h3>
  Filecoin Improvement Proposals (FIPs)
</h3>

<p>TODO</p>




</div>

  

  
    








<div id="intro__process__contributing">

<h3>
  Contributing to the Filecoin spec
</h3>

<p>TODO</p>




</div>

  

  
    








<div id="intro__process__related_resources">

<h3>
  Related Resources
</h3>

<p>TODO</p>



  
    








<div id="intro__process__related_resources__research_portal">

<h4>
  Research portal
</h4>

<p>TODO</p>




</div>

  

  
    








<div id="intro__process__related_resources__network_tooling">

<h4>
  Network tooling
</h4>

<p>TODO</p>




</div>

  

  
    








<div id="intro__process__related_resources__testing">

<h4>
  Testing and implementation compliance
</h4>

<p>TODO</p>




</div>

  


</div>

  


</div>

  


</div>


  
    
    








<div id="algorithms">

<h1>
  Algorithms
</h1>




  
    








<div id="algorithms__expected_consensus">

<h2>
  Expected Consensus
</h2>

<p><strong>This spec describes how the expected consensus (EC) protocol works in general. To read more about Filecoin-specific processes, see:</strong></p>

<ul>
<li><a href="mining.md#mining-blocks">Mining Blocks</a> on how consensus is used in block mining.</li>
<li><a href="faults.md">Faults</a> on slashing.</li>
<li><a href="storage-market.md#the-power-table">Storage market</a> on how the <code>power table</code> is created and maintained.</li>
<li><a href="data-structures.md#block">Block data structure</a> for details on fields and encoding.</li>
</ul>

<div id="algorithms__expected_consensus__important_concepts_and_definitions"></div><h3>Important concepts and definitions</h3>

<p>Some important concepts relevant to expected consensus are:</p>

<ul>
<li><a href="definitions.md#vdf">Verifiable Delay Function (VDF)</a></li>
<li><a href="defintions.md#vrf">Verifiable Random Function (VRF)</a></li>
<li><a href="definitions.md#tipset">TipSet</a></li>
<li><a href="definitions.md#ticket">Ticket</a></li>
<li><a href="defintions.md#ticket-chain">Ticket Chain</a></li>
<li><a href="definitions.md#height">Height</a>

<ul>
<li>In the realm of EC, it is worth noting that a new ticket must be produced at every height, and consequently the duration of a round is bounded by the duration of the Verifiable Delay Function that is run to generate a ticket.</li>
</ul></li>
<li><a href="definitions.md#weight">Weight</a></li>
<li><a href="definitions.md#power-fraction">Power Fraction</a></li>
<li><a href="definitions.md#electionproof">ElectionProof</a></li>
</ul>

<div id="algorithms__expected_consensus__algorithm"></div><h3>Algorithm</h3>

<p>Expected Consensus (EC) is a probabilistic Byzantine fault-tolerant consensus protocol. At a high
level, it operates by running a leader election every round in which, on expectation, one
participant may be eligible to submit a block. EC guarantees that this winner will be anonymous until they reveal themselves by submitting a proof of their election (we call this proof an <code>Election Proof</code>). All valid blocks submitted in a given round form a <code>TipSet</code>. Every block in a TipSet adds weight to its chain. The &lsquo;best&rsquo; chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on how to select the heaviest chain, see <a href="#chain-selection">Chain Selection</a>.</p>

<p>The methods below describe the basic algorithm for EC.</p>

<p>Every time a block is received, we first verify whether the block is valid (<code>VerifyBlock</code> is defined in the <a href="mining.md#block-validation">mining spec</a>.) If the received block is valid, we add it to our TipSet.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Called when a block is received by this node
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">OnBlockReceived</span><span class="p">(</span><span class="nx">blk</span> <span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The exact definition of VerifyBlock depends on the protocol
</span><span class="c1"></span>    <span class="c1">// For Filecoin, see mining.md
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">VerifyBlock</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ChainTipsMgr</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="c1">// Received an invalid block!
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<p>Meanwhile, the mining node runs a mining process to attempt to generate blocks. In <code>Mine</code>, the node identifies the best TipSet in each round and generates a ticket from it. In parallel, it uses a past ticket to try and generate a valid <code>ElectionProof</code> thereby enabling it to mine a new block. If no valid <code>ElectionProof</code> is produced, the miner mines a new ticket atop their old one and tries again at a new height.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Mine</span><span class="p">(</span><span class="nx">minerKey</span> <span class="nx">PrivateKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rounds</span> <span class="p">{</span> <span class="c1">// for each round
</span><span class="c1"></span>        <span class="nx">bestTipset</span><span class="p">,</span> <span class="nx">tickets</span> <span class="o">:=</span> <span class="nx">ChainTipsMgr</span><span class="p">.</span><span class="nf">GetBestTipsetAtRound</span><span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="nx">ticket</span> <span class="o">:=</span> <span class="nf">GenerateTicket</span><span class="p">(</span><span class="nx">minerKey</span><span class="p">,</span> <span class="nx">bestTipset</span><span class="p">)</span>
        <span class="nx">tickets</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">ticket</span><span class="p">)</span>

        <span class="c1">// Generate an ElectionProof and check if we win
</span><span class="c1"></span>        <span class="c1">// Note: even if we don&#39;t win, we want to make a ticket
</span><span class="c1"></span>        <span class="c1">// in case we need to mine a null round
</span><span class="c1"></span>        <span class="nx">win</span><span class="p">,</span> <span class="nx">proof</span> <span class="o">:=</span> <span class="nf">CheckIfWinnerAtRound</span><span class="p">(</span><span class="nx">minerKey</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">bestTipset</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">win</span> <span class="p">{</span>
            <span class="nf">GenerateAndBroadcastBlock</span><span class="p">(</span><span class="nx">bestTipset</span><span class="p">,</span> <span class="nx">tickets</span><span class="p">,</span> <span class="nx">proof</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Even if we don&#39;t win, add our ticket to the tracker in
</span><span class="c1"></span>            <span class="c1">// case we need to mine on it later.
</span><span class="c1"></span>            <span class="nx">ChainTipsMgr</span><span class="p">.</span><span class="nf">AddFailedTicket</span><span class="p">(</span><span class="nx">bestTipset</span><span class="p">,</span> <span class="nx">tickets</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>To check if the miner won the round, she runs <code>CheckIfWinnerAtRound</code>. In this method, the miner takes their ticket from a prior round (which round to look at is specified by the randomness lookback parameter), computes an ElectionProof, and returns whether the proof indicates that the miner has won the round. In the pseudocode below, <code>IsProofAWinner</code> is taken from <a href="mining.md#block-validation">the mining doc</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">RandomnessLookback</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// Also referred to as &#34;K&#34; in many places
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">CheckIfWinnerAtRound</span><span class="p">(</span><span class="nx">key</span> <span class="nx">PrivateKey</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">Integer</span><span class="p">,</span> <span class="nx">parentTipset</span> <span class="nx">Tipset</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">ElectionProof</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lbt</span> <span class="o">:=</span> <span class="nx">ChainTipsMgr</span><span class="p">.</span><span class="nf">TicketFromRound</span><span class="p">(</span><span class="nx">parentTipset</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="nx">RandomnessLookback</span><span class="p">)</span>

  <span class="nx">eproof</span> <span class="o">:=</span> <span class="nf">ComputeElectionProof</span><span class="p">(</span><span class="nx">lbt</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>

  <span class="nx">minerPower</span> <span class="o">:=</span> <span class="nf">GetPower</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
  <span class="nx">totalPower</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetTotalPower</span><span class="p">()</span>

  <span class="k">if</span> <span class="nf">IsProofAWinner</span><span class="p">(</span><span class="nx">eproof</span><span class="p">,</span> <span class="nx">minerPower</span><span class="p">,</span> <span class="nx">totalPower</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">True</span><span class="p">,</span> <span class="nx">eproof</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nx">False</span><span class="p">,</span> <span class="nx">None</span>
<span class="p">}</span></code></pre></div>
<p>Note: Validity of blocks beyond appropriate ticket generation (defined below) is defined by the specific protocol using EC. For the Filecoin definition of a valid block, see the <a href="mining.md">mining spec</a>.</p>

<p>The EC algorithm can be better understood by looking at its two major components in more detail:</p>

<ul>
<li><a href="./#algorithms__expected_consensus__secret_leader_election">Secret Leader Election</a></li>
<li><a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a></li>
</ul>

<p><div id="algorithms__expected_consensus__secret_leader_election"></div>
<div id="algorithms__expected_consensus__secret_leader_election"></div><h3>Secret Leader Election</h3></p>

<p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the storage <a href="storage-market.md#the-power-table">power table</a>, where power is equivalent to storage provided through time.</p>

<p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin&rsquo;s EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness inputs for Leader Election. Every block generated references an <code>ElectionProof</code> derived from a past ticket. The ticket chain is extended by the miner who generates a new ticket with each attempted election.</p>

<p>In cases in which no winning ticket is found by any miner in a given round (i.e. no block is mined on the network at that height), miners move on to the next ticket in the ticket chain to attempt a new leader election. When this happens, miners should nonetheless generate a new ticket prior to the new leader election, thereby appropriately prolonging the ticket chain (the block chain can never be longer than the ticket chain). This situation is fleshed out in the <a href="#losing-tickets">Losing Tickets</a> section.</p>

<p>In order to pressure the network to converge on a single chain, each miner may only submit one block per round (see: <a href="#slashing"><code>Slashing</code></a>).</p>

<p>TODO: pictures of ticket chain and block chain</p>

<h4>Tickets</h4>

<p>One may think of leader election in EC as a verifiable lottery, in which participants win in proportion to the power they have within the network.</p>

<p>A ticket is drawn from the past at the beginning of each new round, and a new ticket is generated in every round. Tickets are chained independently of the main blockchain. A ticket only depends on the ticket before it, and not any other data in the block. Nonetheless, in Filecoin, every block header contains one or more new tickets, thereby extending the ticket chain. A miner generates a new ticket in their block for every ticket they scratch running leader election, thereby ensuring the ticket chain is at least as long as the block chain.</p>

<p>At a high-level, tickets must do the following:</p>

<ul>
<li>Ensure leader secrecy &ndash; meaning a block producer will not be known until they release their block to the network.</li>
<li>Prove leader election &ndash; meaning a block producer can be verified by any participant in the network.</li>
<li>Prove appropriate delay between drawings — thereby preventing leaders from &ldquo;rushing&rdquo; the protocol by releasing blocks early (at the expense of fairness for miners with worse connectivity).</li>

<li><p>Ensure a single drawing per round — derived in part from the above, thereby preventing miners from grinding on tickets (e.g. by repeatedly drawing new tickets in the hopes of winning) within a round.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">ticket = {TODO} where (proof, value) &lt;-- VDF(SK, x) for some seed x</code></pre></div></li>
</ul>

<p>You can find the Ticket data structure <a href="data-structures.md#tickets">here</a>.</p>

<p>In practice, EC defines two different fields within a block:</p>

<ul>
<li>A <code>Tickets</code> array — this stores new tickets generated during this block generation attempt. It proves appropriate delay. It is from this array that miners will sample randomness to run leader election in <code>K</code> rounds. See <a href="#ticket-generation">Ticket generation</a>.</li>
<li>An <code>ElectionProof</code> — this stores a proof that a given miner scratched a winning lottery ticket using the appropriate ticket <code>K</code> rounds back. It proves that the leader was elected in this round. See <a href="#checking-election-results">Checking election results</a>.</li>
</ul>

<p>On expectation, the <code>Tickets</code> array will contain a single ticket. For cases in which it contains more than one, see <a href="#losing-tickets">Losing Tickets</a>.</p>

<pre><code>On the two uses of tickets.

Tickets serve two main purposes.

1) As a proof that blocks were appropriately delayed. This both prevents miners grinding through tickets and a winner rushing the protocol by publishing
blocks as fast as possible (thereby penalizing poorly connected miners).

This is a result of a new ticket being generated by the miner for every leader election
attempt (using a ticket from the past). This ticket is generated using the ticket generated at the last height (either
from the prior block, or the prior &quot;losing&quot; ticket).

2) As a source of randomness used to prove that a leader was correctly elected.

This is done by generating an 'ElectionProof' derived from the ticket sampled K rounds
back in the ticket chain.

But why the randomness lookback?

The randomness lookback helps turn independent lotteries (ticket drawings from a block one round back)
into a global lottery instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:
- The randomness lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).
- It means electionProofs are stored separately from new tickets on a block, taking up
more space on-chain.
</code></pre>

<h5>Ticket generation</h5>

<p>This section discusses how tickets are generated for the <code>Tickets</code> array. For how tickets are validated, see <a href="mining.md#ticket-validation">ticket validation</a>.</p>

<p>At round <code>N</code>, new tickets are generated using tickets drawn from the <a href="#tipsets">TipSet</a> at round <code>N-1</code>. This ensures the miner cannot publish a new block (corresponding to the <code>ElectionProof</code> generated by a winning ticket <code>K</code> rounds back) until the correct round. Because a Tipset can contain multiple blocks (see <a href="#chain-selection">Chain Selection</a> below), the smallest ticket in the Tipset must be drawn otherwise the block will be invalid.</p>

<p>TODO: pictures of TipSet ticket drawing</p>

<p>The miner runs the prior ticket through a Verifiable Random Function (VRF) to get a new unique output. This output is then used as input into a Verifiable Delay Function (VDF), with the VRFProof, VDFProof and VDFOutput generating a new ticket for future use.</p>

<p>The VRF&rsquo;s deterministic output adds entropy to the ticket chain, limiting a miner&rsquo;s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).
The VDF approximates clock synchrony for miners, thereby ensuring miners have waited an appropriate delay ahead of drawing a new ticket. It ensures network liveness, allowing miners to run a new election if no winner is found in a given round.
Finally, it establishes a lower-bound delay between production of new blocks at different heights. This helps ensure fairness, in that miners with lesser connectivity are not penalized and have a chance to produce blocks.
A default value for the VDF delay could be 30 seconds, given estimated network propagation times.</p>

<p>Succinctly, the process of crafting a new <code>Ticket</code> in round <code>N</code> is as follows. We use:</p>

<ul>
<li>The ECVRF algorithm from <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">Goldberg et al. Section 5</a>, with:

<ul>
<li>Sha256 for our hashing function</li>
<li>Secp256k1 for our curve</li>
<li>Note that the operation type in step 2.1 is necessary to prevent an adversary from guessing an election proof for a miner ahead of time.</li>
</ul></li>

<li><p>The TODO VDF impl.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: parentTickets at round N-1, miner&#39;s private key SK
Output: newTicket

0. Prepare new ticket
i. newTicket &lt;-- New()
1. Draw prior ticket
i. # take the last ticket for each parent &#39;Tickets&#39; array
    lastTickets &lt;-- map(parentTickets, fun(x): x.last)
ii. # draw the smallest ticket
    parentTicket &lt;-- min(sortedTickets)
2. Run it through VRF and get determinstic output
i. # take the VDFOutput of that ticket as input, specifying the personalization (see data-structures)
        input &lt;-- VRFPersonalization.Ticket | parentTicket.VDFOutput
ii. # run it through the VRF and store the VRFProof in the new ticket
        newTicket.VRFProof &lt;-- ECVRF_prove(SK, input)
iii. # draw a deterministic output from this
        VRFOutput &lt;-- ECVRF_proof_to_hash(newTicket.VRFProof)
3. Run that deterministic output through a VDF
i. # run eval with our VDF and its evaluation k on VRFOutput
        y, pi &lt;-- VDF_eval(ek, VRFOutput)
ii. # Store the output and proof in our ticket
        newTicket.VDFOutput &lt;-- y
        newTicket.VDFProof  &lt;-- pi
4. Return the new ticket</code></pre></div></li>
</ul>

<h4>Running a leader election</h4>

<p>Now, a miner must also check whether they are eligible to mine a block in this round. For how Election Proofs are validated, see <a href="mining.md#election-validation">election validation</a>.</p>

<p>To do so, the miner will use tickets from K rounds back as randomness to uniformly draw a value from 0 to 1. Comparing this value to their power, they determine whether they are eligible to mine. A user&rsquo;s <code>power</code> is defined as the ratio of the amount of storage they proved as of their last PoSt submission to the total storage in the network as of the current block.</p>

<p>Succinctly, the process of crafting a new <code>ElectionProof</code> in round <code>N</code> is as follows. We use:</p>

<ul>
<li>The ECVRF algorithm (must yield a pseudorandom, deterministic output) from <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">Goldberg et al. Section 5</a>, with:

<ul>
<li>Sha256 for our hashing function</li>
<li>Secp256k1 for our curve</li>
</ul></li>
</ul>

<p>Note: We draw the miner power from the prior round. This means that if a miner wins a block on their ProvingPeriodEnd even if they have not yet resubmitted a PoSt, they retain their power (until the next round).</p>

<p>At round N:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: parentTickets from N-K, miner&#39;s public key PK, miner&#39;s secret key SK, the Storage Market actor S
Output: 1 or 0

0. Prepare new election proof
    i. newEP &lt;-- New()
1. Determine the miner&#39;s power fraction
    i. # Determine total storage this round
        S &lt;-- storageMarket(N)
        p_n &lt;-- S.GetTotalStorage()
    ii. # Determine own power at prior tipSet
        p_m &lt;-- GetMinersPowerAt(N-1, self.PK)
    iii. # Get power fraction
  		p_f &lt;-- p_m/p_n
2. Draw parentTicket from K blocks back (see ticket creation above for example, using 1 block back) 
3. Run it through VRF and get determinstic output
    i. # take the VDFOutput of that ticket as input, specified for the appropriate operation type
        input &lt;-- VRFPersonalization.ElectionProof | parentTicket.VDFOutput
    ii. # run it through the VRF and store the VRFProof in the new ticket
        newEP.VRFProof &lt;-- ECVRF_prove(SK, input)
    iii. # draw a deterministic, pseudorandom output from this
        VRFOutput &lt;-- ECVRF_proof_to_hash(newEP.VRFProof)
3. Determine if the miner drew a winning lottery ticket
    # Conceptually we are mapping the pseudorandom, deterministic VRFOutput onto [0,1] by dividing by 2^HashLen (64 Bytes using Sha256) and comparing that to the miner&#39;s power (portion of network storage).
    # In practice, we actually multiply the power fraction by 2^HashLen for comparison with the ticket value in order to avoid dealing with floats.
    i.  # Map the miner&#39;s power onto [0, 2^HashLen] (64 Bytes using sha256)
        normalized_power &lt;-- p_f * 2^HashLen
    ii. # Compare the miner&#39;s power fraction to the value of the ticket drawn: more power means win more often.
        # winning ticket
        if readLittleEndian(VRFOutput) &lt;= normalized_power
            return newEP
        # otherwise parentTicket is not a winning lottery ticket
        else 
            Return 0</code></pre></div>
<p>If the miner scratches a winning ticket in this round, it can use newEP, along with a newTicket to generate and publish a new block (see <a href="#block-generation">Block Generation</a>). Otherwise, it waits to hear of another block generated in this round.</p>

<p>It is important to note that every block contains two artifacts: one, a ticket derived from last block&rsquo;s ticket to prove that they have waited the appropriate delay, and two, an election proof derived from the ticket <code>K</code> rounds back used to run leader election.</p>

<h5>Losing Tickets</h5>

<p>In the case that everybody draws a losing ticket in a given round (i.e. no miner is eligible to produce a block), every miner can run leader election again by &ldquo;scratching&rdquo; (attempting to generate a new <code>ElectionProof</code> from) the next ticket in the chain. That is, miners will now use the ticket sampled <code>K-1</code> rounds back to generate a new <code>ElectionProof</code>. They can then compare that proof with their current power fraction. This is repeated until a miner scratches a winning ticket and can publish a block (see <a href="#block-generation">Block Generation</a>).</p>

<p>In addition to each attempted <code>ElectionProof</code> generation, the miner will need to extend the ticket chain by generating another new ticket. They use the ticket they generated in the prior round, rather than the prior block&rsquo;s (as is normally used). This proves appropriate delay (given that finding a winning Ticket has taken multiple rounds).</p>

<p>Thus, each time it is discovered that nobody has won in a given round, every miner should append a new ticket to their would-be block&rsquo;s <code>Ticket</code> array. This continues until some miner finds a winning ticket (see below), ensuring that the ticket chain remains at least as long as the block chain.</p>

<p>The length of repeated losing tickets in the ticket chain (equivalent to the length of generated tickets referenced by a single block, or the length of the <code>Tickets</code> array) decreases exponentially in the number of repeated losing tickets. In the unlikely case the number of losing tickets drawn by miners grows larger than the randomness lookback <code>K</code> (i.e. if a miner runs out of existing tickets on the ticket chain for use as randomness), a miner should proceed as usual using new tickets generated in this epoch for randomness. This has no impact on the protocol safety/validity.</p>

<p>New blocks (with multiple tickets) will have a few key properties:</p>

<ul>
<li>All tickets in the <code>Tickets</code> array are signed by the same miner &ndash; to avoid grinding through out-of-band collusion between miners exchanging tickets.</li>
<li>The <code>ElectionProof</code> was correctly generated from the ticket <code>K-|Tickets|</code> (with <code>|Tickets|</code> the length of the <code>Tickets</code> array) rounds back.</li>
</ul>

<p>This means that valid <code>ElectionProof</code>s can be generated from tickets in the middle of the <code>Tickets</code> array.</p>

<h5>A note on miners&#39; &#39;power fraction&#39;</h5>

<p>The portion of blocks a given miner generates (and so the block rewards they earn) is proportional to their <code>Power Fraction</code> over time.</p>

<p>This means miners should not be able to mine using power they have not yet proven. Conversly, it is acceptable for miners to mine with a slight delay between their proving storage and that proven storage being reflected in leader election. This is reflected in the height at which the <a href="actors.md#storage-market-actor">storage market actor</a>&rsquo;s <code>GetTotalStorage</code> and <code>PowerLookup</code> methods are called, as outlined <a href="#checking-election-results">above</a>.</p>

<p>The miner retrieves the appropriate state of the <code>storage market actor</code> at the height at which they submitted their last valid PoSt: that way, they account for storage which was already proven valid, i.e. they are mining with the power they had in their last proving period. That is the miner will get their own power at height <code>miner.ProvingPeriodEnd - miner.ProvingPeriod</code>.</p>

<p>This power is then compared to the total network power at the current height, in order to account for recent power changes from other miners (and so all miners attempting to mine in this round share 100% of the power).</p>

<p>To illustrate this, an example:</p>

<p>Miner M1 has a provingPeriod of 30. M1 submits a PoST at height 39. Their next <code>provingPeriodEnd</code> will be 69, but M1 can submit a new PoST at any height X, for X in (39, 69]. Let&rsquo;s assume X is 67.</p>

<p>At height Y in (39, 67], M1 will attempt to generate an <code>ElectionProof</code> using the storage market actor from height 39 for their own power (and an actor from Y for total network power); at height 68, M1 will use the storage market actor from height 67 for their own power, and the storage market actor from height 68 for total power and so on.</p>

<h4>Block Generation</h4>

<p>Once a miner has a winning election proof generated over <code>i</code> rounds and <code>i</code> corresponding tickets, they may create a block. For more on this, see the <a href="mining.md#block-creation">Mining spec</a>.</p>

<p><div id="algorithms__expected_consensus__chain_selection"></div>
<div id="algorithms__expected_consensus__chain_selection"></div><h3>Chain Selection</h3></p>

<p>Just as there can be 0 miners win in a round, multiple miners can be elected in a given round. This in turn means multiple blocks can be created in a round. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round.</p>

<h4>Tipsets</h4>

<p>All valid blocks generated in a round form a <code>TipSet</code> that participants will attempt to mine off of in the subsequent round (see above). TipSets are valid so long as:</p>

<ul>
<li>All blocks in a TipSet have the same parent TipSet</li>
<li>All blocks in a TipSet have the same number of tickets in their <code>Tickets</code> array</li>
</ul>

<p>These conditions imply that all blocks in a TipSet were mined at the same height. This rule is key to helping ensure that EC converges over time. While multiple new blocks can be mined in a round, subsequent blocks all mine off of a TipSet bringing these blocks together. The second rule means blocks in a TipSet are mined in a same round.</p>

<p>The blocks in a tipset have no defined order in representation. During state computation, blocks in a tipset are processed in order of block ticket, breaking ties with the block CID bytes.</p>

<p>Due to network propagation delay, it is possible for a miner in round N+1 to omit valid blocks mined at round N from their TipSet. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol.</p>

<p><div id="algorithms__expected_consensus__chain_weighting"></div>
<h4>Chain Weighting</h4></p>

<p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on &lsquo;one true chain&rsquo;, with every block adding to the chain&rsquo;s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin&rsquo;s case, the most storage provided.</p>

<p>The weight at each block is equal to its <code>ParentWeight</code> plus that block&rsquo;s delta weight. Delta
weight is a term P times the sum of a constant <code>V</code> times the number of blocks included in that TipSet in the given round (can only be calculated in the next round), and <code>X</code> - a function of the total power in the network as reported in the Power Table. P will be equal to some term P_i^P_n and seeks to punish selfish mining. So we have:</p>

<p><code>Weight = ParentWeight + P(V*NumBlocksMinedInThisRound + X)</code></p>

<p>The weight should be rounded down to its fourth decimal at each height (i.e. each time it is recalculated).</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Note that <span class="k">if</span> your implementation does not allow <span class="k">for</span> rounding to the fourth decimal, miners should apply the <span class="o">[</span>tie-breaker below<span class="o">](</span><span class="c1">#selecting-between-tipsets-with-equal-weight). Weight changes will be on the order of single digit numbers on expectation, so this should not have an outsized impact on chain consensus across implementations.</span></code></pre></div>
<p>The exact value for these parameters remain to be determined, but for illustration, we can set:</p>

<ul>
<li><code>V = 2 * number of blocks in the round</code></li>
<li><code>X = log(TotalPower in Power Table)</code></li>
<li><code>P_i = .87</code></li>
<li><code>P_n = the number of tickets in this block's Ticket array</code> if that number is  &gt;= 3, 0 otherwise.</li>
</ul>

<p><code>ParentWeight</code> is the aggregate chain weight of a given block&rsquo;s parent set. It is calculated as
the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given TipSet should have
the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the
computation a bit easier, a block&rsquo;s <code>ParentWeight</code> is stored in the block itself (otherwise
potentially long chain scans would be required to compute a given block&rsquo;s weight).</p>

<h4>Selecting between TipSets with equal weight</h4>

<p>When selecting between TipSets of equal weight, a miner chooses the one with the smallest min ticket (by bytewise comparison).</p>

<p>In the case where two TipSets of equal weight have the same min ticket, the miner will compare the next smallest ticket (and select the TipSet with the next smaller ticket). This continues until one TipSet is selected.</p>

<p>The above case may happen in situations under certain block propagation conditions. Assume three blocks B, C, and D have been mined (by miners 1, 2, and 3 respectively) off of block A, with minTicket(B) &lt; minTicket&copy; &lt; minTicket (D).</p>

<p>Miner 1 outputs their block B and shuts down. Miners 2 and 3 both receive B but not each others&rsquo; blocks. We have miner 2 mining a TipSet made of B and C and miner 3 mining a TipSet made of B and D. If both succesfully mine blocks now, other miners in the network will receive new blocks built off of TipSets with equal weight and the same smallest ticket (that of block B). They should select the block mined atop [B, C] since minTicket&copy; &lt; minTicket(D).</p>

<p>The probability that two TipSets with different blocks would have all the same tickets can be considered negligible: this would amount to finding a collision between two 256-bit (or more) collision-resistant hashes.</p>

<h4>Slashing</h4>

<p>See the <a href="faults.md">Faults spec</a> for implementation details.</p>

<p>Due to the existence of potential forks, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p>

<p>This is detectable when a miner submits two blocks that satisfy either of the following &ldquo;slashing conditions&rdquo;:</p>

<p>(1) one block contains at least one ticket in its ticket array generated at the same round as one of the tickets in the other block&rsquo;s ticket array.
(2) one block&rsquo;s parent is a TipSet that could have validly included the other block according to TipSet validity rules, however the parent of the first block does not include the other block.</p>

<ul>
<li>While it cannot be proven that a miner omits known blocks from a TipSet in general (i.e. network latency could simply mean the miner did not receive a particular block) in this case it can be proven because a miner must be aware of a block they mined in a previous round.</li>
</ul>

<p>Any node that detects this occurring should take both block headers, and call <a href="actors.md#slashconsensusfault"><code>storagemarket.SlashConsensusFault</code></a>. The network will then take all of that node&rsquo;s collateral, give a portion of it to
the reporter, and keep the rest.</p>

<p>TODO: It is unclear that rewarding the reporter any more than gas fees is the right thing to do. Needs thought. Tracking issue: <a href="https://github.com/filecoin-project/specs/issues/159">https://github.com/filecoin-project/specs/issues/159</a></p>

<p>Note: One may wonder what prevents miners from simply breaking up their power into multiple unlinkable miner actors  (or sybils) that will be able to mine on multiple chains without being caught mining at the same round at the same time. Read more about this <a href="https://github.com/filecoin-project/consensus/issues/32">here</a>.</p>

<div id="algorithms__expected_consensus__implementation_notes"></div><h3>Implementation Notes</h3>

<ul>
<li>When selecting messages from the mempool to include in the block, be aware that other miners may also generate blocks during this round, and to maximize fee earnings it may be best to select some messages at random (second in a duplicate earns no fees).</li>
</ul>

<div id="algorithms__expected_consensus__open_questions"></div><h3>Open Questions</h3>

<ul>
<li>Parameter K</li>
<li>VDF difficulty adjustment</li>
</ul>




</div>

  

  
    








<div id="algorithms__proof_of_replication">

<h2>
  Proof of Replication
</h2>



<p>This section describes the specific Proof-of-Replication used in Filecoin called <em>ZigZag</em>. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.</p>

<p>ZigZag has been presented by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.</p>

<h2 id="introduction">Introduction</h2>

<h3 id="background-on-proof-of-replication">Background on Proof-of-Replication</h3>

<p><em>Proof-of-Replication</em> enables a prover <em>P</em> to convince a verifier <em>V</em> that <em>P</em> is storing a replica <em>R</em>, a physically independent copy of some data <em>D</em>, unique to <em>P</em>. The scheme is defined by a tuple of polynomial time algorithms (<em>Setup</em>, Replication, <em>Prove</em>, <em>Verify</em>). The assumption is that generation of a replica after <em>Replicate</em>  must be difficult (if not impossible) to generate.</p>

<ul>
<li><em>Setup</em>: On setup, the public parameters of the proving systems are set.</li>
<li><em>Replicate</em>: On replication, either a party or both (depending on the scheme, in our case the prover only!) generate a unique permutation of the original data <em>D</em>, which we call replica <em>R</em>.</li>
<li><em>Prove</em>: On receiving a challenge, the prover must generate a proof that it is in possession of the replica and that it was derived from data <em>D</em>. The prover must only be able to respond to the challenge successfully if it is in possession of the replica, since would be difficult (if not impossible) to generate a replica that can be used to generate the proof at this stage</li>
<li><em>Verify</em>: On receiving the proof, the verifier checks the validity of the proof and accepts or rejects the proof.</li>
</ul>

<div class="mermaid" align="center">
sequenceDiagram
    Note right of Prover: CommD
    Prover-->>Prover: R, CommR ← Replicate(D) 
    Prover->>Verifier: CommR
    Verifier-->>Verifier: Generate random challenge
    Verifier->>Prover: challenge
    Prover-->>Prover: proof ← Prove(D, R, challenge)
    Prover->>Verifier: proof
</div>

<h4 id="time-bounded-proof-of-replication">Time-bounded Proof-of-Replication</h4>

<p><strong>Timing assumption</strong>. <em>Time-bounded Proof-of-Replication</em> are constructions of PoRep with timing assumptions. The assumption is that generation of the replica (hence the <em>Replication</em>) takes some time <em>t</em> that is substantially larger than the time it takes to produce a proof (hence <em>time(Prove)</em>) and the round-trip time (<em>RTT</em>) for sending a challenge and receiving a proof.</p>

<p><strong>Distinguishing Malicious provers</strong>. A malicious prover that does not have <em>R</em>, must obtain it (or generate it), before the <em>Prove</em> step. A verifier can distinguish an honest prover from a malicious prover, since the malicious one will take too long to answer the challenge. A verifier will reject if receiving the proof from the prover takes longer than a timeout (bounded between proving time and replication time).</p>

<h3 id="background-on-zigzag">Background on ZigZag</h3>

<p><em>ZigZag</em> is a specific Proof-of-Replication construction that we use in Filecoin. ZigZag has been designed by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.  In high level, ZigZag ensures that the <em>Replicate</em> step is a slow non-parallelizable sequential process by using some special type of graphs called Depth Robust Graphs (we refer to as &ldquo;DRG&rdquo;).</p>

<p><strong>Encoding using DRGs</strong>. By positioning data blocks into nodes in the DRG, we sequentially encode each node in the graph using its encoded parents. The depth robustness property of these graphs ensure that this process is not likely to be parallelizable.</p>

<p><strong>Layering DRGs</strong>. ZigZag repeates this encoding by layering DRG graphs <code>LAYERS</code> times. The data represented in each DRG layer is the data encoded in the previous layer. We connect different layers using Bipartite Expander Graphs and at each layer, we reverse the graph edges with a technique which we call zigzag. The combination of DRGs, expander graphs and zigzag guarantee the security property of PoRep. The final encoded layer is the final replica.</p>

<p><strong>Generating ZigZag proofs</strong>. Given the following public parameters:</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details)</li>
<li><code>CommD</code> is the Merkle Tree root hash of the input data to the first layer</li>
<li><code>CommRStar</code> is the hash of the concatenation of the <code>ReplicaId</code> and all the <code>CommR</code>s.</li>
<li><code>CommRLast</code> is the hash of the last encoded DRG layer.</li>
</ul>

<p>A ZigZag proof proves that some data whose committment is <code>CommD</code> has been used to run a <code>Replicate</code> algorithm and generated some data whose commitment is <code>CommRLast</code>.</p>

<p>A ZigZag proof consists of a set of challenged DRG nodes (both encoded and unencoded) for each layer, a set of parent nodes for each challenged node and a Merkle tree inclusion proof for each node provided. The verifier can then verify the correct encoding of each node and that the nodes given were consistent with the provers&rsquo; commitments.</p>

<p><strong>Making proofs succinct with SNARKs</strong>: The proof size in the ZigZag is too large for blockchain usage (~100MB), mostly due to the large amount of Merkle tree inclusion proofs required to achieve security. We use SNARKs to generate a proof of knowledge of a correct ZigZag proof. In other words, we implement the ZigZag proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>The SNARK circuit proves that given a Merkle root <code>CommD</code>, <code>CommRLast</code>, and <code>commRStar</code>, the prover knew the correct replicated data at each layer.</p>

<h3 id="porep-in-filecoin">PoRep in Filecoin</h3>

<p>Proof-of-Replication proves that a Storage Miner is dedicating unique storage for each <strong><em>sector</em></strong>. Filecoin Storage Miners collect new clients&rsquo; data in a sector, run a slow encoding process (called <code>Seal</code>) and generate a proof (<code>SealProof</code>) that the encoding was generated correctly.</p>

<p>In Filecoin, PoRep provides two guarantees: (1) <em>space-hardness</em>: Storage Miners cannot lie about the amount of space they are dedicating to Filecoin in order to gain more power in the consensus; (2) <em>replication</em>: Storage Miners are dedicating unique storage for each copy of their clients data.</p>

<p>Glossary:</p>

<ul>
<li><strong><em>sector:</em></strong> a fixed-size block of data of <code>SECTOR_SIZE</code> bytes which generally contains clients&rsquo; data.</li>
<li><strong><em>unsealed sector:</em></strong> a concrete representation (on disk or in memory) of a sector&rsquo;s that follows the &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</li>
<li><strong><em>sealed sector:</em></strong>  a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an <strong><em>unsealed sector</em></strong>. A sector contains one or more <strong><em>pieces</em></strong>.</li>
<li><strong><em>piece:</em></strong> a block of data of at most <code>SECTOR_SIZE</code> bytes which is generally a client&rsquo;s file or part of.</li>
</ul>

<h2 id="zigzag-construction">ZigZag Construction</h2>

<h3 id="public-parameters">Public Parameters</h3>

<p>The following public parameters are used in the ZigZag Replication and Proof Generation algorithms:</p>

<p>TODO: the Appendix should explain why we picked those values</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>SECTOR_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the DRG in bytes</td>
<td align="right"><code>68,719,476,736</code></td>
</tr>

<tr>
<td><code>LAYERS</code></td>
<td><code>uint</code></td>
<td>Number of Depth Robust Graphs stacked layers.</td>
<td align="right"><code>10</code></td>
</tr>

<tr>
<td><code>BASE_DEGREE</code></td>
<td><code>uint</code></td>
<td>In-Degree of each Depth Robust Graph.</td>
<td align="right"><code>5</code></td>
</tr>

<tr>
<td><code>EXPANSION_DEGREE</code></td>
<td><code>uint</code></td>
<td>Degree of each Bipartite Expander Graph to extend dependencies between layers.</td>
<td align="right"><code>8</code></td>
</tr>

<tr>
<td><code>GRAPH_SEED</code></td>
<td><code>uint</code></td>
<td>Seed used for random number generation in <code>baseParents</code>.</td>
<td align="right"><code>TODO</code></td>
</tr>

<tr>
<td><code>NODE_SIZE</code></td>
<td><code>uint</code></td>
<td>Size of each node in bytes.</td>
<td align="right"><code>32B</code></td>
</tr>
</tbody>
</table>

<p>The following constants are computed from the public parameters:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">computation</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>PARENTS_COUNT</code></td>
<td><code>uint</code></td>
<td>Total number of parent nodes</td>
<td align="right"><code>EXPANSION_DEGREE + BASE_DEGREE</code></td>
<td><code>13</code></td>
</tr>

<tr>
<td><code>GRAPH_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the graph</td>
<td align="right"><code>SECTOR_SIZE / NODE_SIZE</code></td>
<td><code>2,147,483,648</code></td>
</tr>

<tr>
<td><code>TREE_DEPTH</code></td>
<td><code>uint</code></td>
<td>Height of the Merkle Tree of a sector</td>
<td align="right"><code>LOG_2(GRAPH_SIZE)</code></td>
<td><code>31</code></td>
</tr>
</tbody>
</table>

<p>The following additional public parameters are required:</p>

<ul>
<li><code>TAPER</code> : <code>Float</code>: Fraction of each layer&rsquo;s challenges by which to reduce next-lowest layer&rsquo;s challenge count.</li>
<li><code>TAPER_LAYERS</code>: <code>uint</code>: Number of layers
<code>Data</code> is a byte array initialized to the content of <strong><em>unsealed sector</em></strong> and will be mutated in-place by the replication process.</li>
</ul>

<h3 id="hash-functions">Hash Functions</h3>

<p>We have describe three hash functions:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>size of input</th>
<th>size of output</th>
<th>construction</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>KDFHash</code></td>
<td>Hash function used as a KDF to derive the key to encode a single node.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>Blake2s-256</code></td>
</tr>

<tr>
<td><code>CommRHash</code></td>
<td>Hash function used to hash all the commitments at every layer (<code>CommR</code>s) to generate <code>CommRStar</code></td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>Blake2s-256</code></td>
</tr>

<tr>
<td><code>RepCompress</code></td>
<td>Collision Resistant Hash function used for the Merkle tree.</td>
<td>2 x <code>32B</code> + integer height</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>

<tr>
<td><code>RepHash</code></td>
<td>Merkle-tree based hash function used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication</td>
<td>TODO</td>
<td><code>32B</code></td>
<td>It uses <code>RepCompress</code></td>
</tr>
</tbody>
</table>

<h4 id="rephash">RepHash</h4>

<p><code>RepHash</code> is Merkle-tree based hash function used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication. The tree is a binary balanced Merkle-tree. The leaves of the Merkle tree are pairs of adjacent nodes.</p>

<p><code>RepHash</code> inputs MUST respect a valid Storage Format.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">node</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uint8</span>

<span class="c1">// Create and return a balanced binary Merkle tree and its root commitment.
</span><span class="c1">// len(leaves) must be a power of 2.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepHash</span><span class="p">(</span><span class="nx">leaves</span> <span class="p">[]</span><span class="nx">node</span><span class="p">)</span> <span class="p">([][]</span><span class="nx">node</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rows</span> <span class="p">=</span> <span class="p">[][]</span><span class="nx">node</span>
	
	<span class="nx">currentRow</span> <span class="o">:=</span> <span class="nx">leaves</span>
	<span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">currentRow</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">rows</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">currentRow</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">nextRow</span> <span class="p">[]</span><span class="nx">node</span>

		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">right</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

			<span class="c1">// NOTE: Depending on choice of RepCompress, heightPart may be trimmed to fewer than 8 bits.
</span><span class="c1"></span>			<span class="nx">heightPart</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint8</span><span class="p">{</span><span class="nx">height</span><span class="p">}</span>
			
			<span class="nx">input1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">heightPart</span><span class="p">,</span> <span class="nx">left</span><span class="o">...</span><span class="p">)</span>
			<span class="nx">input</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">input1</span><span class="p">,</span> <span class="nx">right</span><span class="o">...</span><span class="p">)</span>
			<span class="nx">hashed</span> <span class="p">=</span> <span class="nf">RepCompress</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
			<span class="nx">nextRow</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nextRow</span><span class="p">,</span> <span class="nx">hashed</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">currentRow</span> <span class="p">=</span> <span class="nx">nextRow</span>
	<span class="p">}</span>
    <span class="c1">// The tree returned here is just a vector of rows for later use. Its representation is not part of the spec.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">currentRow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<h3 id="zigzag-graph">ZigZag Graph</h3>

<p>The slow sequential encoding required is enforced by the depth robusness property of the ZigZag graph.</p>

<p><strong>Encoding with ZigZag</strong>: The data from a sector (of size <code>SECTOR_SIZE</code>) is divided in <code>NODE_SIZE</code> nodes (for a total of <code>GRAPH_SIZE</code> nodes) and arranged in a directed acyclic graph. The structure of the graph is used to encode the data sequentially: in order to encode a node, its parents must be encoded (see the &ldquo;Layer Replication&rdquo; section below). We repeat this process for <code>LAYERS</code> layers, where the input to a next layer is the output of the previous one.</p>

<p><strong>Generating the ZigZag graph</strong>: The ZigZag graph is divided in <code>LAYERS</code> layers. Each layer is a directed acyclic graph and it combines a Depth Robust Graph (DRG) and a Bipartite Expander graph.</p>

<p>We provide an algorithm (<code>ZigZag</code>) which computes the parents of a node. In high level, the parents of a node are computed by combining two algorithms: some parents (<code>BASE_DEGREE</code> of them) are computed via the <code>BucketSample</code> algorithm, others (<code>EXPANSION_DEGREE</code> of them) are computer via the <code>Chung</code> algorithm.In addition, every odd layer performs the &ldquo;ZigZag&rdquo; technique which reverts some edges and inverts some nodes.</p>

<h4 id="zigzag-zigzag-graph-algorithm"><code>ZigZag</code>: ZigZag Graph algorithm</h4>

<p>Overview: on even layers, compute the DRG and the Bipartite Expander parents using respectively <code>BucketSample</code> and <code>ChungExpander</code>, on odd layers, compute the inverted DRG parents (using <code>BucketSample</code> on the inverted node: <code>GRAPH_SIZE - node - 1</code> and inverting the resulting parents <code>GRAPH_SIZE - parent -1</code> for each parent) and the reverted Biparate Expander parents (by reverting the edges)</p>

<h5 id="inputs">Inputs</h5>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>node</code></td>
<td>The node for which the parents are being computed</td>
<td><code>uint</code></td>
</tr>

<tr>
<td><code>layer</code></td>
<td>The layer of the ZigZag graph</td>
<td><code>uint</code></td>
</tr>
</tbody>
</table>

<h5 id="outputs">Outputs</h5>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>parents</code></td>
<td>The parents of node <code>node</code> on layer <code>layer</code></td>
<td><code>[PARENTS_COUNT]uint</code></td>
</tr>
</tbody>
</table>

<h5 id="algorithm">Algorithm</h5>

<ul>
<li><p>If the <code>layer</code> is even:</p>

<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Compute <code>expanderParents = ChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>drgParents</code> and <code>expanderParents</code></li>
</ul></li>

<li><p>If the <code>layer</code> is odd:</p>

<ul>
<li>Invert the <code>node</code>: <code>inverted_node = GRAPH_SIZE - inverted_node - 1</code></li>
<li>Compute the inverted DRG parents <code>invertedDRGParents</code>:</li>
<li>Compute <code>drgParents = BucketSample(n)</code></li>
<li>For each <code>parent</code> in <code>drgParents</code>:

<ul>
<li><code>invertedDRGParents.push(GRAPH_SIZE - parent - 1)</code></li>
</ul></li>
<li>Compute the reversed Expander parents: <code>reversedExpanderParents</code>:</li>
<li>Compute <code>reversedExpanderParents = InverseChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>invertedDrgParents</code> and <code>reversedExpanderParents</code></li>
</ul></li>
</ul>

<h5 id="pseudocode">Pseudocode</h5>

<p>We provide below a more succinct representation of the algorithm:</p>

<pre><code>func ZigZag(node uint, layer uint) {

  if layer % 2 == 0 {
  	// On even layers
  	let drgParents = BucketSample(node)
  	let expanderParents = ChungExpander(node)
  	return concat(drgParents, expanderParents)
  } else {
    // On odd layers
  	
  	// Inverting DRG parents
    let inverted_node = GRAPH_SIZE - node - 1
  	let drgParents = BucketSample(inverted_node)
  	let invertedDrgParents = []
  	for i in 0..drgParents.len() {
      invertedDrgParents.push(GRAPH_SIZE - drgParents[i] - 1)
  	}
  	// Reverting ChungExpander
		let reversedExpanderParents = ReversedChungExpander(node)
  	return concat(invertedDrgParents, reversedExpanderParents)
  }
}
</code></pre>

<h5 id="tests">Tests</h5>

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST not be greater than <code>GRAPH_SIZE-1</code> and lower than <code>0</code></li>
<li>If <code>layer</code> is even:

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST be greater than <code>node</code></li>
<li>EXCEPT: if <code>node</code> is <code>0</code>, then all parents MUST be <code>0</code></li>
</ul></li>
<li>if <code>layer</code> is odd:

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST be less than <code>node</code></li>
<li>EXCEPT: if <code>node</code> is <code>GRAPH_SIZE-1</code>, then all parents MUST be <code>GRAPH_SIZE-1</code></li>
</ul></li>
</ul>

<h5 id="time-space-tradeoff">Time-space tradeoff</h5>

<p>Computing the parents using both <code>BucketSample</code> and <code>ChungExpander</code> (and <code>Reverse</code>) for every layer can be an expensive operation, however, this can be avoided by caching the parents. It is important to note that all the odd layers and all the even layers have the same structure.</p>

<h4 id="bucketsample-depth-robust-graphs-algorithm"><code>BucketSample</code>: Depth Robust Graphs algorithm</h4>

<p>This section describes how to compute the &ldquo;base parents&rdquo; of the ZigZag graph, which is the equivalent of computing the parents of a Depth Robust Graph.</p>

<p>The properties of DRG graphs guarantee that a sector has been encoded with a slow, non-parallelizable process. We use the <code>BucketSample</code> algorithm that is based on DRSample (<a href="https://acmccs.github.io/papers/p1001-alwenA.pdf">ABH17</a>) and described in <a href="https://web.stanford.edu/~bfisch/porep_short.pdf">FBGB18</a> and generates a directed acyclic graph of in-degree <code>BASE_DEGREE</code>.</p>

<p><code>BucketSample</code> DRG graphs are random graphs that can be deterministically generated from a seed; different seed lead with high probability to different graphs. In ZigZag, we use the same seed <code>GRAPH_SEED</code> for each layer of the ZigZag graph such that they are all based on the same DRG graph.</p>

<p>The parents of any node can be locally computed without computing the entire graph. We call the parents of a node calculated in this way <em>base parents</em>.</p>

<h5 id="pseudocode-1">Pseudocode</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BucketSample</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[</span><span class="nx">BASE_DEGREE</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">node</span> <span class="p">{</span>
        <span class="c1">// Special case for the first node, it self references.
</span><span class="c1"></span>        <span class="c1">// Special case for the second node, it references only the first one.
</span><span class="c1"></span>        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">BASE_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="p">}</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nx">rng</span> <span class="o">:=</span> <span class="nx">ChaChaRng</span><span class="p">.</span><span class="nf">from_seed</span><span class="p">(</span><span class="nx">GRAPH_SEED</span><span class="p">)</span>

            <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">BASE_DEGREE</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// iterate over m meta nodes of the ith real node
</span><span class="c1"></span>                <span class="c1">// simulate the edges that we would add from previous graph nodes
</span><span class="c1"></span>                <span class="c1">// if any edge is added from a meta node of jth real node then add edge (j,i)
</span><span class="c1"></span>                <span class="nx">logi</span> <span class="o">:=</span> <span class="nf">floor</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span><span class="p">))</span>
                <span class="nx">j</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nf">gen</span><span class="p">()</span> <span class="o">%</span> <span class="nx">logi</span>
                <span class="nx">jj</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span> <span class="o">+</span> <span class="nx">k</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="nx">backDist</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nf">gen_range</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="nx">jj</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nx">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">out</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">backDist</span><span class="p">)</span> <span class="o">/</span> <span class="nx">BASE_DEGREE</span>

                <span class="c1">// remove self references and replace with reference to previous node
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">out</span> <span class="o">==</span> <span class="nx">node</span> <span class="p">{</span>
                    <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">node</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">out</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">sort</span><span class="p">(</span><span class="nx">parents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="chungexpander-bipartite-expander-graphs"><code>ChungExpander</code>: Bipartite Expander Graphs</h4>

<p>TODO: explain why we link nodes in the current layer</p>

<p>Every node in a layer has <code>EXPANSION_DEGREE</code> parents that are generated via the following algorithm.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChungExpander</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">parents</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">)</span>

	<span class="nx">feistelKeys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// TODO
</span><span class="c1"></span>  
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span> <span class="o">+</span> <span class="nx">i</span>
    <span class="nx">transformed</span> <span class="o">:=</span> <span class="nf">feistelPermute</span><span class="p">(</span><span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">feistelKeys</span><span class="p">)</span>
    <span class="nx">other</span> <span class="o">:=</span> <span class="nx">transformed</span> <span class="o">/</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="k">if</span> <span class="nx">other</span> <span class="p">&lt;</span> <span class="nx">node</span> <span class="p">{</span>
      <span class="nx">parents</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">other</span>
      <span class="nx">p</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ReverseChungExpander</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">parents</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">)</span>

	<span class="nx">feistelKeys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// TODO
</span><span class="c1"></span>  
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span> <span class="o">+</span> <span class="nx">i</span>
    <span class="nx">transformed</span> <span class="o">:=</span> <span class="nf">invertFeistelPermute</span><span class="p">(</span><span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">feistelKeys</span><span class="p">)</span>
    <span class="nx">other</span> <span class="o">:=</span> <span class="nx">transformed</span> <span class="o">/</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="k">if</span> <span class="nx">other</span> <span class="p">&gt;</span> <span class="nx">node</span> <span class="p">{</span>
      <span class="nx">parents</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">other</span>
      <span class="nx">p</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="time-space-tradeoff-1">Time-Space tradeoff</h5>

<p>Computing these parents can be expensive (especially due to the hashing required by the Feistel algorithm). A miner can trade this computation by storing the expansion parents and the reversed expansion parents.</p>

<h5 id="feistel-construction">Feistel construction</h5>

<p>We use three rounds of Feistel as a permutation to generate the parents of the Bipartite Expander graph.</p>

<p>TODO: Add <code>FEISTEL_ROUNDS</code> and <code>FEISTEL_BYTES</code> (or find its definitions)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">numElements</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">u</span> <span class="o">:=</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>

    <span class="nx">while</span> <span class="nx">u</span> <span class="o">&gt;=</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">u</span> <span class="p">=</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// Since we are representing `numElements` using an even number of bits,
</span><span class="c1"></span>    <span class="c1">// that can encode many values above it, so keep repeating the operation
</span><span class="c1"></span>    <span class="c1">// until we land in the permitted range.
</span><span class="c1"></span>
    <span class="k">return</span> <span class="nx">u</span>
<span class="p">}</span>

<span class="c1">// Inverts the `permute` result to its starting value for the same `key`.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">invertPermute</span><span class="p">(</span><span class="nx">numElements</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">u</span> <span class="o">:=</span> <span class="nf">feistelDecode</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>

    <span class="nx">while</span> <span class="nx">u</span> <span class="o">&gt;=</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">u</span> <span class="p">=</span> <span class="nf">feistelDecode</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">keys</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">u</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span> <span class="o">:=</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
        <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">left</span> <span class="p">^</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span>  <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="p">|</span> <span class="nx">right</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">numElements</span> <span class="o">:=</span> <span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="nx">nextPow4</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">halfBits</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nx">while</span> <span class="nx">nextPow4</span> <span class="p">&lt;</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">nextPow4</span> <span class="o">*=</span> <span class="mi">4</span>
        <span class="nx">halfBits</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="nx">rightMask</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">leftMask</span> <span class="p">=</span> <span class="nx">rightMask</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span>

    <span class="nx">right</span> <span class="o">:=</span> <span class="nx">index</span> <span class="o">&amp;</span> <span class="nx">rightMask</span>
    <span class="nx">left</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&amp;</span> <span class="nx">leftMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">halfBits</span>

    <span class="k">return</span>  <span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Round function of the Feistel network: `F(Ri, Ki)`. Joins the `right`
</span><span class="c1">// piece and the `key`, hashes it and returns the lower `uint32` part of
</span><span class="c1">// the hash filtered trough the `rightMask`.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">right</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">rightMask</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="p">[</span><span class="nx">FEISTEL_BYTES</span><span class="p">]</span><span class="kt">uint</span>

    <span class="kd">var</span> <span class="nx">r</span> <span class="kt">uint</span>
    <span class="k">if</span> <span class="nx">FEISTEL_BYTES</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

        <span class="nx">hash</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

        <span class="nx">r</span> <span class="p">=</span>   <span class="nx">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

        <span class="nx">hash</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

        <span class="nx">r</span> <span class="p">=</span>   <span class="nx">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nx">rightMask</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">feistelDecode</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span> <span class="o">:=</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">reversed</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span> <span class="p">^</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">keys</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">),</span> <span class="nx">left</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="p">|</span> <span class="nx">right</span>
<span class="p">}</span></code></pre></div>
<h2 id="replication">Replication</h2>

<blockquote>
<p>The Replication phase turns an <em>unsealed sector</em> into a <em>sealed sector</em></p>
</blockquote>

<p>Before running the <code>Replicate</code> algorithm, the prover must ensure that the sector is correctly formatted with a valid with the &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Filecoin Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</p>

<p>TODO: inputs are missing</p>

<p>The Replication Algorithm  proceeds as follows:</p>

<ul>
<li>Calculate <code>ReplicaID</code> using <code>Hash</code> (Blake2s):</li>
</ul>

<p>The <code>SectorID</code> defined by the chain is an unsigned 64-bit integer which is encoded as a 31-byte array for the purpose of computing a <code>ReplicaID</code>. This transform consists of encoding the number to its little-endian byte representation and then zero-padding to 31-bytes.</p>

<p>Example:</p>

<pre><code>encode(uint64(1025)) -&gt; [1 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</code></pre>

<pre><code>ReplicaID := Hash(ProverID || encode(SectorID) || ticket)
</code></pre>

<ul>
<li><p>Perform <code>RepHash</code> on <code>Data</code> to yield <code>CommD</code> and <code>TreeD</code>:</p>

<pre><code>CommD, TreeD = RepHash(data)
</code></pre></li>
</ul>

<p>For each of <code>LAYERS</code> layers, <code>l</code>, perform one <strong><em>Layer Replication</em></strong>, yielding a replica, tree, and commitment (<code>CommR_&lt;l&gt;</code>) per layer:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">let</span> <span class="nx">layer_replicas</span> <span class="p">=</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">][</span><span class="nx">nodes</span><span class="p">]</span><span class="kt">uint8</span>
<span class="nx">let</span> <span class="nx">layer_trees</span> <span class="p">=</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">MerkleTree</span>
<span class="nx">let</span> <span class="nx">CommRs</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">commitment</span>

<span class="nx">let</span> <span class="nx">layer</span> <span class="p">=</span> <span class="nx">data</span>
<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="mf">0.</span><span class="p">.</span><span class="nx">layers</span> <span class="p">{</span>
	<span class="nx">let</span> <span class="nx">layer_replica</span> <span class="p">=</span> <span class="nf">ReplicateLayer</span><span class="p">(</span><span class="nx">layer</span><span class="p">)</span>
	<span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">=</span> <span class="nx">layer_replica</span>
	<span class="nx">CommRs</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">layers_trees</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">=</span> <span class="nf">RepTree</span><span class="p">(</span><span class="nx">layer_replica</span><span class="p">)</span>
	<span class="nx">layer</span> <span class="p">=</span> <span class="nx">layer_replica</span>
<span class="p">}</span></code></pre></div>
<p>The replicated data is the output of the final <strong><em>Layer Replication</em></strong>,<code>layer_replicas[layers-1]</code>.
Set <code>CommRLast</code> to be  <code>CommR_&lt;Layers&gt;</code>.
Set <code>CommRStar</code> to be <code>CommRHash(ReplicaID || CommR_0 || CommR_&lt;i&gt; || ... || CommRLast)</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Replica</span> <span class="o">:=</span> <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="nx">CommRLast</span> <span class="p">:</span><span class="o">-</span> <span class="nx">CommRs</span><span class="p">[</span><span class="nx">layers</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nx">CommRStar</span> <span class="o">:=</span> <span class="nf">CommRHash</span><span class="p">(</span><span class="nx">replicaID</span><span class="p">,</span> <span class="o">...</span><span class="nx">CommRs</span><span class="p">)</span></code></pre></div>
<h3 id="layer-replication">Layer Replication</h3>

<p>TODO: Define <code>Graph</code>. We need to decide if this is an object we&rsquo;ll explicitly define or if its properties (e.g., <code>GRAPH_SIZE</code>) are just part of the replication parameters and all the functions just refer to the <em>same</em> graphs being manipulated across the entire replication process. (At the moment I&rsquo;ve avoided defining a <code>Graph</code> structure as in other specs I didn&rsquo;t see any object methods, just standalone functions.)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">transformAndReplicateLayers</span><span class="p">(</span><span class="nx">slothIter</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span>
    <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">([]</span><span class="nx">Domain</span><span class="p">,</span> <span class="p">[]</span><span class="nx">Tree</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">taus</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">Domain</span>
    <span class="kd">var</span> <span class="nx">auxs</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">Tree</span>
    <span class="kd">var</span> <span class="nx">sortedTrees</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">Tree</span>

    <span class="k">for</span> <span class="nx">layer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">LAYERS</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">treeData</span> <span class="o">:=</span> <span class="nf">merkleTree</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
        <span class="nx">sortedTrees</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">treeData</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">layer</span> <span class="p">&lt;</span> <span class="nx">LAYERS</span> <span class="p">{</span>
            <span class="nf">vdeEncode</span><span class="p">(</span><span class="nx">slothIter</span><span class="p">,</span> <span class="nx">replicaId</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">zigzag</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">previousCommr</span> <span class="o">:=</span> <span class="kc">nil</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">replicaTree</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sortedTrees</span> <span class="p">{</span>
        <span class="nx">commR</span> <span class="o">:=</span> <span class="nx">replicaTree</span><span class="p">.</span><span class="nf">root</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">previousCommr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">commD</span> <span class="o">:=</span> <span class="nx">previousCommr</span>
            <span class="nx">tau</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">commR</span><span class="p">,</span> <span class="nx">commD</span><span class="p">)</span>
            <span class="nx">taus</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">tau</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">auxs</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">replicaTree</span><span class="p">);</span>
        <span class="nx">previousCommr</span> <span class="p">=</span> <span class="nx">commR</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="nx">taus</span><span class="p">,</span> <span class="nx">auxs</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Note: The function <code>zigzag</code> just inverts an internal <code>bool</code> that tracks whether the <code>graphIsReversed()</code> or not.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">vdeEncode</span><span class="p">(</span><span class="nx">slothIter</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">replicaId</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">parents</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">]</span><span class="kt">uint</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">GRAPH_SIZE</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">node</span> <span class="kt">uint</span>
        <span class="k">if</span> <span class="p">!</span><span class="nf">graphIsReversed</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">node</span> <span class="p">=</span> <span class="nx">n</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If the graph is reversed, traverse in reverse order.
</span><span class="c1"></span>            <span class="nx">node</span> <span class="p">=</span> <span class="nx">GRAPH_SIZE</span> <span class="o">-</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">}</span>

        <span class="nx">parents</span> <span class="p">=</span> <span class="nf">parents</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>

        <span class="nx">key</span> <span class="o">:=</span> <span class="nf">KDFHash</span><span class="p">(</span><span class="nx">replicaId</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">parents</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

        <span class="nx">start</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">NODE_SIZE</span>
        <span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">NODE_SIZE</span><span class="p">;</span>
        <span class="nx">nodeData</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">])</span>
        <span class="nx">encoded</span> <span class="o">:=</span> <span class="nf">slothEncode</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">nodeData</span><span class="p">,</span> <span class="nx">slothIter</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span> <span class="p">=</span> <span class="nx">encoded</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h2 id="proof-generation">Proof Generation</h2>

<p>Overview:</p>

<ul>
<li>Challenge Derivation</li>
<li>Proof Generation</li>
<li>Circuit Proof Generation</li>
</ul>

<p>TODO: write a single algorithm which includes the spec below</p>

<h3 id="challenge-derivation">Challenge Derivation</h3>

<p>This is the Fiat-Shamir transform that turns the interactive Proof-of-Replication into non-interactive in the Random Oracle model.</p>

<p>TODO: define <code>Domain</code> (for practical purposes a <code>uint</code>) and <code>LayerChallenges</code> (or find existing definition).</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TODO: we should replace the word commitment with the word seed, this will be more interactive porep friendly
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeriveChallenges</span><span class="p">(</span><span class="nx">challenges</span> <span class="nx">LayerChallenges</span><span class="p">,</span> <span class="nx">layer</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">leaves</span> <span class="kt">uint</span><span class="p">,</span>
    <span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">commitment</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint</span> <span class="p">{</span>

    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">challenges</span><span class="p">.</span><span class="nf">ChallengesForLayer</span><span class="p">(</span><span class="nx">layer</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">derivedChallenges</span> <span class="p">[</span><span class="nx">n</span><span class="p">]</span><span class="kt">uint</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">bytes</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">replicaId</span><span class="p">)</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">commitment</span><span class="p">));</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">layer</span><span class="p">);</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nf">toLittleEndian</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span> <span class="nx">k</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

        <span class="c1">// For now, we cannot try to prove the first or last node, so make 
</span><span class="c1"></span>        <span class="c1">// sure the challenge can never be 0 or leaves - 1.
</span><span class="c1"></span>        <span class="nx">big_mod_challenge</span> <span class="o">:=</span> <span class="nf">blake2s</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nx">leaves</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nx">derivedChallenges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">big_mod_challenge</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h3 id="challenge-generation">Challenge Generation</h3>

<p>TODO: we may need to remove this section.</p>

<p>Calculate <code>LAYER_CHALLENGES : [LAYERS]uint</code>: Number of challenges per layer. (This will be passed to the ZigZag circuit proof.)</p>

<p>Derive challenges for each layer (call <code>DeriveChallenges()</code>).</p>

<h3 id="witness-generation">Witness Generation</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">let</span> <span class="nx">layer_proofs</span> <span class="p">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="mf">0.</span><span class="p">.</span><span class="nx">LAYERS</span> <span class="p">{</span>
  <span class="nx">let</span> <span class="nx">replica</span> <span class="p">=</span> <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="nx">let</span> <span class="nx">replica_tree</span> <span class="p">=</span> <span class="nx">layer_trees</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  
  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="nf">derive_challenges</span><span class="p">(</span><span class="nx">LAYER_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
    <span class="nx">data_inclusion_proof</span> <span class="p">=</span> <span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataTree</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="p">&gt;)</span>
    <span class="nx">replica_inclusion_proof</span> <span class="p">=</span> <span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">replica</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">replica_tree</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;)</span> <span class="o">||</span> <span class="nx">FAIL</span><span class="c1">// Prove the replica. TODO explain replica[].
</span><span class="c1"></span>    
    <span class="c1">// *** let kdf_preimage = [replica_id] ***
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">parent_replica_inclusion_proofs</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="nf">parents</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// *** kdf_preimage.push(p)***
</span><span class="c1"></span>      <span class="nx">parent_replica_inclusion_proofs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;))</span>
    <span class="p">}</span>
    <span class="c1">// *** let key = kdf(kdf_preimage); ***
</span><span class="c1"></span>    
    <span class="c1">// *** encode(key, data[c]) == replica[c]
</span><span class="c1"></span>    <span class="c1">// *** We don&#39;t actually need to encode in the proof. ***
</span><span class="c1"></span>    <span class="c1">// TODO: move this ***stuff*** to verification.
</span><span class="c1"></span>
    <span class="nx">layer_proof</span><span class="p">.</span><span class="nf">push</span><span class="p">((</span><span class="nx">data_inclusion_proof</span><span class="p">,</span> <span class="nx">replication_inclusion_proof</span><span class="p">,</span> <span class="nx">parent_replica_inclusion_proofs</span><span class="p">))</span>    
  <span class="p">}</span> 
<span class="p">}</span>

<span class="k">return</span> <span class="nx">layer_proofs</span><span class="p">,</span> <span class="nx">CommRstar</span><span class="p">,</span> <span class="nx">CommRLast</span></code></pre></div>
<p>TODO: reconcile outputs of non-circuit proof with inputs to circuit proof.</p>

<h3 id="zigzag-offline-porep-circuit-spec">ZigZag: Offline PoRep Circuit Spec</h3>

<h4 id="zigzag-overview">ZigZag Overview</h4>

<p>ZigZag PoRep is based on layering DRG graphs <code>LAYERS</code> times. The data represented in each DRG layer is the data encoded in the previous layer. The final layer is the replica (which in Filecoin terms is the sealed sector).</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details)</li>
<li><code>CommD</code> is the Merkle Tree root hash of the input data to the first layer</li>
<li><code>CommR[l]</code> is the Merkle Tree hash of the output of the DRG encoding at each layer <code>l</code></li>
<li><code>CommRStar</code> is the hash of the concatenation of the <code>ReplicaId</code> and all the <code>CommR</code>s.</li>
</ul>

<p>The (offline) proof size in the ZigZag is too large for blockchain usage (~3MB). We use SNARKs to generate a proof of knowledge of a correct ZigZag proof. In other words, we implement the ZigZag proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>This circuit proves that given a Merkle root <code>CommD</code>, <code>CommRLast</code>, and <code>commRStar</code>, that the prover knew the correct replicated data at each layer.</p>

<h4 id="spec-notation">Spec notation</h4>

<ul>
<li><strong>Fr</strong>: Field element of BLS12-381</li>
<li><strong>UInt</strong>: Unsigned integer</li>
<li><strong>{0..x}</strong>: From <code>0</code> (included) to <code>x</code> (not included) (e.g. <code>[0,x)</code> )</li>
<li><strong>Check</strong>:

<ul>
<li>If there is an equality, create a constraint</li>
<li>otherwise, execute the function</li>
</ul></li>
<li><strong>Inclusion path</strong>: Binary representation of the Merkle tree path that must be proven packed into a single <code>Fr</code> element.</li>
</ul>

<h2 id="offline-porep-circuit">Offline PoRep circuit</h2>

<h4 id="public-parameters-1">Public Parameters</h4>

<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>

<ul>
<li><code>LAYERS : UInt</code>: Number of DRG layers.</li>
<li><code>LAYER_CHALLENGES : [LAYERS]UInt</code>: Number of challenges per layer.</li>
<li><code>EXPANSION_DEGREE: UInt</code>: Degree of each bipartite expander graph to extend dependencies between layers.</li>
<li><code>BASE_DEGREE: UInt</code>: Degree of each Depth Robust Graph.</li>
<li><code>TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is (log_2(Size of original data in bytes/32 bytes per leaf)).</li>
<li><code>PARENT_COUNT : UInt</code>: Defined as <code>EXPANSION_DEGREE+BASE_DEGREE</code>.</li>
</ul>

<h4 id="public-inputs">Public Inputs</h4>

<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>

<ul>
<li><code>ReplicaId : Fr</code>: A unique identifier for the replica.</li>
<li><code>CommD : Fr</code>: the Merkle tree root hash of the original data (input to the first layer).</li>
<li><code>CommRLast : Fr</code>: The Merkle tree root hash of the final replica (output of the last layer).</li>
<li><code>CommRStar : Fr</code>: A commitment to each <code>l</code> layer&rsquo;s Merkle tree root hash <code>CommR[l]</code> and <code>ReplicaId</code>.</li>
<li><code>InclusionPath : [LAYERS][]Fr</code>: Inclusion path for the challenged data and replica leaf.</li>
<li><code>ParentInclusionPath : [LAYERS][][PARENT_COUNT]Fr</code>:  Inclusion path for the parents of the corresponding <code>InclusionPath[l][c]</code>.</li>
</ul>

<h5 id="design-notes">Design notes</h5>

<ul>
<li><code>CommRLast</code> is a public input, since we will be using it during Proof-of-Spacetime.</li>
<li><code>InclusionPath</code> and <code>ParentInclusionPath</code>: Each layer <code>l</code> has <code>LAYER_CHALLENGES[l]</code> inclusion paths.</li>
</ul>

<h4 id="private-inputs">Private Inputs</h4>

<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>

<ul>
<li><code>CommR : [LAYERS-1]Fr</code>: Commitment of the the encoded data at each layer.</li>
</ul>

<p>Note: Size is <code>LAYERS-1</code> since the commitment to the last layer is <code>CommRLast</code></p>

<ul>
<li><p><code>DataProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer unencoded challenged leaf.</p></li>

<li><p><code>ReplicaProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer encoded challenged leaves.</p></li>

<li><p><code>ParentProof : [LAYERS][][PARENT_COUNT][TREE_DEPTH]Fr</code>: Pedersen hashes of the Merkle inclusion proofs of the parent leaves for each challenged leaf at layer <code>l</code>.</p></li>

<li><p><code>DataValue : [LAYERS][]Fr</code>: Value of the unencoded challenged leaves at layer <code>l</code>.</p></li>

<li><p><code>ReplicaValue : [LAYERS][]Fr</code>: Value of the encoded leaves for each challenged leaf at layer <code>l</code>.</p></li>

<li><p><code>ParentValue : [LAYERS][][PARENT_COUNT]Fr</code>: Value of the parent leaves for each challenged leaf at layer <code>l</code>.</p></li>
</ul>

<h4 id="circuit">Circuit</h4>

<h5 id="high-level">High Level</h5>

<p>In high level, we do 4 checks:</p>

<ol>
<li><strong>ReplicaId Check</strong>: Check the binary representation of the ReplicaId</li>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
<li><strong>Encoding Checks</strong>: Check that the data has been correctly encoding into a replica</li>
<li><strong>CommRStar Check</strong>: Check that CommRStar has been generated correctly</li>
</ol>

<h5 id="details">Details</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 1: ReplicaId Check - Check ReplicaId is equal to its bit representation
</span><span class="c1"></span><span class="nx">let</span> <span class="nx">ReplicaIdBits</span> <span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">ReplicaId</span><span class="p">)</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">replica_id_bits</span><span class="p">)</span> <span class="o">==</span> <span class="nx">ReplicaId</span><span class="p">)</span>

<span class="nx">let</span> <span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">ReplicaRoot</span> <span class="nx">Fr</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span> <span class="p">{</span>
  
  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommD</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommRLast</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="p">}</span>
  
  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// 2: Inclusion Proofs Checks
</span><span class="c1"></span>    <span class="c1">// 2.1: Check inclusion proofs for data leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.2: Check inclusion proofs for replica leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.3: Check inclusion proofs for parent leaves are correct
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">ParentInclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">],</span> <span class="nx">ParentProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="c1">// 3: Encoding checks - Check that replica leaves have been correctly encoded
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">ParentBits</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">][</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="c1">// 3.1: Check that each ParentValue is equal to its bit representation
</span><span class="c1"></span>      <span class="nx">let</span> <span class="nx">parent</span> <span class="p">=</span> <span class="nx">ParentValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]</span>
      <span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="o">==</span> <span class="nx">parent</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3.2: KDF check - Check that each key has generated correctly
</span><span class="c1"></span>    <span class="c1">// PreImage = ReplicaIdBits || ParentBits[1] .. ParentBits[PARENT_NODES]
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">PreImage</span> <span class="p">=</span> <span class="nx">ReplicaIdBits</span>
    <span class="k">for</span> <span class="nx">parentbits</span> <span class="nx">in</span> <span class="nx">ParentBits</span> <span class="p">{</span>
      <span class="nx">PreImage</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">parentbits</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">let</span> <span class="nx">key</span> <span class="nx">Fr</span> <span class="p">=</span> <span class="nf">Blake2s</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nf">Blake2s</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span><span class="p">)</span>

    <span class="c1">// 3.3: Check that the data has been encoded to a replica with the right key
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">==</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="c1">// 4: CommRStar check - Check that the CommRStar constructed correctly
</span><span class="c1"></span>  <span class="nx">let</span> <span class="nx">hash</span> <span class="p">=</span> <span class="nx">ReplicaId</span>
  <span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommRLast</span><span class="p">)</span>

  <span class="nf">assert</span><span class="p">(</span><span class="nx">CommRStar</span> <span class="o">==</span> <span class="nf">PedersenHash</span><span class="p">(</span><span class="nx">hash</span><span class="p">))</span>
  <span class="c1">// TODO check if we need to do packing/unpacking
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h4 id="verification-of-offline-porep-proof">Verification of offline porep proof</h4>

<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
<li>Parent checks: For each <code>leaf = InclusionPath[l][c]</code>:

<ul>
<li><strong>Check</strong> that all <code>ParentsInclusionPaths_[l][c][0..PARENT_COUNT}</code> are the correct parent leaves of <code>leaf</code> in the DRG graph, if a leaf has less than <code>PARENT_COUNT</code>, repeat the leaf with the highest label in the graph.</li>
<li><strong>Check</strong> that the parent leaves are in ascending numerical order.</li>
</ul></li>
</ul>

<h3 id="layer-challenge-counts">Layer Challenge Counts</h3>

<p>TODO: define <code>Challenge</code> (or find existing definition)</p>

<p>TODO: we should just list current parameters and show this as a calculation for correctness, this should not mandatory to implement.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChallengesForLayer</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">Challenge</span><span class="p">,</span> <span class="nx">layer</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>

    <span class="k">switch</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
      <span class="c1">// TODO: remove ambiguity, there should not be a &#34;fixed&#34; case
</span><span class="c1"></span>        <span class="k">case</span> <span class="nx">Fixed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Count</span>
        <span class="k">case</span> <span class="nx">Tapered</span><span class="p">:</span>
      <span class="c1">// TODO: current calculation is incorrect and does not match claim6 from Fisch2019, it should look more like: https://observablehq.com/d/bbabac1947b79011#gen_zigzag_taper
</span><span class="c1"></span>            <span class="nf">assert</span><span class="p">(</span><span class="nx">layer</span> <span class="p">&lt;</span> <span class="nx">LAYERS</span><span class="p">)</span>
            <span class="nx">l</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">LAYERS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nx">layer</span>
            <span class="nx">r</span> <span class="o">:=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nx">TAPER</span><span class="p">;</span>
            <span class="nx">t</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">TAPER_LAYERS</span><span class="p">)</span>

            <span class="nx">totalTaper</span> <span class="o">:=</span> <span class="nf">pow</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

            <span class="nx">calculated</span> <span class="o">:=</span> <span class="nf">ceil</span><span class="p">(</span><span class="nx">totalTaper</span> <span class="o">*</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>

            <span class="c1">// Although implied by the call to `ceil()` above, be explicit
</span><span class="c1"></span>            <span class="c1">// that a layer cannot contain 0 challenges.
</span><span class="c1"></span>            <span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">calculated</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>



</div>

  

  
    








<div id="algorithms__proof_of_spacetime">

<h2>
  Proof of Spacetime
</h2>



<p>This document describes Rational-PoSt, the Proof-of-Spacetime used in Filecoin.</p>

<h2 id="rational-post">Rational PoSt</h2>

<h3 id="definitions">Definitions</h3>

<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>POST_PROVING_PERIOD</code></td>
<td><code>2880</code> blocks  (~24h)</td>
<td>The time interval in which a PoSt has to be submitted.</td>
</tr>

<tr>
<td><code>POST_CHALLENGE_TIME</code></td>
<td><code>240</code> blocks (~2h)</td>
<td>The time offset at which the actual work of generating the PoSt <strong>can not</strong> be started earlier than. This is some delta before the end of the <code>Proving Period</code>, and as such less then a single <code>Proving Period</code>.</td>
</tr>
</tbody>
</table>

<div class="notices todo" ><strong>TODO</strong>: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</div>

<h3 id="high-level-api">High Level API</h3>

<h4 id="fault-detection">Fault Detection</h4>

<p>Fault detection happens over the course of the life time of a sector. When the sector is for some reason unavailable, the miner is responsible to submit the known <code>faults</code>, before the PoSt challenge begins. (Using the <code>AddFaults</code> message to the chain).
Only faults which have been reported at challenge time, will be accounted for. If any other faults have occured the miner can not submit a valid PoSt for this proving period.</p>

<p>The PoSt generation then takes the latest available <code>faults</code> of the miner to generate a PoSt matching the committed sectors and faults.</p>

<p>When a PoSt is successfully submitted all faults are reset and assumed to be recovered. A miner must either (1) resolve a faulty sector and accept challenges against it in the next proof submission, (2) report a sector faulty again if it persists but is eventually recoverable, (3) report a sector faulty <em>and done</em> if the fault cannot be recovered.</p>

<p>If the miner knows that the sectors are permanently lost, they can submit them as part of the <code>doneSet</code>, to ensure they are removed from the proving set.</p>

<div class="notices note" ><strong>Note</strong>: It is important that all faults are known (i.e submitted to the chain) prior to challenge generation, because otherwise it would be possible to know the challenge set, before the actual challenge time. This would allow a miner to report only faults on challenged sectors, with a gurantee that other faulty sectors would not be detected.</div>

<div class="notices todo" ><strong>TODO</strong>: The penalization for faults is not clear yet.</div>

<h4 id="fault-penalization">Fault Penalization</h4>

<p>Each reported fault carries a penality with it.</p>

<div class="notices todo" ><strong>TODO</strong>: Define the exact penality structure for this.</div>

<h4 id="generation">Generation</h4>

<p><code>GeneratePoSt</code> generates a <strong><em>Proof of Spacetime</em></strong> over all  <strong><em>sealed sectors</em></strong> of a single miner— identified by their <code>commR</code> commitments. This is accomplished by performing a series of merkle inclusion proofs (<strong><em>Proofs of Retrievability</em></strong>). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided <code>seed</code>. At each time step, a number of <strong><em>Proofs of Retrievability</em></strong> are performed.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Generate a new PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="nx">SectorSet</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="c1">// Generate the Merkle Inclusion Proofs + Faults
</span><span class="c1"></span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nf">SortAsc</span><span class="p">(</span><span class="nf">GetSectorIds</span><span class="p">(</span><span class="nx">sectors</span><span class="p">)))</span>
    <span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="p">[]</span>
    <span class="nx">inclusionProofs</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">challenges</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">challenge</span> <span class="o">:=</span> <span class="nx">challenges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="c1">// Leaf index of the selected sector
</span><span class="c1"></span>        <span class="nx">inclusionProof</span><span class="p">,</span> <span class="nx">isFault</span> <span class="o">:=</span> <span class="nf">GenerateMerkleInclusionProof</span><span class="p">(</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Leaf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">isFault</span> <span class="p">{</span>
            <span class="c1">// faulty sector, need to post a fault to the chain and try to recover from it
</span><span class="c1"></span>            <span class="k">return</span> <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Detected late fault&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">inclusionProofs</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">inclusionProof</span>
        <span class="nx">challengedSectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectors</span><span class="p">[</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">// Generate the snark
</span><span class="c1"></span>    <span class="nx">snarkProof</span> <span class="o">:=</span> <span class="nf">GeneratePoStSnark</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">challenges</span><span class="p">,</span> <span class="nx">challengedSectors</span><span class="p">,</span> <span class="nx">inclusionProofs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">snarkProof</span>
<span class="p">}</span></code></pre></div>
<h4 id="verification">Verification</h4>

<p><code>VerifyPoSt</code> is the functional counterpart to <code>GeneratePoSt</code>. It takes all of <code>GeneratePoSt</code>&rsquo;s output, along with those of <code>GeneratePost</code>&rsquo;s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Verify a PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">VerifyPoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="nx">SectorSet</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">PoStProof</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nf">SortAsc</span><span class="p">(</span><span class="nf">GetSectorIds</span><span class="p">(</span><span class="nx">sectors</span><span class="p">)))</span>
    <span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="c1">// Match up commitments with challenges
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">challenges</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">challengedSectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectors</span><span class="p">[</span><span class="nx">challenges</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Sector</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">// Verify snark
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">VerifyPoStSnark</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">challenges</span><span class="p">,</span> <span class="nx">challengedSectors</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="types">Types</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The random challenge seed, provided by the chain.
</span><span class="c1"></span><span class="nx">Seed</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Challenge</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Sector</span> <span class="nx">SectorID</span>
    <span class="nx">Leaf</span> <span class="nx">Uint</span>
<span class="p">}</span></code></pre></div>
<h4 id="challenge-derivation">Challenge Derivation</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Derive the full set of challenges for PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sortedSectors</span> <span class="p">[]</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">[</span><span class="nx">POST_CHALLENGES_COUNT</span><span class="p">]</span><span class="nx">Challenge</span> <span class="p">{</span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">POST_CHALLENGES_COUNT</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">attemptedSectors</span> <span class="o">:=</span> <span class="p">{</span><span class="nx">SectorID</span><span class="p">:</span><span class="kt">bool</span><span class="p">}</span>
        <span class="nx">while</span> <span class="nx">challenges</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">challenge</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenge</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">attempt</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sortedSectors</span><span class="p">)</span>

            <span class="c1">// check if we landed in a faulty sector
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">faults</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Valid challenge
</span><span class="c1"></span>                <span class="nx">challenges</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">challenge</span>
            <span class="p">}</span>

            <span class="c1">// invalid challenge, regenerate
</span><span class="c1"></span>            <span class="nx">attemptedSectors</span><span class="p">[</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">attemptedSectors</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sortedSectors</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;All sectors are faulty&#34;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">challenges</span>
<span class="p">}</span>

<span class="c1">// Derive a single challenge for PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DerivePoStChallenge</span><span class="p">(</span><span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">attempt</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sortedSectors</span> <span class="p">[]</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">Challenge</span> <span class="p">{</span>
    <span class="nx">nBytes</span> <span class="o">:=</span> <span class="nf">WriteUintToLittleEndian</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="nf">concat</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">nBytes</span><span class="p">,</span> <span class="nf">WriteUintToLittleEndian</span><span class="p">(</span><span class="nx">attempt</span><span class="p">))</span>
    <span class="nx">challengeBytes</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="nx">sectorChallenge</span> <span class="o">:=</span> <span class="nf">ReadUintLittleEndian</span><span class="p">(</span><span class="nx">challengeBytes</span><span class="p">[</span><span class="mf">0..8</span><span class="p">])</span>
    <span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nf">ReadUintLittleEndian</span><span class="p">(</span><span class="nx">challengeBytes</span><span class="p">[</span><span class="mf">8..16</span><span class="p">])</span>

    <span class="nx">sectorIdx</span> <span class="o">:=</span> <span class="nx">sectorChallenge</span> <span class="o">%</span> <span class="nx">sectorCount</span>

    <span class="k">return</span> <span class="nx">Challenge</span> <span class="p">{</span>
        <span class="nx">Sector</span><span class="p">:</span> <span class="nx">sortedSectors</span><span class="p">[</span><span class="nx">sectorIdx</span><span class="p">],</span>
        <span class="nx">Leaf</span><span class="p">:</span> <span class="nx">leafChallenge</span> <span class="o">%</span> <span class="p">(</span><span class="nx">sectorSize</span> <span class="o">/</span> <span class="nx">NODE_SIZE</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h3 id="post-circuit">PoSt Circuit</h3>

<h4 id="public-parameters">Public Parameters</h4>

<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>

<ul>
<li><code>POST_CHALLENGES_COUNT: UInt</code>: Number of challenges.</li>
<li><code>POST_TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is <code>(log_2(Size of original data in bytes/32 bytes per leaf))</code>.</li>
<li><code>SECTOR_SIZE: UInt</code>: The size of a single sector in bytes.</li>
</ul>

<h4 id="public-inputs">Public Inputs</h4>

<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>

<ul>
<li><code>CommRs: [POST_CHALLENGES_COUNT]Fr</code>: The Merkle tree root hashes of all replicas, ordered to match the inclusion paths and challenge order.</li>
<li><code>InclusionPaths: [POST_CHALLENGES_COUNT]Fr</code>: Inclusion paths for the replica leafs, ordered to match the <code>CommRs</code> and challenge order. (Binary packed bools)</li>
</ul>

<h4 id="private-inputs">Private Inputs</h4>

<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>

<ul>
<li><code>InclusionProofs: [POST_CHALLENGES_COUNT][TREE_DEPTH]Fr</code>: Merkle tree inclusion proofs, ordered to match the challenge order.</li>
<li><code>InclusionValues: [POST_CHALLENGES_COUNT]Fr</code>: Value of the encoded leaves for each challenge, ordered to match challenge order.</li>
</ul>

<h4 id="circuit">Circuit</h4>

<h5 id="high-level">High Level</h5>

<p>In high level, we do 1 check:</p>

<ol>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
</ol>

<h5 id="details">Details</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">POST_CHALLENGES_COUNT</span> <span class="p">{</span>
  <span class="c1">// Inclusion Proofs Checks
</span><span class="c1"></span>  <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">CommRs</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionProof</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionValue</span><span class="p">[</span><span class="nx">c</span><span class="p">]))</span>
<span class="p">}</span></code></pre></div>
<h4 id="verification-of-post-proof">Verification of PoSt proof</h4>

<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
</ul>




</div>

  

  
    








<div id="algorithms__payment_channels">

<h2>
  Payment Channels
</h2>



<h2 id="payment-channels">Payment Channels</h2>

<p>In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.</p>

<p>The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&rdquo;. Once that money is locked up, user A can send user B signed transactions that user B can cash out at any time.</p>

<p>For example:</p>

<ul>
<li>User A locks up 10 FIL to B</li>
<li>User B does something for A</li>
<li>User A sends <code>SignedVoucher{Channel, 1 FIL}</code> to B</li>
<li>User B does something for user A</li>
<li>User A sends <code>SignedVoucher{Channel, 2 FIL}</code> to B</li>
</ul>

<p>At this point, B has two signed messages from A, but the contract is set up such that it can only be cashed out once. So if B decided to cash out, they would obviously select the message with the higher value. Also, once B cashes out, they must not accept any more payments from A on that same channel.</p>

<h3 id="multi-lane-payment-channel">Multi-Lane Payment Channel</h3>

<p>The filecoin storage market may require a way to do incremental payments between two parties, over time, for multiple different transactions. The primary motivating usecase for this is to provide payment for file storage over time, for each file stored. An additional requirement is the ability to have less than one message on chain per transaction &lsquo;lane&rsquo;, meaning that payments for multiple files should be aggregateable (Note: its okay if this aggregation is an interactive process).</p>

<p>Let&rsquo;s say that <code>A</code> wants to make such an arrangement with <code>B</code>. <code>A</code> should create the payment channel with enough funds to cover all potential transactions. Then <code>A</code> decides to start the first transaction, so they send a signed voucher for the payment channel on &lsquo;lane 1&rsquo;, for 2 FIL. They can then send more updates on lane 1 as needed. Then, at some point <code>A</code> decides to start another independent transaction to <code>B</code>, so they send a voucher on &lsquo;lane 2&rsquo;. The voucher for lane 2 can be cashed out independently of lane 1. However, <code>B</code> can ask <code>A</code> to &lsquo;reconcile&rsquo; the two payment channels for them into a single update. This update could contain a value, and a list of lanes to close. Cashing out that reconciled update would invalidate the other lanes, meaning <code>B</code> couldnt also cash in those. The single update would be much smaller, and therefore cheaper to close out.</p>

<p>Lane state can be easily tracked on-chain with a compact bitfield.</p>

<h3 id="payment-channel-reconciliation">Payment Channel Reconciliation</h3>

<p>In a situation where peers A and B  have several different payment channels between them, the scenario may frequently come up where A has multiple payment channel updates from B to apply. Submitting each of these individually would cost a noticeable amount in fees, and put excess unnecessary load on the chain. To remedy this, A can contact B and ask them for a single payment channel update for the combined value of all the updates they have (minus some fee to incent B to actually want to do this). This aggregated update would contain a list of the IDs of the other payment channels that it is superceding so that A cannot also cash out on the originals.</p>

<h1 id="payment-reconciliation">Payment Reconciliation</h1>

<p>The filecoin storage market will (likely) have many independent payments between the same parties. These payments will be secured through payment channels, set up initially on chain, but utilized almost entirely off-chain. The point at which they need to touch the chain is when miners wish to cash out their earnings. A naive solution to this problem would have miners perform one on-chain action per file stored for a particular client. This would not scale well. Instead, we need a system where the miner and client can have some additional off-chain communication and end up with the miner submitting only a single message to the chain.</p>

<p>To accomplish this, we introduce the Payment Reconciliation Protocol.</p>

<p>This is a libp2p service run by all participants wanting to participate in payment reconciliation. When Alice has a set of payments from Bob that she is ready to cash out, Alice can send a <code>ReconcileRequest</code> to Bob, containing the following information:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileRequest struct <span class="o">{</span>
	vouchers <span class="o">[</span>Vouchers<span class="o">]</span>
	reqVal TokenAmount
<span class="o">}</span></code></pre></div>
<p>The Vouchers should all be valid vouchers from Bob to Alice, on the same payment channel, and they should all be ready to be cashed in. <code>ReqVal</code> is a token amount less than or equal to the sum of all the values in the given vouchers. Generally, this value will be between the total sum of the vouchers, and that total sum minus the fees it would cost to submit them all to the chain.</p>

<p>Bob receives this request, and checks that all the fields are correct, and then ensures that the difference between ReqVal and the vouchers sum is sufficient (this is a parameter that the client can set).  Then, he sends back a response which either contains the requested voucher, or an error status and message.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileResponse struct <span class="o">{</span>
	combined Voucher
	status  Status
	message optional String
<span class="o">}</span>

<span class="c1">## TODO: what are the possible status cases?</span>
<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="p">|</span> Success
    <span class="p">|</span> Failure
<span class="o">}</span></code></pre></div>
<p>Open Questions:</p>

<ul>
<li>In a number of usecases, this protocol will require the miner look up and connect to a client to propose reconciliation. How does a miner look up and connect to a client over libp2p given only their filecoin address?</li>
<li>Without repair miners, this protocol will likely not be used that much. Should that be made clear? Should there be other considerations added to compensate?</li>
</ul>




</div>

  

  
    








<div id="algorithms__vdf">

<h2>
  Verifiable Delay Functions
</h2>

<p>TODO: finish</p>




</div>

  

  
    








<div id="algorithms__crypto">

<h2>
  Cryptographic Primitives
</h2>

<ul>
<li>Merkle tree/DAG</li>
<li>Vector commitment scheme</li>
<li>zkSNARK</li>
<li>Verifiable random function (VRF)</li>
<li>Verifiable delay function (VDF)</li>

<li><p>Reliable broadcast channel (libp2p)</p></li>

<li><div class="notices todo">
<strong>TODO</strong>:  Add more detail and include references to relevant papers. 
</div></li>
</ul>



  
    








<div id="algorithms__crypto__signatures">

<h3>
  Signatures
</h3>



<h2 id="signatures">Signatures</h2>

<p>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.</p>

<p>We use signatures in filecoin to verify <em>something</em> was done by <em>someone</em>. For example, we use signatures in order to validate deal messages which represent an action like a storage deals. We also use signatures to determine who generated a particular message, determine public keys&ndash;which can be recovered from signed data and a signature, and find filecoin addresses which generated from a public key.</p>

<ul>
<li>Messages (From users to the blockchain)</li>
<li>Tickets (Signature of proof - <a href="mining.md">Mining</a>)</li>
<li>Block signature (Signature over all data in the block - done by block leader)</li>
</ul>

<h3 id="interface">Interface</h3>

<p>Filecoin requires a system that fulfils the following interface to function correctly.</p>

<p>Note: <code>Message</code> is used here as the object being signed, but this interface should also work for other things that need to be signed.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">interface</span> <span class="p">{</span>

	<span class="c1">// Sign generates a proof that miner `M` generate message `m`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Out:
</span><span class="c1"></span>	<span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>	<span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>	<span class="c1">// In:
</span><span class="c1"></span>	<span class="c1">//    m - a series of bytes representing a message to be signed
</span><span class="c1"></span>	<span class="c1">//    sk - a private key which cryptographically links `M` to `sig`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">Sign</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Message</span><span class="p">,</span> <span class="nx">sk</span> <span class="nx">PrivateKey</span><span class="p">)</span> <span class="p">(</span><span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Verify validates the statement: only `M` could have generated `sig`
</span><span class="c1"></span>	<span class="c1">// given the validator has a message `m`, a signature `sig`, and a
</span><span class="c1"></span>	<span class="c1">// public key `pk`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Out:
</span><span class="c1"></span>	<span class="c1">//    valid - a boolean value indicating the signature is valid
</span><span class="c1"></span>	<span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>	<span class="c1">// In:
</span><span class="c1"></span>	<span class="c1">//    m - a series of bytes representing the signed message
</span><span class="c1"></span>	<span class="c1">//    pk - the public key belonging to the signer `M`
</span><span class="c1"></span>	<span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">Verify</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Messgage</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="p">(</span><span class="nx">valid</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Recover, as its name implies, recovers a public key associated with a
</span><span class="c1"></span>	<span class="c1">// particular signature. In the case of ECDSA signatures, this function can
</span><span class="c1"></span>	<span class="c1">// be fulfilled via the &#39;ECRecover&#39; method. If a different signature scheme
</span><span class="c1"></span>	<span class="c1">// is used, then some other mechanism of &#39;recovering&#39; a message authors
</span><span class="c1"></span>	<span class="c1">// public key must be provided.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Out:
</span><span class="c1"></span>	<span class="c1">//    pk - the public key associated with `M` who signed `m`
</span><span class="c1"></span>	<span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>	<span class="c1">//    **
</span><span class="c1"></span>	<span class="c1">// In:
</span><span class="c1"></span>	<span class="c1">//    m - a series of bytes representing the signed message
</span><span class="c1"></span>	<span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">Recover</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Message</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="p">(</span><span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h3 id="secp256k1-signatures">Secp256k1 Signatures</h3>

<p>Currently, Filecoin uses secp256k1 signatures to fulfill the above interface. All signatures on messages, blocks, and tickets currently use the same scheme and format.</p>

<h4 id="signing-messages">Signing Messages</h4>

<p>To generate a signature for the <a href="data-structures.md#message"><code>Message</code></a> type, first serialize it, then hash the serialized bytes with blake2b-256. Then, take the 32 byte digest output the hash and compute the secp256k1 signature over it.</p>

<h4 id="wire-format">Wire Format</h4>

<p>We use standard secp256k1 signature serialization, as described below. For more details on how the Filecoin <code>Signature</code> type is serialized, see the relevant section in <a href="data-structures.md#signature">the data structures spec</a></p>

<p><strong>Signature</strong></p>

<pre><code>SignatureBytes = [0x30][len][0x02][r][indicator][s][indicator][recovery]
</code></pre>

<p><code>s</code> = Scalar of size 32 bytes</p>

<p><code>r</code> = Compressed elliptic curve point (x-coordinate) of size 32 bytes</p>

<p><code>recovery</code> = Information needed to recover a public key from <code>sig</code>.</p>

<ul>
<li>LSB(0) = parity of y-coordinate of r</li>
<li>LSB(1) = overflow indicator</li>
</ul>

<p><code>indicator</code> = a 2 byte formatting indicator</p>

<h3 id="external-references">External References</h3>

<ul>
<li>Elliptic Curve Cryptography Paper

<ul>
<li><a href="http://www.secg.org/sec1-v2.pdf">http://www.secg.org/sec1-v2.pdf</a></li>
</ul></li>
</ul>




</div>

  


</div>

  


</div>


  
    
    








<div id="subsystems">

<h1>
  Subsystems
</h1>




  
    








<div id="subsystems__blockchain">

<h2>
  Blockchain
</h2>




  
    








<div id="subsystems__blockchain__components">

<h3>
  Blockchain Components
</h3>

<p>In order to ensure they are always on the correct latest state of the blockchain,
a Filecoin node must continuously monitor and propagate blocks on the network.</p>

<p>When a node receives blocks, it must also <em>validate</em> them.
Validation is split into two stages, syntactic and semantic.
The syntactic stage may be validated without reference to additional data,
while the semantic stage requires access to the chain which the block extends.
For clarity, we separate these stages into separate components:
syntactic validation is performed by the <a href="./#subsystems__blockchain__components__block_receiver">Block Receiver</a>,
and once collected and validated, the blocks are forwarded
to the <a href="./#subsystems__blockchain__components__chain_manager">Chain Manager</a>,
which performs semantic validation and adds the blocks to the node&rsquo;s
current view of the blockchain state.</p>



  
    








<div id="subsystems__blockchain__components__block_receiver">

<h4>
  Block Receiver
</h4>

<p>A node must decode and perform syntactic validation for every block received
before passing it on (e.g. in a lipbp2p pubsub validator).</p>

<div id="subsystems__blockchain__components__block_receiver__syntactic_validation"></div><h3>Syntactic Validation</h3>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Miner is the address of the miner actor that mined this block.
</span><span class="c1"></span>    <span class="nx">miner</span> <span class="nx">Address</span>

    <span class="c1">// Tickets is a chain (possibly singleton) of tickets ending with a winning ticket
</span><span class="c1"></span>    <span class="c1">// submitted with this block.
</span><span class="c1"></span>    <span class="nx">tickets</span> <span class="p">[</span><span class="nx">Ticket</span><span class="p">]</span>

    <span class="c1">// ElectionProof is generated from a past ticket and proves this miner is a leader
</span><span class="c1"></span>    <span class="c1">// in this block&#39;s round.
</span><span class="c1"></span>    <span class="nx">electionProof</span> <span class="nx">ElectionProof</span>

    <span class="c1">// Parents is an array of distinct CIDs of parents on which this block was based.
</span><span class="c1"></span>    <span class="c1">// Typically one, but can be several in the case where there were multiple winning
</span><span class="c1"></span>    <span class="c1">// ticket-holders for a given round. The order of parent CIDs is not defined.
</span><span class="c1"></span>    <span class="nx">parents</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>

    <span class="c1">// ParentWeight is the aggregate chain weight of the parent set.
</span><span class="c1"></span>    <span class="nx">parentWeight</span> <span class="nx">UInt</span>

    <span class="c1">// Height is the chain height of this block.
</span><span class="c1"></span>    <span class="nx">height</span> <span class="nx">UInt</span>

    <span class="c1">// StateRoot is a CID pointer to the VM state tree after application of the state
</span><span class="c1"></span>    <span class="c1">// transitions corresponding to this block&#39;s messages.
</span><span class="c1"></span>    <span class="nx">stateRoot</span> <span class="o">&amp;</span><span class="nx">StateTree</span>

    <span class="c1">// Messages is the set of messages included in this block. This field is the CID
</span><span class="c1"></span>    <span class="c1">// of the TxMeta object that contains the bls and secpk signed message trees.
</span><span class="c1"></span>    <span class="nx">messages</span> <span class="o">&amp;</span><span class="nx">TxMeta</span>

    <span class="c1">// BLSAggregate is an aggregated BLS signature for all the messages in this block
</span><span class="c1"></span>    <span class="c1">// that were signed using BLS signatures.
</span><span class="c1"></span>    <span class="nx">blsAggregate</span> <span class="nx">Signature</span>

    <span class="c1">// MessageReceipts is a set of receipts matching to the sending of the `Messages`.
</span><span class="c1"></span>    <span class="c1">// This field is the CID of the root of a sharray of MessageReceipts.
</span><span class="c1"></span>    <span class="nx">messageReceipts</span> <span class="o">&amp;</span><span class="p">[</span><span class="nx">MessageReceipt</span><span class="p">]</span>

    <span class="c1">// The block Timestamp is used to enforce a form of block delay by honest miners.
</span><span class="c1"></span>    <span class="c1">// Unix time UTC timestamp (in seconds) stored as an unsigned integer.
</span><span class="c1"></span>    <span class="nx">timestamp</span> <span class="nx">Timestamp</span>

    <span class="c1">// BlockSig is a signature over the hash of the entire block with the miners
</span><span class="c1"></span>    <span class="c1">// worker key to ensure that it is not tampered with after creation
</span><span class="c1"></span>    <span class="nx">blockSig</span> <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TxMeta</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">blsMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">Message</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
    <span class="nx">secpkMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">SignedMessage</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<p>A syntactically valid block:</p>

<ul>
<li>must include a well-formed miner address</li>
<li>must include at least one well-formed ticket, and if more they form a valid ticket chain</li>
<li>must include an election proof which is a valid signature by the miner address of the final ticket</li>
<li>must include at least one parent CID</li>
<li>must include a positive parent weight</li>
<li>must include a positive height</li>
<li>must include well-formed state root, messages, and receipts CIDs</li>
<li>must include a timestamp not in the future</li>
</ul>




</div>

  

  
    








<div id="subsystems__blockchain__components__block_propagator">

<h4>
  Block Propagator
</h4>



<p>The filecoin network needs to broadcast blocks and messages to all peers in the network. This document details how that process works.</p>

<p>Messages and block headers along side the message references are propagated using the <a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">gossipsub libp2p pubsub router</a>. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be <a href="./validation.md#syntactical-validation">syntactically validated</a> before being propagated further.</p>

<p>Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.g. <code>Message</code>) from any node it is connected to. However, the node should fan out these requests to multiple nodes and not bombard any single node with too many requests at a time. A node may implement throttling and DDoS protection to prevent such a bombardment.</p>

<h2 id="bitswap">Bitswap</h2>

<p>Run bitswap to fetch and serve data (such as blockdata and messages) to and from other filecoin nodes. This is used to fill in missing bits during block propagation, and also to fetch data during sync.</p>

<p>There is not yet an official spec for bitswap, but <a href="https://github.com/ipfs/go-bitswap/blob/master/message/pb/message.proto">the protobufs</a> should help in the interim.</p>

<h2 id="block-propagation">Block Propagation</h2>

<p>Blocks are propagated over the libp2p pubsub channel <code>/fil/blocks</code>. The following structure is filled out with the appropriate information, serialized (with IPLD), and sent over the wire:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockMessage struct <span class="o">{</span>
  header BlockHeader
  secpkMessages <span class="o">[]</span><span class="p">&amp;</span>SignedMessage
  blsMessages <span class="o">[]</span><span class="p">&amp;</span>Message
<span class="o">}</span></code></pre></div>
<p>Every <code>BlockMessage</code> received must be validated <a href="validation.md#syntactical-validation">through the syntactical check</a> before being propagated again. If validation fails, it must not be propagated.</p>

<h2 id="message-propagation">Message Propagation</h2>

<p>Messages are propagated over the libp2p pubsub channel <code>/fil/messages</code>. On this channel, every <a href="data-structures.md#messages">serialised <code>SignedMessage</code></a> is announced.</p>

<p>Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</p>

<div class="notices todo" >discuss checking signatures and account balances, some tricky bits that need consideration. Does the fund check cause improper dropping? E.g. I have a message sending funds then use the newly constructed account to send funds, as long as the previous wasn&rsquo;t executed the second will be considered &ldquo;invalid&rdquo; &hellip; though it won&rsquo;t be at the time of execution.</div>

<h2 id="blocksync">BlockSync</h2>

<ul>
<li><strong>Name</strong>: Block Sync</li>
<li><strong>Protocol ID</strong>: <code>/fil/sync/blk/0.0.1</code></li>
</ul>

<p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.</p>

<p>The request requests a chain of a given length by the hash of its highest block. The <code>Options</code> allow the requester to specify whether or not blocks and messages to be included.</p>

<p>The response contains the requested chain in reverse iteration order. Each item in the <code>Chain</code> array contains the blocks for that tipset if the <code>Blocks</code> option bit in the request was set, and if the <code>Messages</code> bit was set, the messages across all blocks in that tipset. The <code>MsgIncludes</code> array contains one array of integers for each block in the <code>Blocks</code> array. Each of the arrays in <code>MsgIncludes</code> contains a list of indexes of messages from the <code>Messages</code> array that are in each <code>Block</code> in the blocks array.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockSyncRequest struct <span class="o">{</span>
    <span class="c1">## The TipSet being synced from</span>
	start <span class="o">[</span><span class="p">&amp;</span>Block<span class="o">]</span>
    <span class="c1">## How many tipsets to sync</span>
	requestLength UInt
    <span class="c1">## Query options</span>
    options Options
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Options enum <span class="o">{</span>
    <span class="c1"># Include only blocks</span>
    <span class="p">|</span> Blocks <span class="m">0</span>
    <span class="c1"># Include only messages</span>
    <span class="p">|</span> Messages <span class="m">1</span>
    <span class="c1"># Include messages and blocks</span>
    <span class="p">|</span> BlocksAndMessages <span class="m">2</span>
<span class="o">}</span>

<span class="nb">type</span> BlockSyncResponse struct <span class="o">{</span>
	chain <span class="o">[</span>TipSetBundle<span class="o">]</span>
	status Status
<span class="o">}</span>

<span class="nb">type</span> TipSetBundle struct <span class="o">{</span>
  blocks <span class="o">[</span>Blocks<span class="o">]</span>
  secpMsgs <span class="o">[</span>SignedMessage<span class="o">]</span>
  secpMsgIncludes <span class="o">[[</span>UInt<span class="o">]]</span>

  blsMsgs <span class="o">[</span>Message<span class="o">]</span>
  blsMsgIncludes <span class="o">[[</span>Uint<span class="o">]]</span>
<span class="o">}</span>

<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="c1">## All is well.</span>
    <span class="p">|</span> Success <span class="m">0</span>
    <span class="c1">## Sent back fewer blocks than requested.</span>
    <span class="p">|</span> PartialResponse <span class="m">101</span>
    <span class="c1">## Request.Start not found.</span>
    <span class="p">|</span> BlockNotFound <span class="m">201</span>
    <span class="c1">## Requester is making too many requests.</span>
    <span class="p">|</span> GoAway <span class="m">202</span>
    <span class="c1">## Internal error occured.</span>
    <span class="p">|</span> InternalError <span class="m">203</span>
    <span class="c1">## Request was bad</span>
    <span class="p">|</span> BadRequest <span class="m">204</span>
<span class="o">}</span></code></pre></div>
<h3 id="example">Example</h3>

<p>The TipSetBundle</p>

<pre><code>Blocks: [b0, b1]
secpMsgs: [mA, mB, mC, mD]
secpMsgIncludes: [[0, 1, 3], [1, 2, 0]]
</code></pre>

<p>corresponds to:</p>

<pre><code>Block 'b0': [mA, mB, mD]
Block 'b1': [mB, mC, mA]
</code></pre>




</div>

  

  
    








<div id="subsystems__blockchain__components__chain_manager">

<h4>
  Chain Manager
</h4>



<div id="subsystems__blockchain__components__chain_manager__semantic_validation"></div><h3>Semantic Validation</h3>

<p>A semantically valid block:</p>

<ul>
<li>must be from a valid miner, i.e. has not been slashed</li>
<li>must only have valid parents in the tipset, meaning

<ul>
<li>that each parent itself must be a valid block</li>
<li>all parents must be at same height</li>
</ul></li>
<li>must have a valid ticket:

<ul>
<li>the ticket must be the winning ticket</li>
<li>the ticket must be generated from the smallest ticket in the parent tipset</li>
<li>all tickets in the ticket array must have been generated by the same miner</li>
<li>if it includes intermediary losing tickets in the ticket array, the node must confirm that each ticket correctly generates the next in the array</li>
</ul></li>
<li>must have a valid timestamp, meaning

<ul>
<li>must be later than the earliest parent block time plus appreopriate delay, which is BLOCK_DELAY (30s by default) * len(blk.Tickets).
see <a href="mining.md#block-validation">BLock Validation</a></li>
</ul></li>
<li>must only have valid state transitions:

<ul>
<li>all messages in the block must be valid</li>
<li>the execution of each message, in the order they are in the block, must produce a receipt matching the corresponding one in the receipt set of the block, see <a href="state-machine.md">the state machine spec</a>.</li>
</ul></li>
<li>the resulting state root after all messages are applied, must match the one in the block</li>
</ul>

<div class="notices info" >Once the block passes validation, it must be added to the local datastore, regardless whether it is understood as the best tip at this point. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching.</div>

<div class="notices info" >To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.</div>

<h3 id="basic-check">Basic check</h3>

<div class="notices todo" >clarify which of these checks are needed in order to be allowed to validate and propagate a block. This is probably a sub-set of the above mentioned - and thus this paragraph might be moved there - that should be reasonably quick to check and hard to spoof or get around.</div>

<p>A BlockHeader is verifiable on its own, with the last StateTree but without the rest of the Block,
in the following ways:</p>

<ul>
<li>MinerAddress can be validated against current StateTree</li>
<li>ConsensusTickets can be validated</li>
<li>ConsensusElectionProof can be validated</li>
<li>Parents can be checked</li>
<li>BlockSignature can be verified</li>
<li>ParentWeight can be calculated and verified</li>
<li>BlockHeight can be checked against the height of the parents</li>
<li>Timestamp can be checked to be greater than the parents&rsquo; timestamp, by around one block time,
and smaller than the current time.</li>
</ul>

<p>The following requires having and processing (executing) the messages</p>

<ul>
<li>Messages can be checked by verifying the messages hash correctly to the value.</li>
<li>MessageAggregateSig can be checked by verifying the messages sign correctly</li>
<li>MessageReceipts can only be checked by executing the messages</li>
<li>StateRoot is the result of the execution of the messages, and can only be verified by executing them</li>
</ul>

<h3 id="receiving-blocks">Receiving Blocks</h3>

<p>When receiving blocks from the network (via <a href="data-propagation.md">block propagation</a>), a miner must do the following:</p>

<ol>
<li>Check their validity (see <a href="#block-validation">below</a>).</li>
<li>Assemble a TipSet with all valid blocks with common parents and the same number of tickets in their <code>Tickets</code> array.</li>
</ol>

<p>A miner may sometimes receive blocks belonging to different TipSets (i.e. whose parents are not the same). In that case, they must choose which TipSet to mine on.</p>

<p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier TipSet rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="expected-consensus.md#chain-selection">chain selection</a> in the Expected Consensus spec.</p>

<h3 id="block-validation">Block Validation</h3>

<p>The block structure and serialization is detailed in <a href="data-structures.md#block">the datastructures spec - block</a>. Check there for details on fields and types.</p>

<p>In order to validate a block coming in from the network at height <code>N</code> was well mined a miner must do the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">VerifyBlock</span><span class="p">(</span><span class="nx">blk</span> <span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 1. Verify Signature
</span><span class="c1"></span>    <span class="nx">pubk</span> <span class="o">:=</span> <span class="nf">GetPublicKey</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Miner</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">BlockSig</span><span class="p">,</span> <span class="nx">pubk</span><span class="p">,</span> <span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid block signature&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 2. Verify Timestamp
</span><span class="c1"></span>    <span class="c1">// first check that it is not in the future
</span><span class="c1"></span>    <span class="c1">// allowing for some small grace period to deal with small asynchrony
</span><span class="c1"></span>    <span class="c1">// a potential default for ALLOWABLE_CLOCK_DRIFT could be 2/3*blockTime
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">GetTime</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nf">networkTime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">ALLOWABLE_CLOCK_DRIFT</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;block was generated too far in the future&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// next check that it is appropriately delayed from its parents including
</span><span class="c1"></span>    <span class="c1">// null blocks.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">GetTime</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">minParentTime</span><span class="p">()</span><span class="o">+</span><span class="p">(</span><span class="nx">BLOCK_DELAY</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Tickets</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;block was generated too soon&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3. Verify ParentWeight
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nx">ParentWeight</span> <span class="o">!=</span> <span class="nf">ComputeWeight</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Parents</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid parent weight&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 4. Verify Tickets
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">VerifyTickets</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;tickets were invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 5. Verify ElectionProof
</span><span class="c1"></span>    <span class="c1">// Note that this step must explicitly check that the
</span><span class="c1"></span>    <span class="c1">// miner has not been slashed or is not late to submitting a PoSt
</span><span class="c1"></span>    <span class="c1">// i.e. that this is still a valid miner
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">VerifyElectionProof</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;election was invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 6. Verify Message Signatures
</span><span class="c1"></span>    <span class="nx">state</span> <span class="o">:=</span> <span class="nf">GetParentState</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Parents</span><span class="p">)</span>
    <span class="nx">blsMessages</span> <span class="o">:=</span> <span class="nf">LoadMessages</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Messages</span><span class="p">.</span><span class="nx">blsMsgs</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">blsPubKeys</span> <span class="p">[]</span><span class="nx">PublicKey</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blsMessages</span> <span class="p">{</span>
          <span class="nx">blsPubKeys</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nf">LookupPublicKey</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateBLSSignature</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">BLSAggregate</span><span class="p">,</span> <span class="nx">blsMessages</span><span class="p">,</span> <span class="nx">blsPubKeys</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;aggregated bls signature failed to validate&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">secpkMessages</span> <span class="o">:=</span> <span class="nf">LoadMessages</span><span class="p">(</span><span class="nx">bls</span><span class="p">.</span><span class="nx">Messages</span><span class="p">.</span><span class="nx">secpkMessages</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">secpkMessages</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;secpk message %d had invalid signature&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 7. Validate State Transitions
</span><span class="c1"></span>    <span class="nx">receipts</span> <span class="o">:=</span> <span class="nf">LoadReceipts</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">MessageReceipts</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blsMessages</span> <span class="p">{</span>
        <span class="nx">receipt</span> <span class="o">:=</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">receipt</span> <span class="o">!=</span> <span class="nx">receipts</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;message receipt mismatch&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">secpkMessages</span> <span class="p">{</span>
      <span class="nx">receipt</span> <span class="o">:=</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">receipt</span> <span class="o">!=</span> <span class="nx">receipts</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blsMessages</span><span class="p">)]</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;message receipt mismatch&#34;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nf">Cid</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">blk</span><span class="p">.</span><span class="nx">StateRoot</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;state roots mismatch&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">state</span> <span class="nx">StateTree</span><span class="p">)</span> <span class="nf">LookupPublicKey</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">PubKey</span> <span class="p">{</span>
    <span class="nx">act</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">act</span><span class="p">.</span><span class="nx">Code</span> <span class="o">==</span> <span class="nx">AccountActor</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only account actors have public keys&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">ast</span> <span class="o">:=</span> <span class="nf">LoadAccountActorState</span><span class="p">(</span><span class="nx">act</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">act</span><span class="p">.</span><span class="nx">Address</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">BLS</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">ExtractBLSPubKey</span><span class="p">(</span><span class="nx">act</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;can only look up public keys for BLS controlled accounts&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Get the canonical randomness from a block.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">ticket</span> <span class="o">:=</span> <span class="nf">minTicket</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">ticket</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>If all of this lines up, the block is valid. The miner repeats this for all blocks in a TipSet, and for all TipSets formed from incoming blocks.</p>

<p>Once they&rsquo;ve ensured all blocks in the heaviest TipSet received were properly mined, they can mine on top of it. If they weren&rsquo;t, the miner may need to ensure the next heaviest <code>Tipset</code> was properly mined. This might mean the same <code>Tipset</code> with invalid blocks removed, or an altogether different one.</p>

<p>If no valid blocks are received, a miner may run leader election again (see <a href="expected-consensus.md#ticket-generation">ticket generation</a>).</p>

<h3 id="ticket-validation">Ticket Validation</h3>

<p>For ticket generation, see <a href="expected-consensus.md#ticket-generation">ticket generation</a>.</p>

<p>A ticket can be verified to have been generated in the appropriate number of rounds by looking at the <code>Tickets</code> array, and ensuring that each subsequent ticket (leading to the final ticket in that array) was generated using the previous one in the array (or in the prior block if the array is empty). Note that this has implications on block size, and client memory requirements, though on expectation, the <code>Tickets</code> array should only contain one Ticket. Put another way, each Ticket should be generated from the prior one in the ticket-chain.</p>

<p>Succinctly, the process of verifying a block&rsquo;s tickets is as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: received block, storage market actor S, miner&#39;s public key PK, a public VDF validation key vk
Output: 0, 1

0. Get the tickets
    i. tickets &lt;-- block.tickets
For each ticket, idx: tickets
1. Verify its VRF Proof
    i. # get the appropriate parent
        if idx == 0:
            # the first was derived from the prior block&#39;s last ticket
            parent = parentBlock.lastTicket
        else:
            parent = tickets[idx - 1]
    ii. # generate the VRFInput
        input &lt;-- VRFPersonalization.Ticket | parent.VDFOutput
    iii. # verify the VRF
        VRFState &lt;-- ECVRF_Verify(PK, ticket.VRFProof, input)
        if VRFState == &#34;INVALID&#34;:
            return 0
2. Verify its VDF Proof
    i. # generate the VDF input
        VRFOutput &lt;-- ECVRF_proof_to_hash(ticket.VRFProof)
    ii. # verify
        VDFState &lt;-- VDF_verify(vk, VRFOutput, ticket.VDFOutput, ticket.VDFProof)
        if VDFState == &#34;NO&#34;:
            return 0
3. Return results
    return 1</code></pre></div>
<p>Notice that there is an implicit check that all tickets in the <code>Tickets</code> array are signed by the same miner.</p>

<h3 id="election-validation">Election Validation</h3>

<p>For election proof generation, see <a href="expected-consensus.md#checking-election-results">checking election results</a>.</p>

<p>In order to determine that the mined block was generated by an eligible miner, one must check its <code>ElectionProof</code>.</p>

<p>Succinctly, the process of verifying a block&rsquo;s election proof at round N, is as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: received block, storage market actor S, miner&#39;s public key PK, a public parameter K
Output: 0, 1

0. Get the election proof, total power, miner power
        i. electionProof &lt;-- block.electionProof
        ii. # get total market power
            S &lt;-- storageMarket(N)
            p_n &lt;-- S.GetTotalStorage()
        iii. # get miner power
            p_m &lt;-- GetMinersPowerAt(N, PK)
1. Ensure the miner was not slashed or late: in that case, their power would be 0 and can just abort.
        i. # Check for a reported fault or late submission
            if p_m == 0
                return 0
2. Determine the miner&#39;s power fraction
        i. # Get power fraction
              p_f &lt;-- p_m/p_n
3. Ensure that the scratched ticket is a winner
        i. # get the deterministic output from the election proof
            VRFOutput &lt;-- ECVRF_proof_to_hash(electionProof.VRFProof)
        ii. # map p_f onto [0, 2^HashLen]
            normalized_power &lt;-- p_f * 2^HashLen
          iii. # Compare the miner&#39;s scratchValue to the miner&#39;s normalized power fraction
              if readLittleEndian(VRFOutput) &gt; normalized_power:
                return 0
4. Get the appropriate ticket from the ticket chain
        i. # Get the tipset K rounds back
            appropriateTipset &lt;-- lookback(K)
        ii. # Take its min ticket (already validated)
            scratchedTicket &lt;-- appropriateTipset.minTicket()
5. Verify Election Proof validity
        i. # generate the VRFInput from the scratched ticket
            input &lt;-- VRFPersonalization.ElectionProof | scratchedTicket.VDFOutput
        ii. # Check that the election proof was correctly generated by the miner
            # using the appropriate ticket
            VRFState &lt;-- ECVRF_Verify(miner.PK, electionProof.VRFProof, input)
            if VRFState == &#34;INVALID&#34;:
                return 0
5. Everything checks out, it&#39;s a valid election proof
        return 1</code></pre></div>
<h3 id="chaintipsmanager">ChainTipsManager</h3>

<p>The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.</p>

<p>The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current &lsquo;best&rsquo; tipset is.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns the ticket that is at round &#39;r&#39; in the chain behind &#39;head&#39;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TicketFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Returns the tipset that contains round r (Note: multiple rounds&#39; worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TipsetFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// GetBestTipset returns the best known tipset. If the &#39;best&#39; tipset hasn&#39;t changed, then this
</span><span class="c1">// will return the previous best tipset.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetBestTipset</span><span class="p">()</span>

<span class="c1">// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddLosingTicket</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Ticket</span><span class="p">)</span></code></pre></div>



</div>

  

  
    








<div id="subsystems__blockchain__components__block_producer">

<h4>
  Block Producer
</h4>



<h2 id="mining-blocks">Mining Blocks</h2>

<p>Having registered as a miner, it&rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest <a href="expected-consensus.md#tipsets">TipSets</a> seen on the network.</p>

<p>For additional details around how consensus works in Filecoin, see the <a href="expected-consensus.md">expected consensus spec</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how &ldquo;Tickets&rdquo; should be validated during block validation.</p>

<h3 id="ticket-generation">Ticket Generation</h3>

<p>For details of ticket generation, see the <a href="expected-consensus.md#ticket-generation">expected consensus spec</a>.</p>

<p>New tickets are generated using the last ticket in the ticket-chain. Generating a new ticket will take some amount of time (as imposed by the VDF in Expected Consensus).</p>

<p>Because of this, on expectation, as it is produced, the miner will hear about other blocks being mined on the network. By the time they have generated their new ticket, they can check whether they themselves are eligible to mine a new block (see <a href="#block-creation">block creation</a>).</p>

<p>At any height <code>H</code>, there are three possible situations:
- The miner is eligible to mine a block: they produce their block and form a TipSet with it and other blocks received in this round (if there are any), and resume mining at the next height <code>H+1</code>.
- The miner is not eligible to mine a block but has received blocks: they form a TipSet with them and resume mining at the next height <code>H+1</code>.
- The miner is not eligible to mine a block and has received no blocks: they run leader election again, using:
    - their losing ticket from the last leader election to produce a new ticket (the <code>Tickets</code> array in the block to be published grows with each new ticket generated).
    - the ticket <code>H + 1 - K</code> blocks back to attempt to generate an <code>ElectionProof</code>.</p>

<p>This process is repeated until either a winning ticket is found (and block published) or a new valid TipSet comes in from the network.</p>

<p>Let&rsquo;s illustrate this with an example.</p>

<p>Miner M is mining at Height H.
Heaviest tipset at H-1 is {B0}
- New Round:
    - M produces a ticket at H, from B0&rsquo;s ticket (the min ticket at H-1)
    - M draws the ticket from height H-K to generate an ElectionProof
    - That ElectionProof is invalid
    - M has not heard about other blocks on the network.
- New Round:
    - M produces a ticket at H + 1 using the ticket produced at H last round.
    - M draws a ticket from height H+1-K to generate an ElectionProof
    - That ElectionProof is valid
    - M generates a block B1
    - M has received blocks B2, B3 from the network with the same parents and same height.
    - M forms a tipset {B1, B2, B3}
- Finding the new min ticket/extending the ticket chain:
    - M compares the final tickets in {B1,B2,B3} (each has two tickets in their <code>Tickets</code> array). B2 has the smallest final ticket. B2 should be used to extend the ticket chain, conceptually.
- New Round:
    - M produces a new ticket at H + 2 using B2&rsquo;s final ticket (the min final ticket in {B1, B2, B3})
    - M draws a ticket from H+2-K to generate an ElectionProof
    - That ElectionProof is invalid
    - M has received B4 from the network, mined atop {B1,B2,B3}
- New Round with M mining atop B4</p>

<p>Anytime a miner receives new blocks, it should evaluate which is the heaviest TipSet it knows about and mine atop it.</p>

<h3 id="block-creation">Block Creation</h3>

<p>Scratching a winning ticket, and armed with a valid <code>ElectionProof</code>, a miner can now publish a new block!</p>

<p>To create a block, the eligible miner must compute a few fields:</p>

<ul>
<li><code>Tickets</code> - An array containing a new ticket, and, if applicable, any intermediary tickets generated to prove appropriate delay for any failed election attempts. See <a href="expected-consensus.md#ticket-generation">ticket generation</a>.</li>
<li><code>ElectionProof</code> - A signature over the final ticket from the <code>Tickets</code> array proving. See <a href="expected-consensus.md#checking-election-results">checking election results</a>.</li>
<li><code>ParentWeight</code> - As described in <a href="expected-consensus.md#chain-weighting">Chain Weighting</a>.</li>
<li><code>Parents</code> - the CIDs of the parent blocks.</li>
<li><code>ParentState</code> - Note that it will not end up in the newly generated block, but is necessary to compute to generate other fields. To compute this:

<ul>
<li>Take the <code>ParentState</code> of one of the blocks in the chosen parent set (invariant: this is the same value for all blocks in a given parent set).</li>
<li>For each block in the parent set, ordered by their tickets:</li>
<li>Apply each message in the block to the parent state, in order. If a message was already applied in a previous block, skip it.</li>
<li>Transaction fees are given to the miner of the block that the first occurance of the message is included in. If there are two blocks in the parent set, and they both contain the exact same set of messages, the second one will receive no fees.</li>
<li>It is valid for messages in two different blocks of the parent set to conflict, that is, A conflicting message from the combined set of messages will always error.  Regardless of conflicts all messages are applied to the state.</li>
<li>TODO: define message conflicts in the state-machine doc, and link to it from here</li>
</ul></li>
<li><code>MsgRoot</code> - To compute this:

<ul>
<li>Select a set of messages from the mempool to include in the block.</li>
<li>Separate the messages into BLS signed messages and secpk signed messages</li>
<li>For the BLS messages:</li>
<li>Strip the signatures off of the messages, and insert all the bare <code>Message</code>s for them into a sharray.</li>
<li>Aggregate all of the bls signatures into a single signature and use this to fill out the <code>BLSAggregate</code> field</li>
<li>For the secpk messages:</li>
<li>Insert each of the secpk <code>SignedMessage</code>s into a sharray</li>
<li>Create a <code>TxMeta</code> object and fill each of its fields as follows:</li>
<li><code>blsMessages</code>: the root cid of the bls messages sharray</li>
<li><code>secpkMessages</code>: the root cid of the secp messages sharray</li>
<li>The cid of this <code>TxMeta</code> object should be used to fill the <code>MsgRoot</code> field of the block header.</li>
</ul></li>
<li><code>BLSAggregate</code> - The aggregated signatures of all messages in the block that used BLS signing.</li>
<li><code>StateRoot</code> - Apply each chosen message to the <code>ParentState</code> to get this.

<ul>
<li>Note: first apply bls messages in the order that they appear in the blsMsgs sharray, then apply secpk messages in the order that they appear in the secpkMessages sharray.</li>
</ul></li>
<li><code>ReceiptsRoot</code> - To compute this:

<ul>
<li>Apply the set of messages to the parent state as described above, collecting invocation receipts as this happens.</li>
<li>Insert them into a sharray and take its root.</li>
</ul></li>
<li><code>Timestamp</code> - A Unix Timestamp generated at block creation. We use an unsigned integer to represent a UTC timestamp (in seconds). The Timestamp in the newly created block must satisfy the following conditions:

<ul>
<li>the timestamp on the block is not in the future (with ALLOWABLE_CLOCK_DRIFT grace to account for relative asynchrony)</li>
<li>the timestamp on the block is at least BLOCK_DELAY * len(block.Tickets) higher than the latest of its parents, with BLOCK_DELAY taking on the same value as that needed to generate a valid VDF proof for a new Ticket (currently set to 30 seconds).</li>
<li>We also recommend the use of a networkTime() function to be booted on node launch and run every so frequently to call on a networked time service (e.g. ntp) and ensure relative synchrony with the rest of the network.</li>
</ul></li>
<li><code>BlockSig</code> - A signature with the miner&rsquo;s private key (must also match the ticket signature) over the entire block. This is to ensure that nobody tampers with the block after it propagates to the network, since unlike normal PoW blockchains, a winning ticket is found independently of block generation.</li>
</ul>

<p>An eligible miner can start by filling out <code>Parents</code>, <code>Tickets</code> and <code>ElectionProof</code> with values from the ticket checking process.</p>

<p>Next, they compute the aggregate state of their selected parent blocks, the <code>ParentState</code>. This is done by taking the aggregate parent state of the blocks&rsquo; parent TipSet, sorting the parent blocks by their tickets, and applying each message in each block to that state. Any message whose nonce is already used (duplicate message) in an earlier block should be skipped (application of this message should fail anyway). Note that re-applied messages may result in different receipts than they produced in their original blocks, an open question is how to represent the receipt trie of this tipsets &lsquo;virtual block&rsquo;. For more details on message execution and state transitions, see the <a href="state-machine.md">Filecoin state machine</a> document.</p>

<p>Once the miner has the aggregate <code>ParentState</code>, they must apply the block reward. This is done by adding the correct block reward amount to the miner owner&rsquo;s account balance in the state tree. The reward will be spendable immediately in this block. See <a href="#block-rewards">block reward</a> for details on how the block reward is structured. See <a href="#notes-on-block-reward-application">Notes on Block Reward Application</a> for some of the nuances in applying block rewards.</p>

<p>Now, a set of messages is selected to put into the block. For each message, the miner subtracts <code>msg.GasPrice * msg.GasLimit</code> from the sender&rsquo;s account balance, returning a fatal processing error if the sender does not have enough funds (this message should not be included in the chain).</p>

<p>They then apply the messages state transition, and generate a receipt for it containing the total gas actually used by the execution, the executions exit code, and the return value (see <a href="data-structures.md#message-receipt">receipt</a> for more details). Then, they refund the sender in the amount of <code>(msg.GasLimit - GasUsed) * msg.GasPrice</code>. In the event of a message processing error, the remaining gas is refunded to the user, and all other state changes are reverted. (Note: this is a divergence from the way things are done in Ethereum)</p>

<p>Each message should be applied on the resultant state of the previous message execution, unless that message execution failed, in which case all state changes caused by that message are thrown out. The final state tree after this process will be the block&rsquo;s <code>StateRoot</code>.</p>

<p>The miner merklizes the set of messages selected, and put the root in <code>MsgRoot</code>. They gather the receipts from each execution into a set, merklize them, and put that root in <code>ReceiptsRoot</code>. Finally, they set the <code>StateRoot</code> field with the resultant state.</p>

<div class="notices info" >Note that the <code>ParentState</code> field from the expected consensus document is left out, this is to help minimize the size of the block header. The parent state for any given parent set should be computed by the client and cached locally.</div>

<p>Finally, the miner can generate a Unix Timestamp to add to their block, to show that the block generation was appropriately delayed.</p>

<p>The miner will wait until BLOCK_DELAY has passed since the latest block in the parent set was generated to timestamp and send out their block. We recommend using NTP or another clock synchronization protocol to ensure that the timestamp is correctly generated (lest the block be rejected). While this timestamp does not provide a hard proof that the block was delayed (we rely on the VDF in the ticket-chain to do so), it provides some softer form of block delay by ensuring that honest miners will reject undelayed blocks.</p>

<p>Now the block is complete, all that&rsquo;s left is to sign it. The miner serializes the block now (without the signature field), takes the sha256 hash of it, and signs that hash. They place the resultant signature in the <code>BlockSig</code> field.</p>

<h4 id="block-broadcast">Block Broadcast</h4>

<p>An eligible miner broadcasts the completed block to the network (via <a href="data-propagation.md">block propagation</a>), and assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p>

<h3 id="block-rewards">Block Rewards</h3>

<p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin). These funds are initially held by the network account actor, and are transferred to miners in blocks that they mine. The reward amount remains fixed for a period of 1 week (given our 30 second block time, this  is 20,160 blocks, the <code>AdjustmentPeriod</code>) and is then adjusted. Over time, the reward will eventually become zero as the fractional amount given out at each step shrinks the network account&rsquo;s balance to 0.</p>

<p>The equation for the current block reward is of the form:</p>

<pre><code>Reward = IV * (Decay ^ (BlockHeight / 20160))
</code></pre>

<p><code>IV</code> is the initial value, and is computed by taking:</p>

<pre><code>IV = TotalIssuance * (1 - Decay)
</code></pre>

<p><code>Decay</code> is computed by:</p>

<pre><code>Decay = e^(ln(0.5) / (HalvingPeriodBlocks / AdjustmentPeriod))
</code></pre>

<pre><code>// Given one block every 30 seconds, this is how many blocks are in six years
HalvingPeriodBlocks = 6 * 365 * 24 * 60 * 2 = 6,307,200 blocks
</code></pre>

<p>Note: Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it&rsquo;s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</p>

<p>TODO: Ensure that if a miner earns a block reward while undercollateralized, then <code>min(blockReward, requiredCollateral-availableBalance)</code> is garnished (transfered to the miner actor instead of the owner).</p>

<h3 id="notes-on-block-reward-application">Notes on Block Reward Application</h3>

<p>As mentioned above, every round, a miner checks to see if they have been selected as the leader for that particular round (see <a href="expected-consensus.md#secret-leader-election">Secret Leader Election</a> in the Expected Consensus spec for more detail). Thus, it is possible that multiple miners may be selected as winners in a given round, and thus, that there will be multiple blocks with the same parents that are produced at the same block height (forming a TipSet). Each of the winning miners will apply the block reward directly to their actor&rsquo;s state in their state tree.</p>

<p>Other nodes will receive these blocks and form a TipSet out of the eligible blocks (those that have the same parents and are at the same block height). These nodes will then validate the TipSet. The full procedure for how to verify a TipSet can be found above in <a href="#block-validation">Block Validation</a>. To validate TipSet state, the validating node will, for each block in the TipSet, first apply the block reward value directly to the mining node&rsquo;s account and then apply the messages contained in the block.</p>

<p>Thus, each of the miners who produced a block in the TipSet will receive a block reward. There will be no lockup. These rewards can be spent immediately.</p>

<p>Messages in Filecoin also have an associated transaction fee (based on the gas costs of executing the message). In the case where multiple winning miners included the same message in their blocks, only the first miner will be paid this transaction fee. The first miner is the miner with the lowest ticket value (sorted lexicographically). More details on message execution can be found in the <a href="state-machine.md#execution-calling-a-method-on-an-actor">State Machine spec</a>.</p>

<h3 id="open-questions">Open Questions</h3>

<ul>
<li>How should receipts for tipsets &lsquo;virtual blocks&rsquo; be referenced? It is common for applications to provide the merkleproof of a receipt to prove that a transaction was successfully executed.</li>
</ul>




</div>

  


</div>

  

  
    








<div id="subsystems__blockchain__libp2p">

<h3>
  libp2p Protocols
</h3>

<p>TODO</p>



  


</div>

  


</div>

  

  
    








<div id="subsystems__vm">

<h2>
  Filecoin VM
</h2>

<p>TODO</p>



  
    








<div id="subsystems__vm__components">

<h3>
  Filecoin VM Components
</h3>

<p>TODO</p>



  

  
    








<div id="subsystems__vm__components__vm_interpreter">

<h4>
  VM Interpreter
</h4>



<h3 id="sending-funds">Sending Funds</h3>

<p>As all messages carry a method ID, the method ID &lsquo;0&rsquo; is reserved for simple
transfers of funds. Funds specified by the value field are always transferred,
but specifying a method ID of &lsquo;0&rsquo; ensures that no other side effects occur.</p>

<h3 id="state-representation">State Representation</h3>

<p>The <code>global state</code> is modeled as a map of actor <code>ID</code>s to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the &lsquo;key&rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the <code>InitActor</code>), and the value is an <a href="data-structures.md#actor"><code>Actor</code></a> object with the actors information. Within each <code>Actor</code> object is a field called <code>state</code> that is an ipld pointer to a graph that can be entirely defined by the actor.</p>

<h3 id="actor-creation">Actor Creation</h3>

<p>There are two mechanisms by which an actor can be created. By explicitly invoking <code>exec</code> on the <code>Init</code> actor, and by sending a message to a <code>Public Key</code> typed <code>Address</code>.</p>

<p>Calling <code>exec</code> to create an actor should generate an Actor address, and register it in the state tree (see <a href="actors.md#init-actor">Init Actor</a> for more details).</p>

<p>Sending a message to a non-existant account via a public key address causes the creation of an account actor for that address. The <code>To</code> address should be placed into the actor storage for later use in validating messages sent from this actor.</p>

<p>This second route for creating an actor is allowed to avoid the necessity of an explicit &lsquo;register account&rsquo; step for creating new accounts.</p>

<h3 id="execution-calling-a-method-on-an-actor">Execution (Calling a method on an Actor)</h3>

<p>Message execution currently relies entirely on &lsquo;built-in&rsquo; code, with a common external interface. The method and actor to call it on are specified in the <code>Method</code> and <code>To</code> fields of a message, respectively. Method parameters are encoded and put into the <code>Params</code> field of a message. The encoding is technically actor dependent, but for all built-in Filecoin actors it is the dag-cbor ipld encoding of the parameters struct for each method defined in <a href="actors.md">the actors doc</a>.</p>

<p>These functions are given, as input, an <code>ExecutionContext</code> containing useful information for their execution.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">VMContext</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Message is the message that kicked off the current invocation
</span><span class="c1"></span>	<span class="nf">Message</span><span class="p">()</span> <span class="nx">Message</span>

	<span class="c1">// Storage provides access to the VM storage layer
</span><span class="c1"></span>	<span class="nf">Storage</span><span class="p">()</span> <span class="nx">Storage</span>

	<span class="c1">// Origin is the address of the account that initiated the top level invocation
</span><span class="c1"></span>	<span class="nf">Origin</span><span class="p">()</span> <span class="nx">Address</span>

	<span class="c1">// Send allows the current execution context to invoke methods on other actors in the system
</span><span class="c1"></span>	<span class="nf">Send</span><span class="p">(</span><span class="nx">to</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">AttoFIL</span><span class="p">,</span> <span class="nx">params</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// BlockHeight returns the height of the block this message was added to the chain in
</span><span class="c1"></span>	<span class="nf">BlockHeight</span><span class="p">()</span> <span class="nx">BlockHeight</span>
<span class="p">}</span></code></pre></div>
<p>If the execution completes successfully, changes to the state tree are saved. Otherwise, the message is marked as failed, and any state changes are reverted.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">st</span> <span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msg</span> <span class="nx">Message</span><span class="p">)</span> <span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Snapshot</span><span class="p">()</span>
	<span class="nx">fromActor</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no such from actor&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">totalCost</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasLimit</span> <span class="o">*</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nx">Balance</span> <span class="p">&lt;</span> <span class="nx">totalCost</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough funds&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">Nonce</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nx">Nonce</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid nonce&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">toActor</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">toActor</span> <span class="p">=</span> <span class="nf">TryCreateAccountActor</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">DeductFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">totalCost</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">DepositFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>

	<span class="nx">vmctx</span> <span class="o">:=</span> <span class="nf">makeVMContext</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">ret</span><span class="p">,</span> <span class="nx">errcode</span> <span class="o">:=</span> <span class="nx">toActor</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">vmctx</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">errcode</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// revert all state changes since snapshot
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">Revert</span><span class="p">()</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">DeductFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">()</span><span class="o">*</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// refund unused gas
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">DepositFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasLimit</span><span class="o">-</span><span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">())</span><span class="o">*</span><span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// reward miner gas fees
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">DepositFunds</span><span class="p">(</span><span class="nx">BlockMiner</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="o">*</span><span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">())</span>

	<span class="k">return</span> <span class="nx">MessageReceipt</span><span class="p">{</span>
		<span class="nx">ExitCode</span><span class="p">:</span> <span class="nx">errcode</span><span class="p">,</span>
		<span class="nx">Return</span><span class="p">:</span>   <span class="nx">ret</span><span class="p">,</span>
		<span class="nx">GasUsed</span><span class="p">:</span>  <span class="nx">vmctx</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TryCreateAccountActor</span><span class="p">(</span><span class="nx">st</span> <span class="nx">StateTree</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">Actor</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">BLS</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">NewBLSAccountActor</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">Secp256k1</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">NewSecp256k1AccountActor</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">ID</span><span class="p">:</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no actor with given ID&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">Actor</span><span class="p">:</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no such actor&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="receipts">Receipts</h4>

<p>Every message execution generates a <a href="data-structures.md#message-receipt">receipt</a>. These receipts contain the encoded return value of the method invocation, and an exit code.</p>

<h4 id="storage">Storage</h4>

<p>Actors are given acess to a <code>Storage</code> interface to fulfil their need for persistent storage. The <code>Storage</code> interface describes a content addressed block storage system (<code>Put</code> and <code>Get</code>) and a pointer into it (<code>Head</code> and <code>Commit</code>) that points to the actor&rsquo;s current state.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Storage</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Put writes the given object to the storage staging area and returns its CID
</span><span class="c1"></span>	<span class="nf">Put</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">Cid</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Get fetches the given object from storage (either staging, or local) and returns
</span><span class="c1"></span>	<span class="c1">// the serialized data.
</span><span class="c1"></span>	<span class="nf">Get</span><span class="p">(</span><span class="nx">Cid</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Commit updates the actual stored state for the actor. This is a compare and swap
</span><span class="c1"></span>	<span class="c1">// operation, and will fail if &#39;old&#39; is not equal to the current return value of `Head`.
</span><span class="c1"></span>	<span class="c1">// This functionality is used to prevent issues with re-entrancy
</span><span class="c1"></span>	<span class="nf">Commit</span><span class="p">(</span><span class="nx">old</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">Cid</span><span class="p">)</span> <span class="kt">error</span>

	<span class="c1">// Head returns the CID of the current actor state
</span><span class="c1"></span>	<span class="nf">Head</span><span class="p">()</span> <span class="nx">Cid</span>
<span class="p">}</span></code></pre></div>
<p>Actors can store state as a single block or implement any persistent
data structure that can be built upon a content addressed block store.
Implementations may provide data structure implementations to simplify
development. The current interface only supports CBOR-IPLD, but this
should soon expand to allow other types of IPLD data structures (as long
as the system has resolvers for them).</p>

<p>The current state of a given actor can be accessed first by calling <code>Head</code> to retrieve the CID of the root of the actors state, then by using <code>Get</code> to retrieve the actual object being referenced.</p>

<p>To store data, <code>Put</code> is used. Any number of objects may be <code>Put</code>, but only the object whose CID is committed, or objects that are linked to in some way by the committed object will be kept. All other objects are dropped after the method invocation returns. Objects stored via <code>Put</code> are first marshaled to CBOR-IPLD, and then stored, the returned CID is a 32 byte sha2-256 CBOR-IPLD content identifier.</p>

<h3 id="burning-funds">Burning Funds</h3>

<p>In the case that an actor needs to provably burn funds, the funds should be transferred to the &lsquo;Burnt Funds Actor&rsquo; (ID 99).</p>

<h2 id="filecoin-state-machine-actors">Filecoin State Machine Actors</h2>

<p>Any implementations of the Filecoin actors must be exactly byte for byte compatible with the go-filecoin actor implementations. The pseudocode below tries to capture the important logic, but capturing all the detail would require embedding exactly the code from go-filecoin, so for now, its simply informative pseudocode. The algorithms below are correct, and all implementations much match it (including go-filecoin), but details omitted from here should be looked for in the go-filecoin code.</p>

<p>This spec describes a set of actors that operate within the <a href="state-machine.md">Filecoin State Machine</a>. All types are defined in <a href="data-structures.md#basic-type-encodings">the basic type encoding spec</a>.</p>

<h2 id="actor-state">Actor State</h2>

<p>Each actor type defines their own structure for storing their state. We
represent each with an IPLD schema at the beginning of each actor section in
this document.</p>

<h2 id="system-actors">System Actors</h2>

<p>Some state machine actors are &lsquo;system&rsquo; actors that get instantiated in the genesis block, and have their IDs allocated at that point.</p>

<table>
<thead>
<tr>
<th>ID</th>
<th>Actor</th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>InitActor</td>
<td>Network Init</td>
</tr>

<tr>
<td>1</td>
<td>AccountActor</td>
<td>Network Treasury</td>
</tr>

<tr>
<td>2</td>
<td>StorageMarketActor</td>
<td>Filecoin Storage Market</td>
</tr>

<tr>
<td>99</td>
<td>AccountActor</td>
<td>Burnt Funds</td>
</tr>
</tbody>
</table>

<h2 id="built-in-actors">Built In Actors</h2>

<h3 id="init-actor">Init Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;init&quot;&gt;</code></li>
</ul>

<p>The init actor is responsible for creating new actors on the filecoin network. This is a built-in actor and cannot be replicated. In the future, this actor will be responsible for loading new code into the system (for user programmable actors). ID allocation for user instantiated actors starts at 100. This means that <code>NextID</code> will initially be set to 100.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> InitActorState struct <span class="o">{</span>
    addressMap <span class="o">{</span>Address:ID<span class="o">}</span>&lt;Hamt&gt;
    nextId UInt
<span class="o">}</span></code></pre></div>
<h4 id="methods">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Constructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>Exec</code></td>
<td>2</td>
</tr>

<tr>
<td><code>GetIdForAddress</code></td>
<td>3</td>
</tr>
</tbody>
</table>

<h4 id="constructor"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> InitConstructor struct <span class="o">{</span>
<span class="o">}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<h4 id="exec"><code>Exec</code></h4>

<p>This method is the core of the <code>Init Actor</code>. It handles instantiating new actors and assigning them their IDs.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Exec struct <span class="o">{</span>
    <span class="c1">## Reference to the location at which the code of the actor to create is stored.</span>
    code <span class="p">&amp;</span>Code
    <span class="c1">## Parameters passed to the constructor of the actor.</span>
    params ActorMethod
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">code</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">ActorMethod</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="c1">// Get the actor ID for this actor.
</span><span class="c1"></span>	<span class="nx">actorID</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">NextID</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">NextID</span><span class="o">++</span>

	<span class="c1">// Make sure that only the actors defined in the spec can be launched.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">IsBuiltinActor</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch actor instance that is not a builtin actor&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Ensure that singeltons can be only launched once.
</span><span class="c1"></span>	<span class="c1">// TODO: do we want to enforce this? If so how should actors be marked as such?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">IsSingletonActor</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch another actor of this type&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// This generates a unique address for this actor that is stable across message
</span><span class="c1"></span>	<span class="c1">// reordering
</span><span class="c1"></span>	<span class="c1">// TODO: where do `creator` and `nonce` come from?
</span><span class="c1"></span>	<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span><span class="p">,</span> <span class="nx">nonce</span><span class="p">)</span>

	<span class="c1">// Set up the actor itself
</span><span class="c1"></span>	<span class="nx">actor</span> <span class="o">:=</span> <span class="nx">Actor</span><span class="p">{</span>
		<span class="nx">Code</span><span class="p">:</span>    <span class="nx">code</span><span class="p">,</span>
		<span class="nx">Balance</span><span class="p">:</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
		<span class="nx">Head</span><span class="p">:</span>    <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">Nonce</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// The call to the actors constructor will set up the initial state
</span><span class="c1"></span>	<span class="c1">// from the given parameters, setting `actor.Head` to a new value when successfull.
</span><span class="c1"></span>	<span class="c1">// TODO: can constructors fail?
</span><span class="c1"></span>	<span class="nx">actor</span><span class="p">.</span><span class="nf">Constructor</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>

	<span class="nx">VM</span><span class="p">.</span><span class="nx">GlobalState</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">actorID</span><span class="p">,</span> <span class="nx">actor</span><span class="p">)</span>

	<span class="c1">// Store the mapping of address to actor ID.
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorID</span>

	<span class="k">return</span> <span class="nx">addr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IsSingletonActor</span><span class="p">(</span><span class="nx">code</span> <span class="nx">Cid</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">code</span> <span class="o">==</span> <span class="nx">StorageMarketActor</span> <span class="o">||</span> <span class="nx">code</span> <span class="o">==</span> <span class="nx">InitActor</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TODO: find a better home for this logic
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">VM</span> <span class="nx">VM</span><span class="p">)</span> <span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">nonce</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewActorAddress</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="nx">creator</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">nonce</span><span class="p">.</span><span class="nf">BigEndianBytes</span><span class="p">()))</span>
<span class="p">}</span></code></pre></div>
<h4 id="getidforaddress"><code>GetIdForAddress</code></h4>

<p>This method allows for fetching the corresponding ID of a given Address</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetIdForAddress struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetIdForAddress</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">Fault</span><span class="p">(</span><span class="s">&#34;unknown address&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">id</span>
<span class="p">}</span></code></pre></div>
<h3 id="account-actor">Account Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;account&quot;&gt;</code></li>
</ul>

<p>The Account actor is the actor used for normal keypair backed accounts on the filecoin network.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> AccountActorState struct <span class="o">{</span>
    address Address
<span class="o">}</span></code></pre></div>
<h4 id="methods-1">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>AccountConstructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>GetAddress</code></td>
<td>2</td>
</tr>
</tbody>
</table>

<pre><code>type AccountConstructor struct {
}
</code></pre>

<h4 id="getaddress"><code>GetAddress</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetAddress struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetAddress</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">address</span>
<span class="p">}</span></code></pre></div>
<h3 id="storage-market-actor">Storage Market Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;smarket&quot;&gt;</code></li>
</ul>

<p>The storage market actor is the central point for the Filecoin storage market. It is responsible for registering new miners to the system, and maintaining the power table. The Filecoin storage market is a singleton that lives at a specific well-known address.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMarketActorState struct <span class="o">{</span>
    miners <span class="o">{</span>Address:Null<span class="o">}</span>&lt;Hamt&gt;
    totalStorage BytesAmount
<span class="o">}</span></code></pre></div>
<h4 id="methods-2">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>StorageMarketConstructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>CreateStorageMiner</code></td>
<td>2</td>
</tr>

<tr>
<td><code>SlashConsensusFault</code></td>
<td>3</td>
</tr>

<tr>
<td><code>UpdateStorage</code></td>
<td>4</td>
</tr>

<tr>
<td><code>GetTotalStorage</code></td>
<td>5</td>
</tr>

<tr>
<td><code>PowerLookup</code></td>
<td>6</td>
</tr>

<tr>
<td><code>IsMiner</code></td>
<td>7</td>
</tr>

<tr>
<td><code>StorageCollateralForSize</code></td>
<td>8</td>
</tr>
</tbody>
</table>

<h4 id="constructor-1"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMarketConstructor struct <span class="o">{}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<h4 id="createstorageminer"><code>CreateStorageMiner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> CreateStorageMiner struct <span class="o">{</span>
    worker Address
    sectorSize BytesAmount
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CreateStorageMiner</span><span class="p">(</span><span class="nx">worker</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">owner</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">SupportedSectorSize</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Unsupported sector size&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">newminer</span> <span class="o">:=</span> <span class="nx">InitActor</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">MinerActorCodeCid</span><span class="p">,</span> <span class="nf">EncodeParams</span><span class="p">(</span><span class="nx">worker</span><span class="p">,</span> <span class="nx">owner</span><span class="p">,</span> <span class="nx">pledge</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pid</span><span class="p">))</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">newminer</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">newminer</span>
<span class="p">}</span></code></pre></div>
<h4 id="slashconsensusfault"><code>SlashConsensusFault</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SlashConsensusFault struct <span class="o">{</span>
    block1 <span class="p">&amp;</span>Block
    block2 <span class="p">&amp;</span>Block
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">shouldSlash</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span> <span class="nx">BlockHeader</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// First slashing condition, blocks have the same ticket round
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">sameTicketRound</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// Second slashing condition, miner ignored own block when mining
</span><span class="c1"></span>	<span class="c1">// Case A: block2 could have been in block1&#39;s parent set but is not
</span><span class="c1"></span>	<span class="nx">block1ParentTipSet</span> <span class="o">:=</span> <span class="nf">parentOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">block1Parent</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">block1ParentTipSet</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="nx">block2</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span>
		<span class="nx">block1ParentTipSet</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="o">==</span> <span class="nx">block2</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// Case B: block1 could have been in block2&#39;s parent set but is not
</span><span class="c1"></span>	<span class="nx">block2ParentTipSet</span> <span class="o">:=</span> <span class="nf">parentOf</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">block2Parent</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">block2ParentTipSet</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="nx">block1</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span>
		<span class="nx">block2ParentTipSet</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="o">==</span> <span class="nx">block1</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SlashConsensusFault</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span> <span class="nx">BlockHeader</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">block1</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nf">ValidSignature</span><span class="p">(</span><span class="nx">block2</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid blocks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;blocks must be from the same miner&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// see the &#34;Consensus Faults&#34; section of the faults spec (faults.md)
</span><span class="c1"></span>	<span class="c1">// for details on these slashing conditions.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">shouldSlash</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;blocks do not prove a slashable offense&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">miner</span> <span class="o">:=</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span>

	<span class="c1">// TODO: Some of the slashed collateral should be paid to the slasher
</span><span class="c1"></span>
	<span class="c1">// Burn all of the miners collateral
</span><span class="c1"></span>	<span class="nx">miner</span><span class="p">.</span><span class="nf">BurnCollateral</span><span class="p">()</span>

	<span class="c1">// Remove the miner from the list of network miners
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
	<span class="nx">self</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span><span class="p">)</span>

	<span class="c1">// Now delete the miner (maybe this is a bit harsh, but i&#39;m okay with it for now)
</span><span class="c1"></span>	<span class="nx">miner</span><span class="p">.</span><span class="nf">SelfDestruct</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="updatestorage"><code>UpdateStorage</code></h4>

<p>UpdateStorage is used to update the global power table.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UpdateStorage struct <span class="o">{</span>
    delta BytesAmount
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">delta</span> <span class="nx">BytesAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;update storage must only be called by a miner actor&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">TotalStorage</span> <span class="o">+=</span> <span class="nx">delta</span>
<span class="p">}</span></code></pre></div>
<h4 id="gettotalstorage"><code>GetTotalStorage</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetTotalStorage struct <span class="o">{</span>

<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetTotalStorage</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">TotalStorage</span>
<span class="p">}</span></code></pre></div>
<h4 id="powerlookup"><code>PowerLookup</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PowerLookup struct <span class="o">{</span>
    miner Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">PowerLookup</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner not registered with storage market&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">mact</span> <span class="o">:=</span> <span class="nf">LoadMinerActor</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">mact</span><span class="p">.</span><span class="nf">GetPower</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="isminer"><code>IsMiner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> IsMiner struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsMiner</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="storagecollateralforsize"><code>StorageCollateralForSize</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageCollateralForSize struct <span class="o">{</span>
    size UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StorageCollateralforSize</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="c1">// TODO:
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h2 id="storage-miner-actor">Storage Miner Actor</h2>

<ul>
<li><p><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;sminer&quot;&gt;</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMinerActorState struct <span class="o">{</span>
<span class="c1">## contains mostly static info about this miner</span>
info <span class="p">&amp;</span>MinerInfo


<span class="c1">## Collateral that is waiting to be withdrawn.</span>
dePledgedCollateral TokenAmount

	<span class="c1">## Time at which the depledged collateral may be withdrawn.</span>
dePledgeTime BlockHeight

	<span class="c1">## All sectors this miner has committed.</span>
sectors <span class="p">&amp;</span>SectorSet

	<span class="c1">## Sectors this miner is currently mining. It is only updated</span>
	<span class="c1">## when a PoSt is submitted (not as each new sector commitment is added).</span>
provingSet <span class="p">&amp;</span>SectorSet

<span class="c1">## Faulty sectors reported since last SubmitPost, up to the current proving period&#39;s challenge time.</span>
currentFaultSet BitField

<span class="c1">## Faults submitted after the current proving period&#39;s challenge time, but before the PoSt for that period</span>
<span class="c1">## is submitted. These become the currentFaultSet when a PoSt is submitted.</span>
nextFaultSet BitField

	<span class="c1">## Sectors reported during the last PoSt submission as being &#39;done&#39;. The collateral</span>
<span class="c1">## for them is still being held until the next PoSt submission in case early sector</span>
<span class="c1">## removal penalization is needed.</span>
nextDoneSet BitField

	<span class="c1">## Deals this miner has been slashed for since the last post submission.</span>
arbitratedDeals <span class="o">{</span>Cid:Null<span class="o">}</span>

	<span class="c1">## Amount of power this miner has.</span>
power UInt

<span class="c1">## List of sectors that this miner was slashed for.</span>
slashedSet optional <span class="p">&amp;</span>SectorSet

<span class="c1">## The height at which this miner was slashed at.</span>
slashedAt optional BlockHeight

<span class="c1">## The amount of storage collateral that is owed to clients, and cannot be used for collateral anymore.</span>
owedStorageCollateral TokenAmount

provingPeriodEnd BlockHeight
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> MinerInfo struct <span class="o">{</span>
	<span class="c1">## Account that owns this miner.</span>
<span class="c1">## - Income and returned collateral are paid to this address.</span>
<span class="c1">## - This address is also allowed to change the worker address for the miner.</span>
owner Address

	<span class="c1">## Worker account for this miner.</span>
	<span class="c1">## This will be the key that is used to sign blocks created by this miner, and</span>
	<span class="c1">## sign messages sent on behalf of this miner to commit sectors, submit PoSts, and</span>
	<span class="c1">## other day to day miner activities.</span>
worker Address

<span class="c1">## Libp2p identity that should be used when connecting to this miner.</span>
peerId PeerId

<span class="c1">## Amount of space in each sector committed to the network by this miner.</span>
sectorSize BytesAmount

<span class="o">}</span></code></pre></div></li>
</ul>

<h4 id="methods-3">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>StorageMinerConstructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>CommitSector</code></td>
<td>2</td>
</tr>

<tr>
<td><code>SubmitPost</code></td>
<td>3</td>
</tr>

<tr>
<td><code>SlashStorageFault</code></td>
<td>4</td>
</tr>

<tr>
<td><code>GetCurrentProvingSet</code></td>
<td>5</td>
</tr>

<tr>
<td><code>ArbitrateDeal</code></td>
<td>6</td>
</tr>

<tr>
<td><code>DePledge</code></td>
<td>7</td>
</tr>

<tr>
<td><code>GetOwner</code></td>
<td>8</td>
</tr>

<tr>
<td><code>GetWorkerAddr</code></td>
<td>9</td>
</tr>

<tr>
<td><code>GetPower</code></td>
<td>10</td>
</tr>

<tr>
<td><code>GetPeerID</code></td>
<td>11</td>
</tr>

<tr>
<td><code>GetSectorSize</code></td>
<td>12</td>
</tr>

<tr>
<td><code>UpdatePeerID</code></td>
<td>13</td>
</tr>

<tr>
<td><code>ChangeWorker</code></td>
<td>14</td>
</tr>

<tr>
<td><code>IsSlashed</code></td>
<td>15</td>
</tr>

<tr>
<td><code>IsLate</code></td>
<td>16</td>
</tr>

<tr>
<td><code>PaymentVerifyInclusion</code></td>
<td>17</td>
</tr>

<tr>
<td><code>PaymentVerifySector</code></td>
<td>18</td>
</tr>

<tr>
<td><code>AddFaults</code></td>
<td>19</td>
</tr>
</tbody>
</table>

<h4 id="constructor-2"><code>Constructor</code></h4>

<p>Along with the call, the actor must be created with exactly enough filecoin for the collateral necessary for the pledge.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMinerConstructor struct <span class="o">{</span>
    worker Address
    owner Address
    sectorSize BytesAmount
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StorageMinerActor</span><span class="p">(</span><span class="nx">worker</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">owner</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">owner</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">From</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">worker</span> <span class="p">=</span> <span class="nx">worker</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">peerID</span> <span class="p">=</span> <span class="nx">pid</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">sectorSize</span> <span class="p">=</span> <span class="nx">sectorSize</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">sectors</span> <span class="p">=</span> <span class="nf">EmptySectorSet</span><span class="p">()</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">provingSet</span> <span class="p">=</span> <span class="nf">EmptySectorSet</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="commitsector"><code>CommitSector</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> CommitSector struct <span class="o">{</span>
    sectorId SectorID
    commD Bytes
    commR Bytes
    commRStar Bytes
    proof SealProof
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>

<div class="notices todo" >TODO: ValidatePoRep, EnsureSectorIsUnique, CollateralForSector, Commitment</div>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CommitSector</span><span class="p">(</span><span class="nx">sectorID</span> <span class="nx">SectorID</span><span class="p">,</span> <span class="nx">commD</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">commRStar</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">SealProof</span><span class="p">)</span> <span class="nx">SectorID</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">ValidatePoRep</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">comm</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">worker</span><span class="p">,</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;bad proof!&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// make sure the miner isnt trying to submit a pre-existing sector
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">EnsureSectorIsUnique</span><span class="p">(</span><span class="nx">comm</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;sector already committed!&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Power of the miner after adding this sector
</span><span class="c1"></span>	<span class="nx">futurePower</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">power</span> <span class="o">+</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">sectorSize</span>
	<span class="nx">collateralRequired</span> <span class="p">=</span> <span class="nf">CollateralForPower</span><span class="p">(</span><span class="nx">futurePower</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">collateralRequired</span> <span class="p">&gt;</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">MyBalance</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough collateral&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Note: There must exist a unique index in the miner&#39;s sector set for each
</span><span class="c1"></span>	<span class="c1">// sector ID. The `faults`, `recovered`, and `done` parameters of the
</span><span class="c1"></span>	<span class="c1">// SubmitPoSt method express indices into this sector set.
</span><span class="c1"></span>	<span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">commD</span><span class="p">)</span>

	<span class="c1">// if miner is not mining, start their proving period now
</span><span class="c1"></span>	<span class="c1">// Note: As written here, every miners first PoSt will only be over one sector.
</span><span class="c1"></span>	<span class="c1">// We could set up a &#39;grace period&#39; for starting mining that would allow miners
</span><span class="c1"></span>	<span class="c1">// to submit several sectors for their first proving period. Alternatively, we
</span><span class="c1"></span>	<span class="c1">// could simply make the &#39;CommitSector&#39; call take multiple sectors at a time.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Note: Proving period is a function of sector size; small sectors take less
</span><span class="c1"></span>	<span class="c1">// time to prove than large sectors do. Sector size is selected when pledging.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span> <span class="p">=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span>
		<span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="o">+</span> <span class="nf">ProvingPeriodDuration</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CollateralForPower</span><span class="p">(</span><span class="nx">power</span> <span class="nx">BytesAmount</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nx">availableFil</span> <span class="p">=</span> <span class="nx">FakeGlobalMethods</span><span class="p">.</span><span class="nf">GetAvailableFil</span><span class="p">()</span>
	<span class="nx">totalNetworkPower</span> <span class="p">=</span> <span class="nx">StorageMinerActor</span><span class="p">.</span><span class="nf">GetTotalStorage</span><span class="p">()</span>
	<span class="nx">numMiners</span> <span class="p">=</span> <span class="nx">StorageMarket</span><span class="p">.</span><span class="nf">GetMinerCount</span><span class="p">()</span>
	<span class="nx">powerCollateral</span> <span class="p">=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="nx">NetworkConstants</span><span class="p">.</span><span class="nx">POWER_COLLATERAL_PROPORTION</span> <span class="o">*</span> <span class="nx">power</span> <span class="o">/</span> <span class="nx">totalNetworkPower</span>
	<span class="nx">perCapitaCollateral</span> <span class="p">=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="nx">NetworkConstants</span><span class="p">.</span><span class="nx">PER_CAPITA_COLLATERAL_PROPORTION</span> <span class="o">/</span> <span class="nx">numMiners</span>
	<span class="nx">collateralRequired</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nx">minerPowerCollateral</span> <span class="o">+</span> <span class="nx">minerPerCapitaCollateral</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">collateralRequired</span>
<span class="p">}</span></code></pre></div>
<h4 id="submitpost"><code>SubmitPoSt</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SubmitPost struct <span class="o">{</span>
    proofs PoStProof
    doneSet Bitfield
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SubmitPost</span><span class="p">(</span><span class="nx">proofs</span> <span class="nx">PoStProof</span><span class="p">,</span> <span class="nx">doneSet</span> <span class="nx">Bitfield</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized to submit post for miner&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">feesRequired</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">nextProvingPeriodEnd</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">+</span> <span class="nf">ProvingPeriodDuration</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span>

    <span class="c1">// TODO: rework fault handling, for now anything later than 2 proving periods is invalid
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">nextProvingPeriodEnd</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;PoSt submited too late&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">{</span>
		<span class="nx">feesRequired</span> <span class="o">+=</span> <span class="nf">ComputeLateFee</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">power</span><span class="p">,</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">self</span><span class="p">.</span><span class="nx">provingPeriodEnd</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">feesRequired</span> <span class="o">+=</span> <span class="nf">ComputeTemporarySectorFailureFee</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentFaultSet</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="p">&lt;</span> <span class="nx">feesRequired</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough funds to pay post submission fees&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// we want to ensure that the miner can submit more fees than required, just in case
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="p">&gt;</span> <span class="nx">feesRequired</span> <span class="p">{</span>
		<span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span><span class="o">-</span><span class="nx">feesRequired</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="kd">var</span> <span class="nx">seed</span>
    <span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">{</span>
      <span class="c1">// good case, submitted in time
</span><span class="c1"></span>      <span class="nx">seed</span> <span class="p">=</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// bad case, submitted late, need to take new proving period end as reference
</span><span class="c1"></span>      <span class="nx">seed</span> <span class="p">=</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">nextPovingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">faultSet</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">currentFaultSet</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">VerifyPoSt</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">provingSet</span><span class="p">,</span> <span class="nx">seed</span><span class="p">,</span> <span class="nx">proof</span><span class="p">,</span> <span class="nx">faultSet</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;proof invalid&#34;</span><span class="p">)</span>
	<span class="p">}</span>

    <span class="c1">// The next fault set becomes the current one
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">currentFaultSet</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">nextFaultSet</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">nextFaultSet</span> <span class="p">=</span> <span class="nf">EmptySectorSet</span><span class="p">()</span>

    <span class="c1">// TODO: penalize for faults
</span><span class="c1"></span>
	<span class="c1">// Remove doneSet from the current sectors
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">doneSet</span><span class="p">)</span>

	<span class="c1">// Update miner power to the amount of data actually proved during the last proving period.
</span><span class="c1"></span>	<span class="nx">oldPower</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Power</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Power</span> <span class="p">=</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">-</span> <span class="nx">faultSet</span><span class="p">.</span><span class="nf">Count</span><span class="p">())</span> <span class="o">*</span> <span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span>
	<span class="nx">StorageMarket</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">Power</span> <span class="o">-</span> <span class="nx">oldPower</span><span class="p">)</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Sectors</span>

	<span class="c1">// Updating proving period given a fixed schedule, independent of late submissions.
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">=</span> <span class="nx">nextProvingPeriodEnd</span>

	<span class="c1">// update next done set
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">NextDoneSet</span> <span class="p">=</span> <span class="nx">done</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">ArbitratedDeals</span><span class="p">.</span><span class="nf">Clear</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ProvingPeriodDuration</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">Integer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">// number of blocks in one day
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeLateFee</span><span class="p">(</span><span class="nx">power</span> <span class="nx">Integer</span><span class="p">,</span> <span class="nx">blocksLate</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">4</span> <span class="c1">// TODO: real collateral calculation, obviously
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeTemporarySectorFailureFee</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">4</span> <span class="c1">// TODO: something tells me that 4 might not work in all situations. probably should find a better way to compute this
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h4 id="slashstoragefault"><code>SlashStorageFault</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SlashStorageFault struct <span class="o">{</span>
    miner Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SlashStorageFault</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// You can only be slashed once for missing your PoSt.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">SlashedAt</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner already slashed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Only if the miner is actually late, they can be slashed.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span><span class="o">+</span><span class="nf">GenerationAttackTime</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner is not yet tardy&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Only a miner who is expected to prove, can be slashed.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner is inactive&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Strip the miner of their power.
</span><span class="c1"></span>	<span class="nx">StorageMarketActor</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Power</span><span class="p">)</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">Power</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">slashedSet</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span>
	<span class="c1">// remove proving set from our sectors
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">sectors</span><span class="p">.</span><span class="nf">Substract</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">slashedSet</span><span class="p">)</span>

	<span class="c1">// clear proving set
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">owedStorageCollateral</span> <span class="p">=</span> <span class="nx">StorageMarketActor</span><span class="p">.</span><span class="nf">StorageCollateralForSize</span><span class="p">(</span>
		<span class="nx">self</span><span class="p">.</span><span class="nx">slashedSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">*</span> <span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">SlashedAt</span> <span class="p">=</span> <span class="nx">CurrentBlockHeight</span>
<span class="p">}</span></code></pre></div>
<h4 id="getcurrentprovingset"><code>GetCurrentProvingSet</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetCurrentProvingSet struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetCurrentProvingSet</span><span class="p">()</span> <span class="p">[][]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span>
<span class="p">}</span></code></pre></div>
<div class="notices note" ><strong>Note</strong>: this is unlikely to ever be called on-chain, and will be a very large amount of data. We should reconsider the need for a list of all sector commitments (maybe fixing with accumulators?)</div>

<h4 id="arbitratedeal"><code>ArbitrateDeal</code></h4>

<p>This may be called by anyone to penalize a miner for dropping the data of a deal they committed to before the deal expires. Note: in order to call this, the caller must have the signed deal between the client and the miner in question, this would require out of band communication of this information from the client to acquire.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ArbitrateDeal struct <span class="o">{</span>
    deal Deal
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AbitrateDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">Deal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">VM</span><span class="p">.</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">deal</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid signature on deal&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StartTime</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal not yet started&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Expiry</span> <span class="p">&lt;</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal is expired&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">NextDoneSet</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">pieceInclusionProof</span><span class="p">.</span><span class="nx">sectorID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal agreement not broken, or arbitration too late&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ArbitratedDeals</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">commP</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot slash miner twice for same deal&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">deal</span><span class="p">.</span><span class="nx">pieceInclusionProof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">commP</span><span class="p">,</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid piece inclusion proof or size&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">storageCollateral</span> <span class="o">:=</span> <span class="nx">StorageMarketActor</span><span class="p">.</span><span class="nf">StorageCollateralForSize</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">owedStorageCollateral</span> <span class="p">&lt;</span> <span class="nx">storageCollateral</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;math is hard, and we didnt do it right&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// pay the client the storage collateral
</span><span class="c1"></span>	<span class="nx">VM</span><span class="p">.</span><span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">storageCollateral</span><span class="p">,</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">client</span><span class="p">)</span>

	<span class="c1">// keep track of how much we have payed out
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">owedStorageCollateral</span> <span class="o">-=</span> <span class="nx">storageCollateral</span>

	<span class="c1">// make sure the miner can&#39;t be slashed twice for this deal
</span><span class="c1"></span>	<span class="nx">self</span><span class="p">.</span><span class="nx">ArbitratedDeals</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">commP</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<div class="notices todo" ><strong>TODO(scaling)</strong>: This method, as currently designed, must be called once per sector. If a miner agrees to store 1TB (1000 sectors) for a particular client, and loses all that data, the client must then call this method 1000 times, which will be really expensive.</div>

<h4 id="depledge"><code>DePledge</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> DePledge struct <span class="o">{</span>
    amount TokenAmount
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DePledge</span><span class="p">(</span><span class="nx">amt</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">Worker</span> <span class="o">&amp;&amp;</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">owner</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Not authorized to call DePledge&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">&gt;</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;too early to withdraw collateral&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">DePledgedCollateral</span><span class="p">)</span>
		<span class="nx">self</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">self</span><span class="p">.</span><span class="nx">DePledgedCollateral</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">collateralRequired</span> <span class="p">=</span> <span class="nf">CollateralForPower</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">power</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">amt</span><span class="o">+</span><span class="nx">collateralRequired</span> <span class="p">&gt;</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">MyBalance</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Not enough free collateral to withdraw that much&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">DePledgedCollateral</span> <span class="p">=</span> <span class="nx">amt</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">=</span> <span class="nx">CurrentBlockHeight</span> <span class="o">+</span> <span class="nx">DePledgeCooldown</span>
<span class="p">}</span></code></pre></div>
<h4 id="getowner"><code>GetOwner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetOwner struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetOwner</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">owner</span>
<span class="p">}</span></code></pre></div>
<h4 id="getworkeraddr"><code>GetWorkerAddr</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetWorkerAddr struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetWorkerAddr</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">worker</span>
<span class="p">}</span></code></pre></div>
<h4 id="getpower"><code>GetPower</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetPower struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetPower</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">power</span>
<span class="p">}</span></code></pre></div>
<h4 id="getpeerid"><code>GetPeerID</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetPeerID struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetPeerID</span><span class="p">()</span> <span class="nx">PeerID</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">peerID</span>
<span class="p">}</span></code></pre></div>
<h4 id="getsectorsize"><code>GetSectorSize</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetSectorSize struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetSectorSize</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">sectorSize</span>
<span class="p">}</span></code></pre></div>
<h4 id="updatepeerid"><code>UpdatePeerID</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UpdatePeerID struct <span class="o">{</span>
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UpdatePeerID</span><span class="p">(</span><span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">worker</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only the mine worker may update the peer ID&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">peerID</span> <span class="p">=</span> <span class="nx">pid</span>
<span class="p">}</span></code></pre></div>
<h4 id="changeworker"><code>ChangeWorker</code></h4>

<p>Changes the worker address. Note that since Sector Commitments take the miners worker key as an input, any sectors sealed with the old key but not yet submitted to the chain will be invalid. All future sectors must be sealed with the new worker key.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ChangeWorker struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChangeWorker</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">owner</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only the owner can change the worker address&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">worker</span> <span class="p">=</span> <span class="nx">addr</span>
<span class="p">}</span></code></pre></div>
<h4 id="islate"><code>IsLate</code></h4>

<p>IsLate checks whether the miner has submitted their PoSt on time (i.e. not after ProvingPeriodEnd).</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> IsLate struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsLate</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">provingPeriodEnd</span> <span class="p">&lt;</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="isslashed"><code>IsSlashed</code></h4>

<p>Checks whether the miner has been slashed and not recovered. Note that if the miner is slashed and recovers, this will return False: it checks current state rather than historical occurence.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> IsSlashed struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsSlashed</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">#</span> <span class="nx">SlashedAt</span> <span class="nx">is</span> <span class="nx">reset</span> <span class="nx">on</span> <span class="nx">recovery</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">SlashedAt</span> <span class="p">&gt;</span> <span class="mi">0</span>
<span class="p">}</span></code></pre></div>
<h4 id="paymentverifyinclusion"><code>PaymentVerifyInclusion</code></h4>

<p>Verifies a storage market payment channel voucher&rsquo;s &lsquo;Extra&rsquo; data by validating piece inclusion proof.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentVerify struct <span class="o">{</span>
    Extra Bytes
    Proof Bytes
<span class="o">}</span> representation tuple

<span class="nb">type</span> PieceInclusionVoucherData struct <span class="o">{</span>
    CommP Bytes
    PieceSize BigInt
<span class="o">}</span> representation tuple

<span class="nb">type</span> InclusionProof struct <span class="o">{</span>
    Sector BigInt // <span class="k">for</span> CommD, also verifies the sector is in sector <span class="nb">set</span>
    Proof  Bytes
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">PaymentVerifyInclusion</span><span class="p">(</span><span class="nx">extra</span> <span class="nx">PieceInclusionVoucherData</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">InclusionProof</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">has</span><span class="p">,</span> <span class="nx">commD</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nf">GetSector</span><span class="p">(</span><span class="nx">proof</span><span class="p">.</span><span class="nx">Sector</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">has</span> <span class="p">{</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner does not have required sector&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">ValidatePIP</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">extra</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">extra</span><span class="p">.</span><span class="nx">CommP</span><span class="p">,</span> <span class="nx">commD</span><span class="p">,</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">Proof</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="paymentverifysector"><code>PaymentVerifySector</code></h4>

<p>Verifies a storage market payment channel voucher&rsquo;s &lsquo;Extra&rsquo; data by checking for presence of a specified sector in miner&rsquo;s sector set.</p>

<p>Miners should prefer payment vouchers with this method used for validation over <code>PaymentVerifyInclusion</code>, because posting them to the chain will be much cheaper.</p>

<p>Clients should only create such vouchers after verifying that miners have related sectors in their sector set, and after checking piece inclusion proof.</p>

<p>Miners can incentivize clients to produce such vouchers by applying small &lsquo;discount&rsquo; to amount of token clients have to pay.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentVerify struct <span class="o">{</span>
    Extra Bytes
    Proof Bytes
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">PaymentVerifyInclusion</span><span class="p">(</span><span class="nx">extra</span> <span class="nx">BigInt</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">proof</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;unexpected proof bytes&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nf">HasSector</span><span class="p">(</span><span class="nx">extra</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="addfaults"><code>AddFaults</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> AddFaults struct <span class="o">{</span>
    faults FaultSet
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AddFaults</span><span class="p">(</span><span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">challengeBlockHeight</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span>

    <span class="k">if</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">challengeBlockHeight</span> <span class="p">{</span>
        <span class="c1">// Up to the challenge time new faults can be added.
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">currentFaultSet</span> <span class="p">=</span> <span class="nf">Merge</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">currentFaultSet</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// After that they are only accounted for in the next proving period
</span><span class="c1"></span>        <span class="nx">self</span><span class="p">.</span><span class="nx">nextFaultSet</span> <span class="p">=</span> <span class="nf">Merge</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">nextFaultSet</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h3 id="payment-channel-actor">Payment Channel Actor</h3>

<ul>
<li><strong>Code Cid:</strong> <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;paych&quot;&gt;</code></li>
</ul>

<p>The payment channel actor manages the on-chain state of a point to point payment channel.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentChannel struct <span class="o">{</span>
	from Address
	to   Address

	toSend       TokenAmount

	closingAt      UInt
	minCloseHeight UInt

	laneStates <span class="o">{</span>UInt:LaneState<span class="o">}</span>
<span class="o">}</span> representation tuple

<span class="nb">type</span> SignedVoucher struct <span class="o">{</span>
  TimeLock BlockHeight
  SecretPreimage Bytes
  Extra ModVerifyParams
  Lane Uint
  Nonce Uint
  Merges <span class="o">[]</span>Merge
  Amount TokenAmount
  MinCloseHeight Uint

  Signature Signature
<span class="o">}</span>

<span class="nb">type</span> ModVerifyParams struct <span class="o">{</span>
  Actor Address
  Method Uint
  Data Bytes
<span class="o">}</span>

<span class="nb">type</span> Merge struct <span class="o">{</span>
  Lane Uint
  Nonce Uint
<span class="o">}</span>

<span class="nb">type</span> LaneState struct <span class="o">{</span>
  Closed bool
  Redeemed TokenAmount
  Nonce Uint
<span class="o">}</span>

<span class="nb">type</span> PaymentChannelMethod union <span class="o">{</span>
  <span class="p">|</span> PaymentChannelConstructor <span class="m">0</span>
  <span class="p">|</span> UpdateChannelState <span class="m">1</span>
  <span class="p">|</span> Close <span class="m">2</span>
  <span class="p">|</span> Collect <span class="m">3</span>
<span class="o">}</span> representation keyed</code></pre></div>
<h4 id="methods-4">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Constructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>UpdateChannelState</code></td>
<td>2</td>
</tr>

<tr>
<td><code>Close</code></td>
<td>3</td>
</tr>

<tr>
<td><code>Collect</code></td>
<td>4</td>
</tr>
</tbody>
</table>

<h4 id="constructor-3"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentChannelConstructor struct <span class="o">{</span>
  to Address
<span class="o">}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<div class="notices todo" >TODO: Define me</div>

<h4 id="updatechannelstate"><code>UpdateChannelState</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UpdateChannelState struct <span class="o">{</span>
  sv SignedVoucher
  secret Bytes
  proof Bytes
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UpdateChannelState</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">SignedVoucher</span><span class="p">,</span> <span class="nx">secret</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">proof</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">validateSignature</span><span class="p">(</span><span class="nx">sv</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Signature Invalid&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">TimeLock</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot use this voucher yet!&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">SecretPreimage</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">Hash</span><span class="p">(</span><span class="nx">secret</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">SecretPreimage</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Incorrect secret!&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">vmctx</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">sv</span><span class="p">.</span><span class="nx">Extra</span><span class="p">.</span><span class="nx">Actor</span><span class="p">,</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Extra</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Extra</span><span class="p">.</span><span class="nx">Data</span><span class="p">,</span> <span class="nx">proof</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;spend voucher verification failed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">ls</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">LaneStates</span><span class="p">[</span><span class="nx">sv</span><span class="p">.</span><span class="nx">Lane</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">ls</span><span class="p">.</span><span class="nx">Closed</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot redeem a voucher on a closed lane&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">ls</span><span class="p">.</span><span class="nx">Nonce</span> <span class="p">&gt;</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Nonce</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;voucher has an outdated nonce, cannot redeem&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">mergeValue</span> <span class="nx">TokenAmount</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">merge</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Merges</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">merge</span><span class="p">.</span><span class="nx">Lane</span> <span class="o">==</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Lane</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;voucher cannot merge its own lane&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">ols</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">LaneStates</span><span class="p">[</span><span class="nx">merge</span><span class="p">.</span><span class="nx">Lane</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">ols</span><span class="p">.</span><span class="nx">Nonce</span> <span class="o">&gt;=</span> <span class="nx">merge</span><span class="p">.</span><span class="nx">Nonce</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;merge in voucher has outdated nonce, cannot redeem&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">mergeValue</span> <span class="o">+=</span> <span class="nx">ols</span><span class="p">.</span><span class="nx">Redeemed</span>
		<span class="nx">ols</span><span class="p">.</span><span class="nx">Nonce</span> <span class="p">=</span> <span class="nx">merge</span><span class="p">.</span><span class="nx">Nonce</span>
	<span class="p">}</span>

	<span class="nx">ls</span><span class="p">.</span><span class="nx">Nonce</span> <span class="p">=</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Nonce</span>
	<span class="nx">balanceDelta</span> <span class="p">=</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Amount</span> <span class="o">-</span> <span class="p">(</span><span class="nx">mergeValue</span> <span class="o">+</span> <span class="nx">ls</span><span class="p">.</span><span class="nx">Redeemed</span><span class="p">)</span>
	<span class="nx">ls</span><span class="p">.</span><span class="nx">Redeemed</span> <span class="p">=</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">Amount</span>

	<span class="nx">newSendBalance</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ToSend</span> <span class="o">+</span> <span class="nx">balanceDelta</span>
	<span class="k">if</span> <span class="nx">newSendBalance</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// TODO: is this impossible?
</span><span class="c1"></span>		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;voucher would leave channel balance negative&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">newSendBalance</span> <span class="p">&gt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Balance</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough funds in channel to cover voucher&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">ToSend</span> <span class="p">=</span> <span class="nx">newSendBalance</span>

	<span class="k">if</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">MinCloseHeight</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="p">&lt;</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">MinCloseHeight</span> <span class="p">{</span>
			<span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="p">=</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">MinCloseHeight</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">MinCloseHeight</span> <span class="p">&lt;</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">MinCloseHeight</span> <span class="p">{</span>
			<span class="nx">self</span><span class="p">.</span><span class="nx">MinCloseHeight</span> <span class="p">=</span> <span class="nx">sv</span><span class="p">.</span><span class="nx">MinCloseHeight</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Hash</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">blake2b</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="close"><code>Close</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Close struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">ChannelClosingDelay</span> <span class="p">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">// six hours
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">From</span> <span class="o">&amp;&amp;</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">To</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized to close channel&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Channel already closing&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="p">=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="o">+</span> <span class="nx">ChannelClosingDelay</span>
	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="p">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">MinCloseHeight</span> <span class="p">{</span>
		<span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">MinCloseHeight</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="collect"><code>Collect</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Collect struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Collect</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;payment channel not closing or closed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ClosingAt</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Payment channel not yet closed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Balance</span><span class="o">-</span><span class="nx">self</span><span class="p">.</span><span class="nx">ToSend</span><span class="p">)</span>
	<span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ToSend</span><span class="p">)</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">ToSend</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span></code></pre></div>
<h3 id="multisig-account-actor">Multisig Account Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;multisig&quot;&gt;</code></li>
</ul>

<p>A basic multisig account actor. Allows sending of messages like a normal account actor, but with the requirement of M of N parties agreeing to the operation. Completed and/or cancelled operations stick around in the actors state until explicitly cleared out. Proposers may cancel transactions they propose, or transactions by proposers who are no longer approved signers.</p>

<p>Self modification methods (add/remove signer, change requirement) are called by
doing a multisig transaction invoking the desired method on the contract itself. This means the &lsquo;signature
threshold&rsquo; logic only needs to be implemented once, in one place.</p>

<p>The <a href="#init-actor">init actor</a> is used to create new instances of the multisig.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> MultisigActorState struct <span class="o">{</span>
    signers <span class="o">[</span>Address<span class="o">]</span>
    required UInt
    nextTxId UInt
    initialBalance UInt
    startingBlock UInt
    unlockDuration UInt
    transactions <span class="o">{</span>UInt:Transaction<span class="o">}</span>
<span class="o">}</span>

<span class="nb">type</span> Transaction struct <span class="o">{</span>
    txID UInt
    to Address
    value TokenAmount
    method <span class="p">&amp;</span>ActorMethod
    approved <span class="o">[</span>Address<span class="o">]</span>
    completed Bool
    canceled Bool
    retcode UInt
<span class="o">}</span></code></pre></div>
<h4 id="methods-5">Methods</h4>

<table>
<thead>
<tr>
<th>Name</th>
<th>Method ID</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>MultisigConstructor</code></td>
<td>1</td>
</tr>

<tr>
<td><code>Propose</code></td>
<td>2</td>
</tr>

<tr>
<td><code>Approve</code></td>
<td>3</td>
</tr>

<tr>
<td><code>Cancel</code></td>
<td>4</td>
</tr>

<tr>
<td><code>ClearCompleted</code></td>
<td>5</td>
</tr>

<tr>
<td><code>AddSigner</code></td>
<td>6</td>
</tr>

<tr>
<td><code>RemoveSigner</code></td>
<td>7</td>
</tr>

<tr>
<td><code>SwapSigner</code></td>
<td>8</td>
</tr>

<tr>
<td><code>ChangeRequirement</code></td>
<td>9</td>
</tr>
</tbody>
</table>

<h4 id="constructor-4"><code>Constructor</code></h4>

<p>This method sets up the initial state for the multisig account</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> MultisigConstructor struct <span class="o">{</span>
    <span class="c1">## The addresses that will be the signatories of this wallet.</span>
    signers <span class="o">[</span>Address<span class="o">]</span>
    <span class="c1">## The number of signatories required to perform a transaction.</span>
    required UInt
    <span class="c1">## Unlock time (in blocks) of initial filecoin balance of this wallet. Unlocking is linear.</span>
    unlockDuration UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Multisig</span><span class="p">(</span><span class="nx">signers</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">required</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">unlockDuration</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span> <span class="p">=</span> <span class="nx">signers</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">=</span> <span class="nx">required</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">initialBalance</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">unlockDuration</span> <span class="p">=</span> <span class="nx">unlockDuration</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">startingBlock</span> <span class="p">=</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="propose"><code>Propose</code></h4>

<p>Propose is used to propose a new transaction to be sent by this multisig. The proposer must be a signer, and the proposal also serves as implicit approval from the proposer. If only a single signature is required, then the transaction is executed immediately.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Propose struct <span class="o">{</span>
    <span class="c1">## The address of the target of the proposed transaction.</span>
    to Address
    <span class="c1">## The amount of funds to send with the proposed transaction.</span>
    value TokenAmount
    <span class="c1">## The method and parameters that will be invoked on the proposed transactions target.</span>
    method <span class="p">&amp;</span>ActorMethod
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Propose</span><span class="p">(</span><span class="nx">to</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">String</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">txid</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">NextTxID</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">NextTxID</span><span class="o">++</span>

	<span class="nx">tx</span> <span class="o">:=</span> <span class="nx">Transaction</span><span class="p">{</span>
		<span class="nx">TxID</span><span class="p">:</span>     <span class="nx">txid</span><span class="p">,</span>
		<span class="nx">To</span><span class="p">:</span>       <span class="nx">to</span><span class="p">,</span>
		<span class="nx">Value</span><span class="p">:</span>    <span class="nx">value</span><span class="p">,</span>
		<span class="nx">Method</span><span class="p">:</span>   <span class="nx">method</span><span class="p">,</span>
		<span class="nx">Params</span><span class="p">:</span>   <span class="nx">params</span><span class="p">,</span>
		<span class="nx">Approved</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">{</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">canSpend</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction amount exceeds available&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">RetCode</span> <span class="p">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">txid</span>
<span class="p">}</span></code></pre></div>
<h4 id="approve"><code>Approve</code></h4>

<p>Approve is called by a signer to approve a given transaction. If their approval pushes the approvals for this transaction over the threshold, the transaction is executed.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Approve struct <span class="o">{</span>
    <span class="c1">## The ID of the transaction to approve.</span>
    txid UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Approve</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">tx</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nf">getTransaction</span><span class="p">(</span><span class="nx">txid</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction already completed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction canceled&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">signer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">signer</span> <span class="o">==</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;already signed this message&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">canSpend</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction amount exceeds available&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">RetCode</span> <span class="p">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="cancel"><code>Cancel</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Cancel struct <span class="o">{</span>
    txid UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Cancel</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">tx</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nf">getTransaction</span><span class="p">(</span><span class="nx">txid</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot cancel completed transaction&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction already canceled&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">proposer</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">proposer</span> <span class="o">!=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">&amp;&amp;</span> <span class="nf">isSigner</span><span class="p">(</span><span class="nx">proposer</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot cancel another signers transaction&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span></code></pre></div>
<h4 id="clearcompleted"><code>ClearCompleted</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ClearCompleted struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ClearCompleted</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">tx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Completed</span> <span class="o">||</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">{</span>
			<span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="addsigner"><code>AddSigner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> AddSigner struct <span class="o">{</span>
    signer Address
    increaseReq bool
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AddSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">increaseReq</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;add signer must be called by wallet itself&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;new address is already a signer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">increaseReq</span> <span class="p">{</span>
		<span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="removesigner"><code>RemoveSigner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> RemoveSigner struct <span class="o">{</span>
    signer Address
    decreaseReq bool
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RemoveSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">decreaseReq</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;remove signer must be called by wallet itself&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given address was not a signer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">decreaseReq</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">{</span>
		<span class="c1">// Reduce Required outherwise the wallet is locked out
</span><span class="c1"></span>		<span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="swapsigner"><code>SwapSigner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SwapSigner struct <span class="o">{</span>
    old Address
    new Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SwapSigner</span><span class="p">(</span><span class="nx">old</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;swap signer must be called by wallet itself&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given old address was not a signer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given new address was already a signer&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="changerequirement"><code>ChangeRequirement</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ChangeRequirement struct <span class="o">{</span>
    requirement UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChangeRequirement</span><span class="p">(</span><span class="nx">req</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;change requirement must be called by wallet itself&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;requirement must be at least 1&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;requirement must be less than number of signers&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">=</span> <span class="nx">req</span>
<span class="p">}</span></code></pre></div>
<h2 id="helper-methods">Helper Methods</h2>

<p>The various helper methods called above are defined here.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isSigner</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">signer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">signer</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getTransaction</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">Transaction</span> <span class="p">{</span>
	<span class="nx">tx</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">[</span><span class="nx">txid</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no such transaction&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">tx</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AggregateBitfields</span><span class="p">(</span><span class="nx">faults</span> <span class="p">[]</span><span class="nx">FaultSet</span><span class="p">)</span> <span class="nx">Bitfield</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">out</span> <span class="nx">Bitfield</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">faults</span> <span class="p">{</span>
		<span class="nx">out</span> <span class="p">=</span> <span class="nx">out</span><span class="p">.</span><span class="nf">Union</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">bitField</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BurnFunds</span><span class="p">(</span><span class="nx">amt</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">BurntFundsAddress</span><span class="p">,</span> <span class="nx">amt</span><span class="p">)</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">canSpend</span><span class="p">(</span><span class="nx">amt</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">unlockDuration</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">MinAllowableBalance</span> <span class="p">=</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">initialBalance</span> <span class="o">/</span> <span class="nx">self</span><span class="p">.</span><span class="nx">unlockDuration</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">VM</span><span class="p">.</span><span class="nf">CurrentBlockHeight</span><span class="p">()</span> <span class="o">-</span> <span class="nx">self</span><span class="p">.</span><span class="nx">startingBlock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">MinAllowableBalance</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nf">MyBalance</span><span class="p">()</span> <span class="o">-</span> <span class="nx">amt</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h1 id="faults">Faults</h1>

<p>A fault is what happens when partcipants in the protocol are behaving incorrectly and that behavior needs to be punished. There are a number of possible faults in the Filecoin protocol, their details are all recorded below.</p>

<h2 id="fault-list">Fault List</h2>

<h3 id="consensus-faults">Consensus Faults</h3>

<ul>
<li><strong>Duplicate Block Submission Slashing:</strong>

<ul>
<li><strong>Condition:</strong> If any miner posts two blocks satisfying the slashing conditions defined in <a href="expected-consensus.md">Expected Consensus</a>.</li>
<li><strong>Reporting:</strong> Anyone may call <code>SlashConsensusFault</code> and pass in the two offending block headers.</li>
<li><strong>Check:</strong> The chain checks that both blocks are valid, correctly signed by the same miner, and satisfy the consensus slashing conditions.</li>
<li><strong>Penalization:</strong> All of the miner&rsquo;s pledge collateral and all of their power is irrevocably slashed. This miner can never again produce blocks, even if they attempt to repost their collateral.</li>
</ul></li>
</ul>

<h3 id="market-faults">Market Faults</h3>

<ul>
<li><strong>Late submission penalty:</strong>

<ul>
<li><strong>Condition</strong>: If the miner posts their PoSt after the proving period ends, but before the generation attack threshold.</li>
<li><strong>Reporting:</strong> The miner submits their PoSt as usual, but includes the late submission fee.</li>
<li><strong>Check:</strong> The chain checks first that the submission is within the <code>generation attack threshold</code>, and then checks that the fee provided matches the required fee for how many blocks late the submission is.</li>
<li><strong>Penalization:</strong> The miner is penalized proportionally to the delay. Penalizations are enforced by a standard PoSt submission.</li>
<li><em>Economic penalization</em>: To determine the penalty amount, <code>ComputeLateFee(minerPower, numLate)</code> is called.</li>
<li><em>Power penalization</em>: The miners&rsquo; power is not reduced. Note that the current view of the power table is computed with the lookback parameter.

<ul>
<li><em>Why are we accounting the power table with a lookback parameter ?</em> If we do not use the lookback parameter then, we need to penalize late miners for the duration that they are late. This is tricky to do efficiently. For xample, if miners A, B and C each have <sup>1</sup>&frasl;<sub>3</sub> of the networks power, and C is late in submitting their proofs, then for that duration, A and B should each have effectively half of the networks power (and a 50% chance each of winning the block).</li>
</ul></li>
<li>TODO: write on the spec exact parameters for PoSt Deadline and Gen Attack threshold</li>
</ul></li>
<li><strong>Unreported storage fault slashing:</strong>

<ul>
<li><strong>Condition:</strong> If the miner does not submit their PoSt by the <code>generation attack threshold</code>.</li>
<li><strong>Reporting:</strong> The miner can be slashed by anyone else in the network who calls <code>SlashStorageFaults</code>. We expect miners to report these faults.</li>
<li>Future design note: moving forward, we should either compensate the caller, or require this</li>
<li>Note: we could <em>require</em> the method be called, as part of the consensus rules (this gets complicated though). In this case, there is a DoS attack where if I make a large number of miners each with a single sector, and fail them all at the same time, the next block miner will be forced to do a very large amount of work. This would either need an extended &lsquo;gas limit&rsquo;, or some other method to avoid too long validation times.</li>
<li><strong>Check:</strong> The chain checks that the miners last PoSt submission was before the start of their current proving period, and that the current block is after the generation attack threshold for their current proving period.</li>
<li><strong>Penalization:</strong> Penalizations are enforced by <code>SlashStorageFault</code> on the <code>storage market</code> actor.</li>
<li><em>Economic Penalization</em>: Miner loses all collateral.</li>
<li><em>Power Penalization</em>: Miner loses all power.</li>
<li>Note: If a miner is in this state, where they have failed to submit a PoST, any block they attempt to mine will be invalid, even if the election function selects them. (the election function should probably be made to never select them)</li>
<li>Future design note: There is a way to tolerate Internet connection faults. A miner runs an Emergency PoSt which does not take challenges from the chain, if the miner gets reconnected before the VDF attack time (based on Amax), then, they can submit the Emergency PoSt and get pay a late penalization fee.</li>
</ul></li>
<li><strong>Reported storage fault penalty:</strong>

<ul>
<li><strong>Condition:</strong> The miner submits their PoSt with a non-empty set of &lsquo;missing sectors&rsquo;.</li>
<li><strong>Reporting:</strong> The miner can specify some sectors that they failed to prove during the proving period.</li>
<li>Note: These faults are output by the <code>ProveStorage</code> routine, and are posted on-chain when posting the proof. This occurs when the miner (for example) has a disk failure, or other local data corruption.</li>
<li><strong>Check:</strong> The chain checks that the proof verifies with the missing sectors.</li>
<li><strong>Penalization:</strong> The miner is penalized for collateral and power proportional to the number of missing sectors. The sectors are also removed from the miners proving set.</li>
<li>TODO: should the collateral lost here be proportional to the remaining time?</li>
<li>TODO(nicola): check if the time between posting two proofs allows for a generation attack if it does not then we might reconsider the sector not being lost</li>
<li>Note: if a sector is missed here, and they are recovered after the fact, the miner could simple &rsquo;re-commit&rsquo; the sector. They still have to pay the collateral, but the data can be quickly re-introduced into the system to avoid clients calling them out for breach of contract (this would only work because the sector commD/commR is the same)</li>
<li>Note: In the case where a miner is temporarily unable to prove some of their data, they can simply wait for the temporary unavailability to recover, and then continue proving, submitting the proofs a bit late if necessary (paying appropriate fees, as described above).</li>
</ul></li>
<li><strong>Breach of contract dispute:</strong>

<ul>
<li><strong>Condition:</strong> A client who has stored data with a miner, and the miner removes the sector containing that data before the end of the agreed upon time period.</li>
<li><strong>Reporting:</strong> The client invokes <code>ArbitrateDeal</code> on the offending miner actor with a signed deal from that miner for the storage in question. Note: the reporting must happen within one proving period of the miner removing the storage erroneously.</li>
<li><strong>Check:</strong> The chain checks that the deal was correctly signed by the miner in question, that the deal has not yet expired, and that the sector referenced by the deal is no longer in the miners proving set.</li>
<li><strong>Penalization:</strong> The miner is penalized an amount proportional to the incorrectly removed sector. This penalty is taken from their pledged collateral .</li>
<li>Note: This implies that miners cannot re-seal data into different sectors. We could come up with a protocol where the client gives the miner explicit consent to re-seal, but that is more complicated and can be done later.</li>
</ul></li>
</ul>

<h1 id="pledge-collateral">Pledge Collateral</h1>

<p>Filecoin includes a concept of &ldquo;Pledge Collateral&rdquo;, which is FIL collateral that storage miners must lock up when participating as miners.</p>

<p>Pledge collateral serves several functions in Filecoin. It:
- makes it possible to slash misbehaving or slow miners
- ensures that miners have skin in the game (for the Filecoin network as a whole)
- increases the cost of launching a 51% attack</p>

<h2 id="computing-pledge-collateral">Computing Pledge Collateral</h2>

<p>The total pledge collateral across all miners is a fixed proportion of available FIL.
Available FIL is computed as the total amount of FIL that has been mined, plus the total amount of FIL that&rsquo;s been vested, minued the amount of FIL which has been burned.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">availableFil</span> <span class="o">:=</span> <span class="nx">minedFil</span> <span class="o">+</span> <span class="nx">vestedFil</span> <span class="o">-</span> <span class="nx">burnedFil</span></code></pre></div>
<p>Pledge collateral is subdivided into two kinds: power collateral and per-capita collateral.
Power collateral is split across miners according to their share of the total network power, and per-capita collateral is split across miners evenly.
Two parameters, <code>POWER_COLLATERAL_PROPORTION</code> and <code>PER_CAPITA_COLLATERAL_PROPORTION</code>, relate the total amount of collateral to the <code>availableFil</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">totalPowerCollateral</span> <span class="o">:=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="nx">POWER_COLLATERAL_PROPORTION</span>
<span class="nx">totalPerCapitaCollateral</span> <span class="o">:=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="nx">PER_CAPITA_COLLATERAL_PROPORTION</span>
<span class="nx">totalPledgeCollateral</span> <span class="o">:=</span> <span class="nx">totalPowerCollateral</span> <span class="o">+</span> <span class="nx">totalPerCapitaCollateral</span></code></pre></div>
<p>Power-based collateral ensures that miners&rsquo; collateral is proportional to their economic size and to their expected rewards.
The presence of per-capital collateral acts as a deterrent against Sibyl attacks.
We intend for the <code>POWER_COLLATERAL_PROPORTION</code> to be several times larger than the <code>PER_CAPITA_COLLATERAL_PROPORTION</code>.</p>

<p>To calculate any particular miner&rsquo;s collateral requirements, we need to know the miner&rsquo;s power, the total network power, and the total number of miners in the network.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">minerPowerCollateral</span> <span class="o">:=</span> <span class="nx">totalPowerCollateral</span> <span class="o">*</span> <span class="nx">minerPower</span> <span class="o">/</span> <span class="nx">totalNetworkPower</span>
<span class="nx">minerPerCapitaCollateral</span> <span class="o">:=</span> <span class="nx">totalPerCapitaCollateral</span> <span class="o">/</span> <span class="nx">numMiners</span></code></pre></div>
<p>Putting all these variables together, we have each miner&rsquo;s individual collateral requirement:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">minerPlegeCollateral</span> <span class="o">:=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="p">(</span> <span class="nx">POWER_COLLATERAL_PROPORTION</span> <span class="o">*</span> <span class="nx">minerPower</span> <span class="o">/</span> <span class="nx">totalNetworkPower</span> <span class="nx">PER_CAPITA_COLLATERAL_PROPORTION</span> <span class="o">/</span> <span class="nx">numMiners</span><span class="p">)</span></code></pre></div>
<h2 id="dealing-with-undercollateralization">Dealing with Undercollateralization</h2>

<p>In the course of normal events, miners may become undercollateralized.</p>

<p>They cannot directly undercollateralized themselves by adding more power, as commitSector will fail if they do not have sufficient collateral to cover their power requirements.
However, their collateral requirement could increase due to growth in availableFil, a reduction in the total network power, or a reduction in the total number of miners.
In such cases, the miner may continue to submit PoSts and mine blocks. When they win blocks, their block rewards will be garnished while they remain undercollateralized.</p>

<h2 id="parameter-choices">Parameter Choices</h2>

<p>We provisionally propose the following two parameters choices:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">POWER_COLLATERAL_PROPORTION</span> <span class="o">:=</span> <span class="mf">0.2</span>
<span class="nx">PER_CAPITA_COLLATERAL_PROPORTION</span> <span class="o">:=</span> <span class="mf">0.05</span></code></pre></div>
<p>These are subject to change before launch.</p>




</div>

  


</div>

  

  
    








<div id="subsystems__vm__actors">

<h3>
  Filecoin VM Actors
</h3>

<div id="subsystems__vm__actors__actorstate"></div><h3>ActorState</h3>

<p>The following data structures use <em>kinded</em> representations for their IPLD
encodings, since the types can be inferred from the context in which they are used
(<code>Actor</code> or <code>UnsignedMessage</code>).</p>

<p><div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ActorState</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">InitActorState</span>
    <span class="p">|</span> <span class="nx">AccountActorState</span>
    <span class="p">|</span> <span class="nx">StorageMarketActorState</span>
    <span class="p">|</span> <span class="nx">StorageMinerActorState</span>
    <span class="p">|</span> <span class="nx">PaymentChannelBrokerActorState</span>
    <span class="p">|</span> <span class="nx">MultisigActorState</span>
<span class="p">}</span> <span class="c1">// representation kinded
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ActorMethod</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">InitActorMethod</span>
    <span class="p">|</span> <span class="nx">AccountActorMethod</span>
    <span class="p">|</span> <span class="nx">StorageMarketActorMethod</span>
    <span class="p">|</span> <span class="nx">StorageMinerActorMethod</span>
    <span class="p">|</span> <span class="nx">PaymentChannelBrokerActorMethod</span>
    <span class="p">|</span> <span class="nx">MultisigActorMethod</span>
<span class="p">}</span> <span class="c1">// representation kinded
</span></code></pre></div>
  
</div>
</p>



  
    








<div id="subsystems__vm__actors__standard">

<h4>
  Standard Actors
</h4>

<p>TODO</p>



  

  

  

  


</div>

  

  
    








<div id="subsystems__vm__actors__singleton">

<h4>
  Singleton Actors
</h4>

<p>TODO</p>



  

  


</div>

  


</div>

  


</div>

  

  
    








<div id="subsystems__storage">

<h2>
  Storage Market
</h2>



<h2 id="the-filecoin-storage-market">The Filecoin Storage Market</h2>

<p>The Filecoin <code>storage market</code> is the underlying system used to discover, negotiate and form <code>storage contracts</code> between clients and storage providers called <code>storage miners</code> in a Filecoin network. The <code>storage market</code> itself is an <code>actor</code> that helps to mediate certain operations in the market, including adding new miners, and punishing faulty ones, it does not directly mediate any actual storage deals. The <code>storage contracts</code> between clients and miners specify that a given <code>piece</code> will be stored for a given time duration. It is assumed that the <code>client</code>, or some delegate of the client, remains online to monitor the <code>storage miner</code> and <code>slash</code> it in the case that the agreed upon data is removed from the miners proving set before the deal is finished.</p>

<p>The creation of such a storage market is motivated by the need to provide a fast, reliable and inexpensive solution to data generated worldwide. The cost and difficulty involved in starting datacenters around the world make a decentralized solution attractive here, enabling clients and miners to interact directly, forming agreements for storage ad-hoc around the world. Geography is only one such aspect in which a decentralized market can be made competitive. You can read more about the underlying motivations for building a storage market <a href="https://www.youtube.com/watch?v=EClPAFPeXIQ">here</a>.</p>

<p>In the current design of the <code>storage market</code>, <code>storage miners</code> post <code>asks</code> indicating the price they are willing to accepts, and <code>clients</code> select (either manually, or via some locally run algorithm) a set of storage miners to store their data with. They then contact the <code>storage miners</code> who programmatically either accept or deny their <code>deal proposals</code>. In the future, we may allow miners to search for clients and propose deals to them, but for now, for simplicity, we stick with the model described above.</p>

<h3 id="visualization-of-the-filecoin-storage-market">Visualization of the Filecoin Storage Market</h3>

<p>TODO: This is a high level overview of how the storage market interacts with components</p>

<h2 id="the-market-interface">The Market Interface</h2>

<p>This interface, written using Go type notation, defines the set of methods that are callable on the storage market actor. The storage market actor is a built-in network actor. For more information about Actors, see <a href="actors.md">actors.md</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StorageMarket</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// CreateStorageMiner registers a new storage miner with the given public key and a
</span><span class="c1"></span>	<span class="c1">// pledge of the given size. The miners collateral is set by the value in the message.
</span><span class="c1"></span>	<span class="c1">// The public key must match the private key used to sign off on blocks created
</span><span class="c1"></span>	<span class="c1">// by this miner. This key is the &#39;worker&#39; key for the miner.
</span><span class="c1"></span>	<span class="c1">// The libp2p peer ID specified should reference the libp2p identity that the
</span><span class="c1"></span>	<span class="c1">// miner is operating. This is the ID that clients will connect to to propose deals
</span><span class="c1"></span>	<span class="c1">// TODO: maybe rename to &#39;RegisterStorageMiner&#39;?
</span><span class="c1"></span>	<span class="nf">CreateStorageMiner</span><span class="p">(</span><span class="nx">pubk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">pledge</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span><span class="p">)</span> <span class="nx">Address</span>

	<span class="c1">// SlashConsensusFault is used to slash a misbehaving miner who submitted two different
</span><span class="c1"></span>	<span class="c1">// blocks at the same block height. The signatures on each block are validated
</span><span class="c1"></span>	<span class="c1">// and the offending miner has their entire collateral slashed, including the
</span><span class="c1"></span>	<span class="c1">// invalidation of any any all storage they are providing. The caller is rewarded
</span><span class="c1"></span>	<span class="c1">// a small amount to compensate for gas fees (TODO: maybe it should be more?)
</span><span class="c1"></span>	<span class="nf">SlashConsensusFault</span><span class="p">(</span><span class="nx">blk1</span><span class="p">,</span> <span class="nx">blk2</span> <span class="nx">BlockHeader</span><span class="p">)</span>

	<span class="c1">// SlashStorageFault slashes a storage miner for not submitting their PoSTs within
</span><span class="c1"></span>	<span class="c1">// the correct [time window](#TODO-link-to-faulty-submission). This may be called by anyone who detects the faulty behavior.
</span><span class="c1"></span>	<span class="c1">// The slashed miner then loses all of their staked collateral, and also loses all
</span><span class="c1"></span>	<span class="c1">// of their power, and as a result, is no longer a candidate leader for extending the chain.
</span><span class="c1"></span>	<span class="nf">SlashStorageFault</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">Address</span><span class="p">)</span>

	<span class="c1">// UpdateStorage is called by a miner to adjust the storage market actors
</span><span class="c1"></span>	<span class="c1">// accounting of the total storage in the storage market.
</span><span class="c1"></span>	<span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">delta</span> <span class="nx">BytesAmount</span><span class="p">)</span>

	<span class="c1">// GetTotalStorage returns the total committed storage in the system. This number is
</span><span class="c1"></span>	<span class="c1">// also used as the &#39;total power&#39; in the system for the purposes of the power table
</span><span class="c1"></span>	<span class="nf">GetTotalStorage</span><span class="p">()</span> <span class="nx">BytesAmount</span>
<span class="p">}</span></code></pre></div>
<h2 id="the-filecoin-storage-market-operation">The Filecoin Storage Market Operation</h2>

<p>The Filecoin storage market operates as follows. Miners providing storage submit ask orders, asking for a certain price for their available storage space, and clients with files to store look through the asks and select a miner they wish to use. Clients negotiate directly with the storage miner that owns that ask, off-chain. Storage is priced in terms of Filecoin per byte per block (note: we may change the units here).</p>

<h3 id="market-datastructures">Market Datastructures</h3>

<p>The storage market contains the following data:</p>

<ul>
<li>StorageMiners - The storage market keeps track of the set of the addresses of all storage miners in the storage market. All miners referenced here were created by the storage market via the <code>CreateStorageMiner</code> method.</li>
<li>TotalComittedStorage - This is a tally of all the committed storage in the network. This is both a nice metric to see how much data is being stored by the filecoin network, and a critical piece of information used by mining routine to compute each miners storage ratio.</li>
</ul>

<h2 id="market-flow">Market Flow</h2>

<p>This section describes the flow required to store a single piece with a single storage miner. Most use-cases will involve performing this process for multiple pieces, with different miners.</p>

<h4 id="before-deal">Before Deal</h4>

<ol>
<li><strong>Data Preparation:</strong> The client prepares their input data. See <a href="client-data.md">client data</a> for more details.</li>
<li><strong>Miner Selection:</strong> The client looks at asks on the network, and then selects a storage miner to store their data with.

<ul>
<li>Note: this is currently a manual process.</li>
</ul></li>
<li><strong>Payment Channel Setup:</strong> The client calls <a href="#payments"><code>Payment.Setup</code></a> with the piece and the funds they are going to pay the miner with. All payments between clients and storage providers use payment channels.</li>
</ol>

<h4 id="deal">Deal</h4>

<p>Note: The details of this protocol including formats, datastructures, and algorithms, can be found <a href="network-protocols.md#storage-deal">here</a>.</p>

<ol>
<li><p><strong>Storage Deal Staging:</strong> The client now runs the <a href="network-protocols.md#storage-deal">&lsquo;make storage deal&rsquo;</a> protocol, as follows:</p>

<ul>
<li>The client sends a <code>StorageDealProposal</code> for the piece in question</li>
<li>This contains updates for the payment channel that the client may close at any time, unless the piece gets confirmed (see next section), in which case the miner is able to extend the channel.</li>
<li>The miner decides whether or not to accept the deal and sends back a <code>StorageDealResponse</code></li>
<li>Note: Different implementations may come up with different ways of making a decision on a given deal.</li>
<li>If the miner accepts, the client now sends the data to the miner</li>
<li>Once the miner receives the data:</li>
<li>They validate that the data matches the storage market hash claimed by the client</li>
<li>They stage it into a sector and set the deal state to <code>Staged</code></li>
</ul></li>

<li><p><strong>Storage Deal Start</strong>: Clients makes sure data is in a <a href="definitions.md#sector">sector</a></p>

<ul>
<li><strong>PieceInclusionProof:</strong> Once the miner seals the sector, they update the PieceInclusionProof in the deal state, which the client then gets the next time they query that state.

<ul>
<li>The PieceInclusionProof proves that the piece in the deal is contained in a sector whose commitment is on chain. The <code>commP</code> hash from earlier is used here. See <a href="proofs.md#piece-inclusion-proof">piece inclusion proof for more details</a></li>
</ul></li>
<li>Note: a client that is not interested in staying online to wait for PieceInclusionProof can leave immediately, however, they run the risk that their files don&rsquo;t actually get stored (but if their data is not stored, the miner will not be able to claim payment for it).

<ul>
<li>Note: In order to provide the piece inclusion proof, the miner needs to fill the sector. This may take some time. So there is a wait between the time the data is transferred to the miner, and when the piece inclusion proof becomes available.</li>
</ul></li>
<li><strong>Mining</strong>: Miner posts <code>seal commitment</code> and associated proof on chain by calling <code>CommitSector</code> and starts running <code>proofs of spacetime</code>. See <a href="mining.md#storage-mining-cycle">storage mining cycle</a> for more details.</li>
</ul></li>

<li><p><strong>Storage Deal Abort:</strong> If the miner doesn&rsquo;t provide the PieceInclusionProof, the client can invalidate the payment channel.</p>

<ul>
<li>This is done by invoking the &lsquo;close&rsquo; method on the channel on-chain. This process starts a timer that, on finishing, will release the funds to the client.</li>
<li>If a client attempts to abort a deal that they have actually made with a miner, the miner can submit a payment channel update to force the channel to stay open for the length of the agreement.</li>
</ul></li>

<li><p><strong>Storage Deal Complete:</strong> The client periodically queries the miner for the deals status until the deal is &lsquo;complete&rsquo;, at which point the client knows that the data is properly replicated.</p>

<ul>
<li>The client should store the returned &lsquo;PieceInclusionProof&rsquo; for later validation.</li>
</ul></li>
</ol>

<p>TODO: &lsquo;complete&rsquo; isnt really the right word here, as it implies that the deal is over.</p>

<ol>
<li><strong>Income Withdrawal</strong>: When the miner wishes to withdraw funds, they call <a href="#payments"><code>Payment.RedeemVoucher</code></a>.</li>
</ol>

<h2 id="the-power-table">The Power Table</h2>

<p>The <code>power table</code> is exported by the storage market for use by consensus. There isn&rsquo;t actually a concrete object that is the power table (though the concept is conceptually helpful), instead, the <a href="actors.md#storage-market-actor">storage market actor</a> exports the <code>GetTotalStorage</code> and <code>PowerLookup</code>  methods which can be used to lookup total network power and a miner&rsquo;s power, respectively.
Each individual miner reports its power through their actor.</p>

<p>To check the power of a given miner, use the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetMinersPowerAt</span><span class="p">(</span><span class="nx">ts</span> <span class="nx">TipSet</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">Integer</span> <span class="p">{</span>
  <span class="nx">curState</span> <span class="o">:=</span> <span class="nf">GetStateTree</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
  <span class="nx">miner</span> <span class="o">:=</span> <span class="nx">curState</span><span class="p">.</span><span class="nf">GetMiner</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">IsSlashed</span><span class="p">()</span> <span class="o">||</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">IsLate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
  
  <span class="err">#</span> <span class="nx">lookback</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">valid</span> <span class="nx">PoSt</span> <span class="nx">put</span> <span class="nx">up</span> <span class="nx">by</span> <span class="nx">the</span> <span class="nx">miner</span>
  <span class="nx">lookbackTipset</span> <span class="o">:=</span> <span class="nf">WalkBack</span><span class="p">(</span><span class="nx">ts</span><span class="p">,</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">provingPeriodEnd</span> <span class="o">-</span> <span class="nf">provingPeriodDuration</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">))</span>
  <span class="nx">lbState</span> <span class="o">:=</span> <span class="nf">GetStateTree</span><span class="p">(</span><span class="nx">lookbackTipset</span><span class="p">)</span>
  
  <span class="nx">sm</span> <span class="o">:=</span> <span class="nx">lbState</span><span class="p">.</span><span class="nf">GetStorageMarket</span><span class="p">()</span>
  
  <span class="k">return</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">PowerLookup</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h3 id="power-updates">Power Updates</h3>

<p>Whenever a new <a href="proofs.md">PoSt</a> or <a href="faults.md">Fault</a> makes it on chain, the storage market updates the underlying power values appropriately.</p>

<p>Specifically, a miner&rsquo;s power is initialized/maintained when they <a href="actors.md#submitPoSt">submit a valid PoSt</a> to the chain, and decreases if they are slashed (for a <a href="actors.md#slashStorageFault">storage fault</a> or a <a href="actors.md#slashConsensusFault">consensus fault</a>).</p>

<p>Power is deducted when miners remove sectors by reporting the sector &lsquo;missing&rsquo; or &lsquo;done&rsquo; in a PoSt.</p>

<h2 id="payments">Payments</h2>

<p>The storage market expects a payments system to allow clients to pay miners for storage. Any payments system that has the following capabilities may be used:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Payments</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Setup sets up a payment from the caller to the target address. The payment
</span><span class="c1"></span>	<span class="c1">// MUST be contingent on the miner being able to prove that they have the data
</span><span class="c1"></span>	<span class="c1">// referenced by &#39;piece&#39;. The total amount of Filecoin that may be transfered by
</span><span class="c1"></span>	<span class="c1">// this payment is specified by &#39;value&#39;
</span><span class="c1"></span>	<span class="nf">Setup</span><span class="p">(</span><span class="nx">target</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">piece</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">ID</span>

	<span class="c1">// MakeVouchers creates a set of vouchers redeemable by the target of the
</span><span class="c1"></span>	<span class="c1">// previously created payment. It creates &#39;count&#39; vouchers, each of which is
</span><span class="c1"></span>	<span class="c1">// redeemable only after an certain block height, evenly spaced out between
</span><span class="c1"></span>	<span class="c1">// start and end. Each voucher should be redeemable for proportionally more
</span><span class="c1"></span>	<span class="c1">// Filecoin, up to the total amount specified during the payment setup.
</span><span class="c1"></span>	<span class="nf">MakeVouchers</span><span class="p">(</span><span class="nx">id</span> <span class="nx">ID</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">BlockHeight</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Voucher</span>

	<span class="c1">// Redeem voucher is called by the target of a given payment to claim the
</span><span class="c1"></span>	<span class="c1">// funds represented by it. The voucher can only be redeemed after the block
</span><span class="c1"></span>	<span class="c1">// height that is attributed to the voucher, and also only if the proof given
</span><span class="c1"></span>	<span class="c1">// proves that the target is correctly storing the piece referenced in the
</span><span class="c1"></span>	<span class="c1">// payment setup.
</span><span class="c1"></span>	<span class="nf">RedeemVoucher</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Voucher</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">Proof</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>For details on the implementation of the payments system, see <a href="payments.md">the payments doc</a>.</p>

<h2 id="future-protocol-improvements">Future Protocol Improvements</h2>

<ul>
<li>Slashable Commitments

<ul>
<li>When miners initially receive the data for a deal with a client, that signed response statement can be used to slash the miner in the event that they never include that data in a sector.</li>
</ul></li>
</ul>

<h1 id="open-questions">Open questions</h1>

<ul>
<li>Storage time should likely be designated in terms of proving period. Where a proving period is the number of blocks in which every miner must submit a proof for their sectors. Not doing this makes accounting hard: &ldquo;when exactly did this sector fail?&rdquo;</li>
</ul>

<h2 id="storage-deal-make">Storage Deal Make</h2>

<ul>
<li><strong>Name</strong>: Storage Deal Make</li>
<li><strong>Protocol ID</strong>: <code>/fil/storage/mk/1.0.0</code></li>
</ul>

<blockquote>
<p>The storage deal protocol is used by any client to store data with a storage miner.</p>
</blockquote>

<p>The protocol starts with storage client (which in this case may be a normal storage client, or a broker). It is assumed that the client has their data already prepared into a <code>piece</code> prior to executing this protocol. For more details on initial data processing, see <a href="client-data.md">client data</a>.</p>

<p>First the client sends a <code>SignedStorageDealProposal</code> to the storage miner:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Commitment Bytes</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SerializationMode enum <span class="o">{</span>
     <span class="p">|</span> <span class="s2">&#34;UnixFs&#34;</span>
    <span class="c1">## no transformations applied</span>
    <span class="p">|</span> <span class="s2">&#34;Raw&#34;</span>
    <span class="c1">## Serialized as IPLD, encoding is specified in the CID stored in `pieceRef`</span>
    <span class="p">|</span> <span class="s2">&#34;IPLD&#34;</span>
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageDealProposal struct <span class="o">{</span>
	<span class="c1">## PieceRef is the hash of the data in native structure. This will be used for</span>
	<span class="c1">## certifying the data transfer.</span>
    <span class="c1">## Reference for transit.</span>
	pieceRef String

	<span class="c1">## Specifies how the graph referenced by &#39;PieceRef&#39; gets transformed</span>
	<span class="c1">## into the data that will be packed into a sector.</span>
	serializationMode SerializationMode

	<span class="c1">## The data hashed in a form that is compatible with the proofs system.</span>
    <span class="c1">## Reference for actual storage in a sector.</span>
	commP Commitment

	size BytesAmount

	totalPrice TokenAmount

	<span class="c1">## Duration is how long the file should be stored for</span>
	Duration NumBlocks

	<span class="c1">## A reference to the mechanism that the proposer will use to pay the miner. It should be</span>
    <span class="c1">## verifiable by the miner using on-chain information.</span>
	payment PaymentInfo

	<span class="c1">## MinerAddress is the address of the storage miner in the deal proposal</span>
	minerAddress Address

	clientAddress Address
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SignedStorageDealProposal struct <span class="o">{</span>
	proposal StorageDealProposal

	<span class="c1">## Signature over the the encoded StorageDealProposal signed by the client.</span>
	signature Signature
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentInfo struct <span class="o">{</span>
	<span class="c1">## The address of the payment channel actor that will be used to facilitate payments.</span>
	payChActor Address

	<span class="c1">## Reference to the message used to create the payment channel. This allows the miner to wait until the</span>
	<span class="c1">## channel is accepted on chain. (optional)</span>
	channelMessage <span class="p">&amp;</span>Message

  <span class="c1">## Set of payments from the client to the miner that can be cashed out contingent on the agreed</span>
  <span class="c1">## upon data being provably within a live sector in the miners control on-chain.</span>
	vouchers <span class="o">[</span>SignedVoucher<span class="o">]</span>
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> DealState enum <span class="o">{</span>
    <span class="c1">## Signifies an unknown negotiation.</span>
    <span class="p">|</span> Unknown <span class="m">0</span>
    <span class="c1">## The deal was rejected for some reason.</span>
    <span class="p">|</span> Rejected <span class="m">1</span>
    <span class="c1">## The deal was accepted but hasn&#39;t yet started.</span>
    <span class="p">|</span> Accepted <span class="m">2</span>
    <span class="c1">## The deal has started and the transfer is in progress.</span>
    <span class="p">|</span> Started <span class="m">3</span>
    <span class="c1">## The deal has failed for some reason.</span>
    <span class="p">|</span> Failed <span class="m">4</span>
    <span class="c1">## The data has been received and staged into a sector, but is not sealed yet.</span>
    <span class="p">|</span> Staged <span class="m">5</span>
    <span class="c1">## The data is being sealed and a `PieceInclusionProof` is available.</span>
    <span class="p">|</span> Sealing <span class="m">6</span>
    <span class="c1">## Deal is complete, and the sector that the deal is contained in has been sealed and its</span>
    <span class="c1">## commitment posted on chain.</span>
    <span class="p">|</span> Complete <span class="m">7</span>
<span class="o">}</span></code></pre></div>
<div class="notices todo" ><strong>TODO</strong>: possibly also include a starting block height here, to indicate when this deal may be started (implying you could select a value in the future). After the first response, both parties will have signed agreeing that the deal started at that point. This could possibly be used to challenge either party in the event of a stall. This starting block height also gives the miner time to seal and post the commitment on chain. Otherwise a weird condition exists where a client could immediately slash a miner for not having their data stored.</div>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageDealResponse union <span class="o">{</span>
    <span class="p">|</span> UnknownParams
    <span class="p">|</span> RejectedParams
    <span class="p">|</span> AcceptedParams
    <span class="p">|</span> StartedParams
    <span class="p">|</span> FailedParams
    <span class="p">|</span> StagedParams
    <span class="p">|</span> SealingParams
    <span class="p">|</span> CompleteParams
<span class="o">}</span> representation keyed

<span class="nb">type</span> UnknownParams struct <span class="o">{</span>
	<span class="c1">## Message is an optional message to add context to any given response</span>
	message optional String
<span class="o">}</span>

<span class="nb">type</span> RejectedParams struct <span class="o">{</span>
    message optional String

	<span class="c1">## A reference to the proposal this is the response to.</span>
    proposal <span class="p">&amp;</span>SignedStorageDealProposal
<span class="o">}</span>

<span class="nb">type</span> AcceptedParams RejectedParams
<span class="nb">type</span> FailedParams RejectedParams
<span class="nb">type</span> StagedParams RejectedParams

<span class="nb">type</span> SealingParams struct <span class="o">{</span>
	<span class="c1">## The proof needed to convince the client that the miner has sealed the data into a sector.</span>
	<span class="c1">## Note: the miner doesnt necessarily have to have committed the sector at this point</span>
	<span class="c1">## they just need to have staged it into a sector, and be committed to putting it at</span>
	<span class="c1">## that place in the sector.</span>
	pieceInclusionProof PieceInclusionProof
<span class="o">}</span>

<span class="nb">type</span> CompleteParams struct <span class="o">{</span>
	<span class="c1">## A reference to the message that was sent to submit the sector containing this data to the chain.</span>
	sectorCommitMessage <span class="p">&amp;</span>Message
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SignedStorageDealResponse struct <span class="o">{</span>
	response StorageDealResponse

	<span class="c1">## Signature is a signature from the miner over the cbor encoded response</span>
	signature Signature
<span class="o">}</span></code></pre></div>
<h3 id="process">Process</h3>

<ol>
<li>[Client] send <code>SignedStorageDealProposal</code>.</li>
<li>[Miner]  send <code>SignedStorageDealResponse</code>, either accepting or rejecting the deal.</li>
<li>[Client] If <code>response.state</code> is <code>Accepted</code> then transfer the data in question.</li>
<li>[Miner] Once the miner receives all the data they validate it. On success they set the <code>DealState</code> to <code>Staged</code> (internally).</li>
<li>[Miner] When the sector gets sealed, the state gets set to <code>Sealing</code>.</li>
<li>[Miner] When the commitment is posted on chain, the state gets set to <code>Complete</code>.</li>
<li>[Client] Once the deal makes it to the <code>Sealing</code> state, they are able to query and get the <code>PieceInclusionProof</code> that they need to verify that the miner is indeed storing their data.</li>
</ol>

<p>At any point in time the client can query (using the query protocol) the miner to get the current state of the deal.</p>

<div class="notices Note" ><strong>Note:</strong> The data transfer operation happens out of band from this protocol, and can be a simple bitswap transfer at first. Support for other more &lsquo;exotic&rsquo; &lsquo;protocols&rsquo; such as mailing hard drives is an explicit goal.</div>

<h2 id="storage-deal-query">Storage Deal Query</h2>

<ul>
<li><strong>Name</strong>: Storage Deal Query</li>
<li><strong>Protocol ID</strong>: <code>/fil/storage/qry/1.0.0</code></li>
</ul>

<p>This is the basic protocol for querying the current state of a given storage deal.
At any point, the client in this flow may query the miner for the state of a given proposal. To query, they send a <code>StorageDealQuery</code> that looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageDealQuery struct <span class="o">{</span>
	<span class="c1">## ProposalCid is the cid of the proposal for the deal that we are querying</span>
	<span class="c1">## the state of</span>
	proposal <span class="p">&amp;</span>SignedStorageDealProposal

	baseState DealState
<span class="o">}</span></code></pre></div>
<p>If <code>baseState</code> is <code>Unset</code> or a terminal state (<code>Complete</code>, <code>Rejected</code>, or <code>Failed</code>) then the current state of the deal in question is returned. If the <code>baseState</code> is different than the current state of the deal, the current state of the deal is also returned immediately. In the case that the <code>baseState</code> matches the current state of the deal, then the stream is held open until the state changes, at which point the new state of the deal is returned.</p>

<div class="notices Note" ><strong>Note:</strong> In the future we may want something more complex that is able to multiplex waiting for notifications about a large set of deals over a single stream simultaneously. Upgrading to that from this should be relatively simple, so for now, we do the simple thing.</div>

<h2 id="piece-commitment">Piece Commitment</h2>

<h3 id="commp">commP</h3>

<p>A piece commitment (<code>commP</code>) is the root hash of a piece that a client wants to store in Filecoin. It is generated using <code>RepHash</code> (as described in <a href="zigzag-porep.md">Proof-of-Replication</a>) on some raw data which has been zero-padded to a multiple of 127 bytes, then preprocessed yielding <code>Fr32 padded</code> data which is a multiple of 128 bytes.</p>

<h2 id="transfer-formats">Transfer formats</h2>

<p>The transfer format is the format to transfer a file over the network. This format SHALL be used for the initial transfer (from clients to storage miners) and for later retrievals (from storage miners to the clients).</p>

<p>The default transfer format is <code>unixfsv1</code>. Cliens MAY agree to use other formats of their preference.</p>

<h3 id="unixfsv1"><code>unixfsv1</code></h3>

<p>The default transfer format is Unixfsv1 with the following parameters:</p>

<ul>
<li>Chunking: Fixed, 1MB</li>
<li>Leaf Format: Raw</li>
<li>Max Branch Width: 1024</li>
</ul>

<p>For details on how UnixfsV1 works, see its spec <a href="https://github.com/ipfs/specs/tree/master/unixfs">here</a>.</p>

<h2 id="storage-formats">Storage Formats</h2>

<p>The Storage Format MUST be use for generating Filecoin proofs and hashing sectors data.</p>

<p>The current required storage format is <code>paddedfr32v1</code>.</p>

<h3 id="paddedfr32v1"><code>paddedfr32v1</code></h3>

<p>A correctly formatted <code>paddedfr32v1</code> data must have:</p>

<ul>
<li><strong>Fr32 Padding</strong>: Every 32 bytes blocks MUST contain two zeroes in the most significant bits (every 254 bits must be followed by 2 zeroes if interpreted as little-endian number). That is, for each block, <code>0x11000000 &amp; block[31] == 0</code>.</li>
<li><strong>Piece Padding</strong>: In order to generate minimal <code>PieceInclusionProofs</code>, blocks of 32 zero bytes MUST be added so that the total number of blocks (including <em>piece padding</em>) is a power of two. <strong>Piece Padding</strong> can be omitted if the prover wishes to generate unaligned proofs. [NOTE: not yet fully specified.]</li>
</ul>

<p><strong>Why do we need a special Storage Encoding Format?</strong> In the Filecoin proofs we do operations in an arithmetic field of size <code>p</code>, where <code>p</code> is a prime of size <code>2^255</code>, hence the size of the data blocks must be smaller than <code>p</code>. We cautiously decide to have data blocks of size 254 to avoid possible overflows (data blocks numerical representation is bigger than <code>p</code>).</p>

<h2 id="miners-claiming-earnings">Miners Claiming Earnings</h2>

<p>Storage Miners claim their Storage Market earnings via payment channels.</p>

<p>The client proposes the cadence of the earnings for a deal by creating <code>SignedVoucher</code>-s. Each vouchers specify how often Storage Miners can claim earnings and how much each earning should be, more precisely, each voucher has some tokens assigned and can be redeemed only at a particular block height. The vouchers are part of the <code>PaymentInfo</code> included in the <code>StorageDealProposal</code>. When receiving a proposal, a Storage Miner can review and accept these terms by completing the deal protocol.</p>

<p>After the block defined in each <code>SignedVoucher</code> is passed, the Storage Miner could claim the earning by updating the payment channel calling <code>UpdateChannelState</code> on the <code>PaymentChannel</code> actor for a particular <code>SignedVoucher</code>. This call passes if the Storage Miner is still storing the piece in sector and if the Storage Miner is not late in their PoSt submission and if the time specified in the <code>SignedVoucher</code> has passed.</p>

<h2 id="storage-miner-payments">Storage Miner Payments</h2>

<p>TODO: these bits were pulled out of a different doc, and describe strategies by which client payments to a miner might happen. We need to organize &lsquo;clients paying miners&rsquo; better, unclear if it should be the same doc that talks about payment channel constructions.</p>

<ol>
<li><strong>Updates Contingent on Inclusion Proof</strong>

<ul>
<li>In this case, the miner must provide an inclusion proof that shows the client data is contained in one of the miners sectors on chain, and submit that along with the payment channel update.</li>
<li>This can be pretty expensive for smaller files, and ideally, we make it to one of the latter two options</li>
<li>This option does however allow clients to upload their files and leave.</li>
</ul></li>
<li><strong>Update Contingent on CommD Existence</strong>

<ul>
<li>For this, the client needs to wait around until the miner finishes packing a sector, and computing its commD. The client then signs a set of payment channel updates that are contingent on the given commD existing on chain.</li>
<li>This route makes it difficult for miners to re-seal smaller files (really, small files just suck)</li>
</ul></li>
<li><strong>Reconciled Payment</strong>

<ul>
<li>In either of the above cases, the miner may go back to the client and say &ldquo;Look, these payment channel updates you gave me are able to be cashed in right now, could you take them all and give me back a single update for a slightly smaller amount?&rdquo;.</li>
<li>The slightly smaller amount could be the difference in transaction fees, meaning the client saves money, and the miner gets the same amount.</li>
</ul></li>
</ol>



  

  
    








<div id="listings__actors">

<h2>
  Filecoin VM Actors
</h2>

<p>TODO</p>




</div>

  

  
    








<div id="subsystems__storage__components">

<h3>
  Storage Market Components
</h3>

<p>TODO</p>



  
    








<div id="subsystems__storage__components__storage_provider">

<h4>
  Storage Provider
</h4>

<p>TODO</p>




</div>

  

  


</div>

  

  
    








<div id="subsystems__storage__libp2p">

<h3>
  libp2p Protocols
</h3>

<p>TODO</p>



  

  


</div>

  


</div>

  

  
    








<div id="subsystems__retrieval">

<h2>
  Retrieval Market
</h2>



<h2 id="components">Components</h2>

<p>Version 0 of the <code>retrieval market</code> protocol is what we (tentatively) will launch the filecoin network with. It is version zero because it will only be good enough to fit the bill as a way to pay another node for a file.</p>

<p>The main components are as follows:</p>

<ul>
<li>A payment channel actor (See <a href="payment-channels.md">payment channels</a> for details)</li>
<li>&lsquo;retrieval-v0&rsquo; <code>libp2p</code> services</li>
<li>A chain-based content routing interface</li>
<li>A set of commands to interact with the above</li>
</ul>

<h2 id="retrieval-v0-libp2p-services">Retrieval V0 <code>libp2p</code> Services</h2>

<p>The v0 <code>retrieval market</code> will initially be implemented as two <code>libp2p</code> services. It will be request response based, where the client who is requesting a file sends a <code>retrieval deal proposal</code> to the miner. The miner chooses whether or not to accept it, sends their response which (if they accept the proposal) includes a <code>signed retrieval deal</code>, followed by the actual requested content, streamed as a series of bitswap block messages, using a pre-order traversal of the dag. Each block should use the <a href="https://github.com/ipfs/go-bitswap/blob/c980d7ed36f278e93828acf920f3a911e8263265/message/message.go#L228">bitswap block message format</a>. This way, the client should be able to verify the data incrementally as it receives it. Once the client has received all the data, it should then send a payment channel SpendVoucher of the proposed amount to the miner. This protocol may be easily extended to include payments from the client to the miner every N blocks, but for now we omit that feature.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> RetDealProposal struct <span class="o">{</span>
	<span class="c1">## Reference to the data being retrieved.</span>
	ref Link

	<span class="c1">## The total amount that the client is willing to pay for the retrieval of the data.</span>
	price TokenAmount

	<span class="c1">## The info from the client to the retrieval miner for the data</span>
	payment PaymentInfo
<span class="o">}</span>

<span class="nb">type</span> RetDealResponse union <span class="o">{</span>
    <span class="p">|</span> AcceptedResponse <span class="m">0</span>
    <span class="p">|</span> RejectedResponse <span class="m">1</span>
    <span class="p">|</span> ErrorResponse <span class="m">2</span>
<span class="o">}</span> representation keyed

<span class="nb">type</span> AcceptedResponse struct <span class="o">{}</span>
<span class="nb">type</span> RejectedResponse struct <span class="o">{</span>
    message optional String
<span class="o">}</span>

<span class="nb">type</span> ErrorResponse RejectedResponse

<span class="nb">type</span> Block struct <span class="o">{</span>
	<span class="c1">## Cid prefix parameters for this block. It describes how to</span>
	<span class="c1">## hash the block to verify it matches the expected value.</span>
	refix CidPrefix
	data Bytes
<span class="o">}</span>

<span class="c1">## Represents all the metadata of a Cid.</span>
<span class="c1">## It does not contains  any actual content information.</span>
<span class="nb">type</span> CidPrefix struct <span class="o">{</span>
	version  UInt
	codec    UInt
	mhType   UInt
	mhLength UInt
<span class="o">}</span></code></pre></div>
<p><code>Retrieval miners</code> should also support a query service that allows clients to request pricing information from a miner.</p>

<p>The query should include the CID of the piece that the client is interested in retrieving. The response contains whether or not the miner will serve that data, the price they will accept for it.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> RetQuery struct <span class="o">{</span>
    <span class="c1">## TODO: what exactly does this link to?</span>
	piece Link
<span class="o">}</span>

<span class="nb">type</span> RetQueryResponse union <span class="o">{</span>
    <span class="p">|</span> AvailableResponse
    <span class="p">|</span> UnavailableResponse
<span class="o">}</span> representation keyed

<span class="nb">type</span> AvailableResponse struct <span class="o">{</span>
	minPrice TokenAmount
<span class="o">}</span>

<span class="nb">type</span> UnavailableResponse struct <span class="o">{}</span></code></pre></div>
<h2 id="chain-based-content-routing">Chain Based Content Routing</h2>

<p>For the version 0 protocol. We should implement a small helper service that looks up which miners have a given piece based on deals made in the blockchain. The service should first look the content up in the blockchain (or in some client index) to find the chain address of the miner, then use the lookup service to map that to a <code>libp2p</code> <code>peerID</code> and <code>multiaddr</code>.</p>

<p>The interface should match the exist libp2p content routing interface:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ChainContentRouting</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">FindProvidersAsync</span><span class="p">(</span><span class="nx">ref</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">pstore</span><span class="p">.</span><span class="nx">PeerInfo</span>
<span class="p">}</span></code></pre></div>
<h2 id="retrieval-market-commands">Retrieval Market Commands</h2>

<p>We will need to add a few commands to allow the user to interact with the <code>retrieval market</code>, and for developers to be able to script higher level applications on top of it.</p>

<p>The command names here are not final, and are definitely subject to change later on once we are able to sit and think through proper UX.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">USAGE
  filecoin retr get &lt;piece-cid&gt; - Retrieve a piece from a miner.

SYNOPSIS
  filecoin retr get [--price=&lt;amt&gt;] [--miner=&lt;peerID&gt;] [--] &lt;piece-cid&gt;

ARGUMENTS

  &lt;piece-cid&gt; - Content ID of piece to retrieve.

OPTIONS

  --price                string - Amount of filecoin to offer for this data.
  --miner                string - Optional Peer ID of miner to connect to. (If unspecified, the chain routing service will be used)</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">USAGE
  filecoin retr lookup &lt;piece-cid&gt; - Print a list of miners who have the given piece.

SYNOPSIS
  filecoin retr lookup [--sort=&lt;sorttype&gt;] [--] &lt;piece-cid&gt;

ARGUMENTS

  &lt;piece-cid&gt;... - Content ID of piece to find.

OPTIONS

  --sort                string - Output sorting scheme.</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">USAGE
  filecoin retr query &lt;minerID&gt; [&lt;piece-cid&gt;] - Query the given retrieval miner.

SYNOPSIS
  filecoin retr query [--] &lt;miner-id&gt; [&lt;piece-cid&gt;]

ARGUMENTS

  &lt;miner-id&gt;  - ID of miner to query.
  [&lt;piece-cid&gt;] - Optional cid of piece to query for.</code></pre></div>
<h2 id="retrieve-piece-for-free">Retrieve Piece for Free</h2>

<ul>
<li><strong>Name</strong>: Retrieve Piece for Free</li>
<li><strong>Protocol ID</strong>: <code>/fil/retrieval/free/0.0.0</code></li>
</ul>

<blockquote>
<p>The Retrieve Piece for Free protocol is used to coordinate the transfer of a piece from miner to client at no cost to the client.</p>
</blockquote>

<p>The client initiates the protocol by opening a libp2p stream to the miner. To find and connect to the miner, the <a href="lookup-service.md">address lookup service</a> should be used. Once connected, the client must send the miner a <code>RetrievePieceRequest</code> message.</p>

<p>When the miner receives the request, it responds with a <code>RetrievePieceResponse</code> message indicating that it has accepted or rejected the request.</p>

<p>If the miner does not accept the request, it sends a <code>RetrievePieceResponseFailure</code>, with the <code>message</code> field set to indicate a reason for the request being rejected.</p>

<p>If the miner accepts the request, it sends a <code>RetrievePieceResponseSuccess</code>. Then the miner sends the client ordered <code>RetrievePieceChunk</code> messages until all of the piece&rsquo;s data has been transferred, at which point the miner closes the stream.</p>

<p>Note: The client must be able to reconstruct a piece by concatenating the <code>Data</code>-bytes in the order that they were received.</p>

<p>Note: The miner divides the piece in to chunks containing a maximum of <code>256 &lt;&lt; 8</code> bytes due to a limitation in our software which caps the size of CBOR-encoded messages at <code>256 &lt;&lt; 10</code> bytes.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> RetrievePieceRequest struct <span class="o">{</span>
	<span class="c1">## Identifier of user data, typically received from the client while consummating a storage deal.</span>
	pieceRef String
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> RetrievePieceResponse union <span class="o">{</span>
    <span class="c1">## Success means that the piece can be retrieved from the miner.</span>
    <span class="p">|</span> RetrievePieceResponseSuccess <span class="m">0</span>
	<span class="c1">## Failure indicates that the piece can not be retrieved from the miner.</span>
    <span class="p">|</span> RetrievePieceResponseFailure <span class="m">1</span>
<span class="o">}</span> representation keyed

<span class="nb">type</span> RetrievePieceResponseSuccess struct <span class="o">{}</span>

<span class="nb">type</span> RetrievePieceResponseFailure struct <span class="o">{</span>
	<span class="c1">## A string explaining the cause for the rejection.</span>
	message string
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">##  A chunk of a piece. The length must be &gt; 0.</span>
<span class="nb">type</span> RetrievePieceChunk Bytes</code></pre></div>


  

  
    








<div id="listings__actors">

<h2>
  Filecoin VM Actors
</h2>

<p>TODO</p>




</div>

  

  
    








<div id="subsystems__retrieval__components">

<h3>
  Retrieval Market Components
</h3>

<p>TODO</p>



  

  


</div>

  


</div>

  

  
    








<div id="subsystems__mining">

<h2>
  Storage Mining
</h2>




  
    








<div id="subsystems__mining__actors">

<h3>
  Storage Mining Actors
</h3>

<p>TODO</p>



  


</div>

  

  
    








<div id="subsystems__mining__components">

<h3>
  Storage Mining Components
</h3>

<p>TODO</p>



  

  

  
    








<div id="subsystems__mining__components__proof_generator">

<h4>
  Proof Generator
</h4>



<p>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning <code>ticket</code> to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.</p>

<h2 id="the-miner-actor">The Miner Actor</h2>

<p>After successfully calling <code>CreateStorageMiner</code>, a miner actor will be created on-chain, and registered in the storage market. This miner, like all other Filecoin State Machine actors, has a fixed set of methods that can be used to interact with or control it.</p>

<p>For details on the methods on the miner actor, see its entry in the <a href="actors.md#storage-miner-actor">actors spec</a>.</p>

<h3 id="owner-worker-distinction">Owner Worker distinction</h3>

<p>The miner actor has two distinct &lsquo;controller&rsquo; addresses. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a &lsquo;hot wallet&rsquo; key.</p>

<h3 id="storage-mining-cycle">Storage Mining Cycle</h3>

<p>Storage miners must continually produce Proofs of SpaceTime over their storage to convince the network that they are actually storing the sectors that they have committed to. Each PoSt covers a miner&rsquo;s entire storage.</p>

<h4 id="step-0-registration">Step 0: Registration</h4>

<p>To initially become a miner, a miner first register a new miner actor on-chain. This is done through the storage market actor&rsquo;s <a href="actors.md#createstorageminer"><code>CreateStorageMiner</code></a> method. The call will then create a new miner actor instance and return its address.</p>

<p>The next step is to place one or more storage market asks on the market. This is done through the storage markets <a href="actors.md#addask"><code>AddAsk</code></a> method. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p>

<p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the section on <a href="storage-market.md#deal">deal</a>.</p>

<p>When they have a full sector, they should seal it. This is done by invoking <a href="proofs.md#seal"><code>PoRep.Seal</code></a> on the sector.</p>

<h4 id="step-1-commit">Step 1: Commit</h4>

<p>When the miner has completed their first seal, they should post it on-chain using <a href="actors.md#commitsector">CommitSector</a>. If the miner had zero committed sectors prior to this call, this begins their proving period.</p>

<p>The proving period is a fixed amount of time in which the miner must submit a Proof of Space Time to the network.</p>

<p>During this period, the miner may also commit to new sectors, but they will not be included in proofs of space time until the next proving period starts.
For example, if a miner currently PoSts for 10 sectors, and commits to 20 more sectors. The next PoSt they submit (i.e. the one they&rsquo;re currently proving) will be for 10 sectors again, the subsequent one will be for 30.</p>

<p>TODO: sectors need to be globally unique. This can be done either by having the seal proof prove the sector is unique to this miner in some way, or by having a giant global map on-chain is checked against on each submission. As the system moves towards sector aggregation, the latter option will become unworkable, so more thought needs to go into how that proof statement could work.</p>

<h4 id="step-2-proving-storage-post-creation">Step 2: Proving Storage (PoSt creation)</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ProveStorage</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">commR</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="nx">challengeBlockHeight</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span>

    <span class="c1">// Faults to be used are the currentFaultSet for the miner.
</span><span class="c1"></span>    <span class="nx">faults</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">currentFaultSet</span>
    <span class="nx">seed</span> <span class="o">:=</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">challengeBlockHeight</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sectors</span><span class="p">,</span> <span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Note: See <a href="proof-of-spacetime.md">&lsquo;Proof of Space Time&rsquo;</a> for more details.</p>

<p>The proving set remains consistent during the proving period. Any sectors added in the meantime will be included in the next proving set, at the beginning of the next proving period.</p>

<h4 id="step-3-post-submission">Step 3: PoSt Submission</h4>

<p>When the miner has completed their PoSt, they must submit it to the network by calling <a href="actors.md#submitpost">SubmitPoSt</a>. There are two different times that this <em>could</em> be done.</p>

<ol>
<li><strong>Standard Submission</strong>: A standard submission is one that makes it on-chain before the end of the proving period. The length of time it takes to compute the PoSts is set such that there is a grace period between then and the actual end of the proving period, so that the effects of network congestion on typical miner actions is minimized.</li>
<li><strong>Penalized Submission</strong>: A penalized submission is one that makes it on-chain after the end of the proving period, but before the generation attack threshold. These submissions count as valid PoSt submissions, but the miner must pay a penalty for their late submission. (See &lsquo;<a href="faults.md">Faults</a>&rsquo; for more information)

<ul>
<li>Note: In this case, the next PoSt should still be started at the beginning of the proving period, even if the current one is not yet complete. Miners must submit one PoSt per proving period.</li>
</ul></li>
</ol>

<p>Along with the PoSt submission, miners may also submit a set of sectors that they wish to remove from their proving set. This is done by selecting the sectors in the &lsquo;done&rsquo; bitfield passed to <code>SubmitPoSt</code>.</p>

<h3 id="stop-mining">Stop Mining</h3>

<p>In order to stop mining, a miner must complete all of its storage contracts, and remove them from their proving set during a PoSt submission. A miner may then call <a href="actors.md#depledge"><code>DePledge()</code></a> to retrieve their collateral. <code>DePledge</code> must be called twice, once to start the cooldown, and once again after the cooldown to reclaim the funds. The cooldown period is to allow clients whose files have been dropped by a miner to slash them before they get their money back and get away with it.</p>

<h3 id="faults">Faults</h3>

<p>Faults are described in the <a href="faults.md">faults document</a>.</p>

<h3 id="on-being-slashed-wip-needs-discussion">On Being Slashed (WIP, needs discussion)</h3>

<p>If a miner is slashed for failing to submit their PoSt on time, they currently lose all their pledge collateral. They do not necessarily lose their storage collateral. Storage collateral is lost when a miner&rsquo;s clients slash them for no longer having the data. Missing a PoSt does not necessarily imply that a miner no longer has the data. There should be an additional timeout here where the miner can submit a PoSt, along with &lsquo;refilling&rsquo; their pledge collateral. If a miner does this, they can continue mining, their mining power will be reinstated, and clients can be assured that their data is still there.</p>

<p>TODO: disambiguate the two collaterals across the entire spec</p>

<p>Review Discussion Note: Taking all of a miners collateral for going over the deadline for PoSt submission is really really painful, and is likely to dissuade people from even mining filecoin in the first place (If my internet going out could cause me to lose a very large amount of money, that leads to some pretty hard decisions around profitability). One potential strategy could be to only penalize miners for the amount of sectors they could have generated in that timeframe.</p>

<h3 id="future-work">Future Work</h3>

<p>There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future.</p>

<ul>
<li><strong>Sector Resealing</strong>: Miners should be able to &rsquo;re-seal&rsquo; sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not-yet-expired pieces into a single (or multiple) sectors.</li>
<li><strong>Sector Transfer</strong>: Miners should be able to re-delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road.</li>
</ul>




</div>

  


</div>

  


</div>

  

  
    








<div id="subsystems__network">

<h2>
  Network Interface
</h2>



<h2 id="message-transport">Message Transport</h2>

<p>Filecoin uses <a href="https://libp2p.io">libp2p</a> for all network communications. libp2p provides transport-agnostic services for peer discovery, naming, routing, pubsub channels and a distributed record store, and there are full or partial <a href="https://libp2p.io/implementations/">implementations</a> in a number of languages. This spec assumes the use of libp2p and its services and does not specify transport-level details. That said, to be at least minimally compatible with other Filecoin nodes, it must support at least the <a href="https://github.com/libp2p/specs/tree/master/mplex">mplex</a> stream multiplexer, and the <a href="TODO, spec in PR">secio</a> encrypted transport protocols. For more details on the exact wire protocol of libp2p, refer to the <a href="https://github.com/libp2p/specs">libp2p specs</a>.</p>

<p>Filecoin uses <a href="https://ipld.io">IPLD</a> for the representation and serialization of the majority of the data in the system. IPLD provides a canonical model for content-addressed data structures, providing a representation of basic data objects and links between them.</p>

<p>All filecoin network protocols are implemented as libp2p protocols. This document will assume that all data is communicated between peers on a libp2p stream.</p>

<h2 id="ipld-dag-cbor-rpc">Ipld dag-cbor RPC</h2>

<p>Filecoin uses many pre-existing protocols from ipfs and libp2p, and also implements several new protocols of its own. For these Filecoin specific protocols, we will use the Ipld dag-cbor RPC protocol format, defined below.</p>

<p>This format consists of series of IPLD objects, serialized using <code>dag-cbor</code>. Whenever a filecoin protocol says &ldquo;send X&rdquo;, it means &ldquo;IPLD serialize the object X using <code>dag-cbor</code>, then write the serialized bytes&rdquo;.</p>

<div class="notices Note" ><strong>Note:</strong> Implementations should limit the maximum number of bytes when reading IPLD objects from the wire. We suggest <code>1MB</code> as a sane limit.</div>

<p><strong>Links</strong></p>

<ul>
<li>Ipld: <a href="https://github.com/ipld/specs/">https://github.com/ipld/specs/</a></li>
<li>dag-cbor: <a href="https://github.com/ipld/specs/blob/master/block-layer/codecs/DAG-CBOR.md">https://github.com/ipld/specs/blob/master/block-layer/codecs/DAG-CBOR.md</a></li>
</ul>

<h2 id="required-protocols">Required Protocols</h2>

<p>Every full node must support the following libp2p protocols:</p>

<ul>
<li><a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">gossipsub</a> (<a href="data-propagation.md">for data announcements</a>)</li>
<li><a href="[for data exchange](data-propagation.md)">bitswap</a></li>
<li>Filecoin specific Protocols:

<ul>
<li>Hello Handshake</li>
<li>StorageDeal</li>
<li>BlockSync</li>
</ul></li>
</ul>

<h2 id="transports-streams-encryption">Transports, Streams &amp; Encryption</h2>

<p>Connections between nodes are end-to-end-encrypted and -authenticated, thus every node has a <code>peerId</code> associated with it.</p>

<p>Filecoin protocols are run as multiple streams over a single connection. Only one connection should exist between two nodes at any time, multiple streams within that connections must be used to exchange different protocols. This is usually handled from within the libp2p stack if configured properly.</p>

<p>This document doesn&rsquo;t make any assumptions on which transports and multiplexing features a particular node offers, however it must at least be able to respond and communicate through mplex channels via a secio transport.</p>

<div class="notices info" >Implementers are encouraged to offer and experiment with more protocols and transports, as long as the above mentioned requirements of ee2e, authentication and muxing are still met. In particular the authors encourage to look into TLS1.3 and QUIC as libp2p protocol/transport layers.</div>

<h3 id="establishing-connections">Establishing connections</h3>

<p>When a Filecoin node connects to the network, it may connect to multiple nodes at once. When a new node connects, it must be greeted with the <code>HelloMessage</code> through the hello-handshake protocol first. Only after that message has been sent can other streams be opened. If a node receives a <code>HelloMessage</code> with a GenesisBlock it doesn&rsquo;t support, it must immediately close the entire connection to that peer.</p>

<p>If the node learns through that handshake about newer blocks it should use that new information to sync up their chain.</p>

<h3 id="syncing">Syncing</h3>

<p>Whenever a node learns about a new <code>BlockHead</code> it should attempt to import the block - let that be through the <code>HelloMessage</code> or through the <a href="data-propagation.md#block-propagation">block pubsub protocol</a>. For that it may fetch the ancestors of that block through bitswap until it is fully caught up. Importing in this context refers to the node confirming that the block is valid, as described in <a href="validation.md">Validation</a> and storing it locally. This mode is known as &ldquo;syncing&rdquo;. During &ldquo;syncing&rdquo; the same node may not mine blocks.</p>

<h2 id="establishing-a-network">Establishing a network</h2>

<p>Every node should aim to establish a set of stable connections to the network in order to stay up to date with latest changes and block propagation - aka to sync - as well as to participate in the processes of the network - e.g. mining.</p>

<p>In order to do that a node must be &ldquo;bootstrapped&rdquo; when starting up. At its simplest, bootstrapping can be thought of as secure network joining. It must enable a new node to get the latest head/chain that the majority of the network power is mining off and must be both:</p>

<ul>
<li>Robust — able to do so in adversarial networks (so long as honest nodes make up the majority of the network).</li>
<li>Consistent — able to reliably get the canonical chain (even given poor latency or state loss in our initial peer set).</li>
</ul>

<p>The specific bootstrapping method and heuristic - or a mix of them - is left up to the node implementation, but we provide some example ideas of how this could be done and what aspects should be taken into consideration for that, such as relying on both new nodes and new connections to ensure a node is connected to both a reliable and representative slice of the network</p>

<h3 id="trusted-bootnodes">Trusted bootnodes</h3>

<p>As with many other networks, trusted entities - e.g. the Filecoin foundation, large exchanges, good actors in the community, etc - might publish a set of bootnodes one can connect to in order to establish network connections.</p>

<p>Keep in mind that, because these could easily be DoS&rsquo;ed, a) large set of different entities should be pre-shipped but only a few should be tried at a time b) they might drop connections rather quickly after establishing (and ban that peer for a short period of time) in order to serve more nodes. Thus you want to make sure to send a discovery request to learn about more peers over the bootnodes to have nodes to connect to.</p>

<p>A node should not attempt to connect to more than 10 bootnodes at a time. And should diversify its set of nodes as quickly as possible.</p>

<h3 id="previously-known-nodes">Previously known nodes</h3>

<p>It is generally preferred that an implementation keeps permanent track of reliable peers and attempts to connect to them upon restart. This can be a simple list of previously established connections or the blow listed ranked reputation list.</p>

<h3 id="peer-discovery-requests">Peer Discovery requests</h3>

<p>At this point the specification does not decide upon any particular peer discovery mechanism but leaves this up for the implementations to decide which ones they want to provide. However, the expectation is that all boot nodes provide some form peer discovery mechanism and publish that information along side the connectivity information. Whether that be BRAHMS or through RandomQueries of KADEMLIA-DHT, any node bootstrapping itself, should attempt to establish streams for peer discovery and may not fail just because their peer declines the given protocol stream.</p>

<p>On the other side, the attempt to establish an unsupported peer-discovery protocol must not - in and of itself - lead to a disconnect, as multiple protocols might be tried. Any protocol may only be tried once on the same connection however.</p>

<h2 id="maintaining-a-stable-network">Maintaining a stable network</h2>

<p>Many aspects of the network topology assume some degree of liveness for filecoin to work. Thus and for it to work most efficiently, we aim for an overall stable network, that still allows for new nodes to join the network without interrupting.</p>

<p>In order to achieve that every node should aim for &ldquo;future usefulness of peers&rdquo; as outline below. However, as a general rule, if a node acts in violation of a <code>must</code> rule, any peer aware of that is totally in their right to drop any connection to the node without further warning. It may also keep a record of these offenses ban the peer from connecting again, if it finds them to continue offending. Such ban may be imposed upon - in increasing order - the peerId, on the IP+Port or finally the IP itself. One must keep in mind that IP addresses still rotate and thus every implementation must add a maximum timeout should they impose a ban on them, while PeerIDs can also be banned indefinitely.</p>

<h3 id="optimise-for-usefulness-of-peers">Optimise for usefulness of peers</h3>

<p>A more sophisticated system to manage a healthy peer set is through optimising for usefulness of that peer to the node. in this system a node tracks all incoming messages and their costs in relation to the value it provided to them and records them as value any particular node provides to it - called &ldquo;reputation&rdquo;. These calculations may also take into account time that passed or whether the other node would have to know about the uselessness of a particular message. Sending a useless message, in this system, is not understood as a hard violation, but as impolite behaviour and can be recorded as such. Thus creating a ranking by usefulness among the peer set.</p>

<p>An example would be that, continuously receive a pubsub message from a node after we&rsquo;ve forwarded it to them prior. This isn&rsquo;t a hard failure, as though they aren&rsquo;t supposed to do that, we can&rsquo;t know if that is because of a faulty implementation or because of network delays queuing their message. However, we&rsquo;d still note this as impolite and for every time this happens deduct from their reputation as it isn&rsquo;t useful to us.</p>

<p>A node attempts to always hold a certain amount of connections (&ldquo;slots&rdquo;) to the network &ndash; we recommend 25-50 on an on-the-shelf system. Whenever a new node connects, it can check their previously stored reputation or assign a default value and if that reputation is higher than the lowest currently connected nodes, may replace that connection (and thus drop the lowest quality connection) or otherwise refuse to take that connection.</p>

<p>In this system a node might also only record a strong decrease in reputation but not drop a connection to a peer directly even upon a strong violation, because the node may still be more useful than others. It is better to stay connected to a crappy network than to no network. However, this doesn&rsquo;t not free the node from still adhering to the spec itself - it should not forward said violation or its connection might still be righteously dropped.</p>

<p>We also recommend to regularly check the ranking and drop and clear up the lowest 10% of slots, leaving 5% open for incoming connections and fill up the other 5% by connecting to other nodes it can find through peer discovery.</p>

<p>All this to create a local view of for that node most useful connections to the network. The reputation may be stored permanently and be available between restarts - thus providing a neat bootstrap start list, too.</p>

<h2 id="hello-handshake">Hello Handshake</h2>

<ul>
<li><strong>Name</strong>: Hello</li>
<li><strong>Protocol ID</strong>: <code>/fil/hello/1.0.0</code></li>
</ul>

<blockquote>
<p>The Hello protocol is used when two filecoin nodes initially connect to each other in order to determine information about the other node.</p>
</blockquote>

<p>Whenever a node gets a new connection, it opens a new stream on that connection and &ldquo;says hello&rdquo;. This is done by crafting a <code>HelloMessage</code>, sending it to the other peer using CBOR RPC and finally, closing the stream.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> HelloMessage struct <span class="o">{</span>
	heaviestTipSet <span class="o">[</span><span class="p">&amp;</span>Block<span class="o">]</span>
	heaviestTipSetWeight UInt
	genesisHash <span class="p">&amp;</span>Block
<span class="o">}</span></code></pre></div>
<p>Upon receiving a &ldquo;hello&rdquo; stream from another node, you should read off the CBOR RPC message, and then check that the genesis hash matches you genesis hash. If it does not, that node is not part of your network, and should probably be disconnected from. Next, the <code>HeaviestTipSet</code>, claimed <code>HeaviestTipSetWeight</code>, and peerID of the other node should be passed to the chain sync subsystem.</p>



  

  

  

  

  

  


</div>

  

  
    








<div id="subsystems__repository">

<h2>
  Repository (persistent storage)
</h2>

<p>TODO</p>



  

  

  

  


</div>

  


</div>


  
    
    








<div id="listings">

<h1>
  Listings
</h1>




  
    








<div id="listings__actors">

<h2>
  Filecoin VM Actors
</h2>

<p>TODO</p>




</div>

  

  
    








<div id="listings__data_structures">

<h2>
  Data Structures
</h2>

<div id="listings__data_structures__address"></div><h3>Address</h3>

<p>An address is an identifier that refers to an actor in the Filecoin state. All <a href="actors.md">actors</a> (miner actors, the storage market actor, account actors) have an address. An address encodes information about:</p>

<ul>
<li>Network this address belongs to</li>
<li>Type of data the address contains</li>
<li>The data itself</li>
<li>Checksum (depending on the type of address)</li>
</ul>

<p>For more detail, see the full <a href="./#appendix__address">address spec</a>.</p>

<div id="listings__data_structures__block"></div><h3>Block</h3>

<p>A block header contains information relevant to a particular point in time over which the network may achieve consensus. The block header contains:</p>

<ul>
<li>The address of the miner that mined the block</li>
<li>An array of the tickets that led to this particular miner being selected as the leader for this round (see
<a href="./#algorithms__expected_consensus__secret_leader_election">Secret Leader Election</a> for more details), as well as a signature on the winning ticket</li>
<li>The set of parent blocks and aggregate <a href="./#algorithms__expected_consensus__chain_weighting">chain weight</a> of the parents</li>
<li>This block&rsquo;s height</li>
<li>Merkle root of the state tree (after applying the messages &ndash; state transitions &ndash; included in this block)</li>
<li>Merkle root of the messages (state transitions) in this block</li>
<li>Merkle root of the message receipts in this block</li>
<li>Timestamp</li>
</ul>

<div class="notices note" ><strong>Note:</strong> A block is functionally the same as a block header in the Filecoin protocol. While a block header contains Merkle links to the full system state, messages, and message receipts, a block can be thought of as the full set of this information (not just the Merkle roots, but rather the full data of the state tree, message tree, receipts tree, etc.). Because a full block is quite large, our chain consists of block headers rather than full blocks. We often use the terms <code>block</code> and <code>block header</code> interchangeably.</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Miner is the address of the miner actor that mined this block.
</span><span class="c1"></span>    <span class="nx">miner</span> <span class="nx">Address</span>

    <span class="c1">// Tickets is a chain (possibly singleton) of tickets ending with a winning ticket
</span><span class="c1"></span>    <span class="c1">// submitted with this block.
</span><span class="c1"></span>    <span class="nx">tickets</span> <span class="p">[</span><span class="nx">Ticket</span><span class="p">]</span>

    <span class="c1">// ElectionProof is generated from a past ticket and proves this miner is a leader
</span><span class="c1"></span>    <span class="c1">// in this block&#39;s round.
</span><span class="c1"></span>    <span class="nx">electionProof</span> <span class="nx">ElectionProof</span>

    <span class="c1">// Parents is an array of distinct CIDs of parents on which this block was based.
</span><span class="c1"></span>    <span class="c1">// Typically one, but can be several in the case where there were multiple winning
</span><span class="c1"></span>    <span class="c1">// ticket-holders for a given round. The order of parent CIDs is not defined.
</span><span class="c1"></span>    <span class="nx">parents</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>

    <span class="c1">// ParentWeight is the aggregate chain weight of the parent set.
</span><span class="c1"></span>    <span class="nx">parentWeight</span> <span class="nx">UInt</span>

    <span class="c1">// Height is the chain height of this block.
</span><span class="c1"></span>    <span class="nx">height</span> <span class="nx">UInt</span>

    <span class="c1">// StateRoot is a CID pointer to the VM state tree after application of the state
</span><span class="c1"></span>    <span class="c1">// transitions corresponding to this block&#39;s messages.
</span><span class="c1"></span>    <span class="nx">stateRoot</span> <span class="o">&amp;</span><span class="nx">StateTree</span>

    <span class="c1">// Messages is the set of messages included in this block. This field is the CID
</span><span class="c1"></span>    <span class="c1">// of the TxMeta object that contains the bls and secpk signed message trees.
</span><span class="c1"></span>    <span class="nx">messages</span> <span class="o">&amp;</span><span class="nx">TxMeta</span>

    <span class="c1">// BLSAggregate is an aggregated BLS signature for all the messages in this block
</span><span class="c1"></span>    <span class="c1">// that were signed using BLS signatures.
</span><span class="c1"></span>    <span class="nx">blsAggregate</span> <span class="nx">Signature</span>

    <span class="c1">// MessageReceipts is a set of receipts matching to the sending of the `Messages`.
</span><span class="c1"></span>    <span class="c1">// This field is the CID of the root of a sharray of MessageReceipts.
</span><span class="c1"></span>    <span class="nx">messageReceipts</span> <span class="o">&amp;</span><span class="p">[</span><span class="nx">MessageReceipt</span><span class="p">]</span>

    <span class="c1">// The block Timestamp is used to enforce a form of block delay by honest miners.
</span><span class="c1"></span>    <span class="c1">// Unix time UTC timestamp (in seconds) stored as an unsigned integer.
</span><span class="c1"></span>    <span class="nx">timestamp</span> <span class="nx">Timestamp</span>

    <span class="c1">// BlockSig is a signature over the hash of the entire block with the miners
</span><span class="c1"></span>    <span class="c1">// worker key to ensure that it is not tampered with after creation
</span><span class="c1"></span>    <span class="nx">blockSig</span> <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TxMeta</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">blsMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">Message</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
    <span class="nx">secpkMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">SignedMessage</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<div id="listings__data_structures__tipset"></div><h3>TipSet</h3>

<p>For more on TipSets, see <a href="expected-consensus.md#tipsets">the Expected Consensus spec</a>. Implementations may choose not to create a TipSet data structure, instead representing its operations in terms of the underlying blocks.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TipSet</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>
</code></pre></div>
  
</div>


<div id="listings__data_structures__vrf_personalization"></div><h3>VRF Personalization</h3>

<p>We define VRF personalizations as follow, to enable domain separation across operations that make use of the same VRF (e.g. <code>Ticket</code> and
<code>ElectionProof</code>).</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Prefix</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ticket</td>
<td><code>0x01</code></td>
</tr>

<tr>
<td>ElectionProof</td>
<td><code>0x02</code></td>
</tr>
</tbody>
</table>

<div id="listings__data_structures__ticket"></div><h3>Ticket</h3>

<p>A ticket contains a shared random value referenced by a particular <code>Block</code> in the Filecoin blockchain.
Every miner must produce a new <code>Ticket</code> each time they run a leader election attempt.
In that sense, every new block produced will have one or more associated tickets
(specifically, the block may contain more than one ticket if it corresponds to
one or more zero-winner epochs of <a href="./#algorithms__expected_consensus">Expected Consensus</a>).</p>

<p>To produce the ticket values,
we use an <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">EC-VRF per Goldberg et al.</a>
with Secp256k1 and SHA-256 to obtain a deterministic, pseudorandom output.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Ticket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The VRFProof (pi_string in the RFC) is generated by running our VRF on a past ticket
</span><span class="c1"></span>    <span class="c1">// in the ticket chain signed with the miner&#39;s keypair. This field is 97 bytes long
</span><span class="c1"></span>    <span class="c1">// (may be compressible to 80).
</span><span class="c1"></span>    <span class="nx">VRFProof</span> <span class="nx">Bytes</span>

    <span class="c1">// The VDFResult is derived from the VRFResult of the ticket. It is the value that
</span><span class="c1"></span>    <span class="c1">// will be used to generate future tickets or ElectionProofs.
</span><span class="c1"></span>    <span class="nx">VDFResult</span> <span class="nx">Bytes</span>

    <span class="c1">// The VDF proves a delay between tickets generated.
</span><span class="c1"></span>    <span class="nx">VDFProof</span> <span class="nx">Bytes</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>


<h4>Ticket Comparison</h4>

<p>The ticket is represented concretely by the <code>Ticket</code> data structure.
Whenever the Filecoin protocol refers to ticket values
(notably in crafting <a href="./#algorithms__proof_of_spacetime">PoSTs</a> or running leader election),
what is meant is that the bytes of the <code>VDFResult</code> field in the <code>Ticket</code> struct are used.
Specifically, tickets are compared lexicographically,
interpreting the bytes of the <code>VDFResult</code> as an unsigned integer value (little-endian).</p>

<div id="listings__data_structures__electionproof"></div><h3>ElectionProof</h3>

<p>An election proof is generated from a past ticket (chosen based on public network parameters)
by a miner during the leader election process.
Its output value determines whether the miner is elected as one of the leaders,
and hence is eligible to produce a block for the current epoch.
The inclusion of the <code>ElectionProof</code> in the block allows other network participants
to verify that the block was mined by a valid leader.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ElectionProof</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The VRFProof is generated by running our VRF on a past ticket in the ticket chain
</span><span class="c1"></span>    <span class="c1">// signed with the miner&#39;s keypair. This field is 97 bytes long (may be compressible
</span><span class="c1"></span>    <span class="c1">// to 80).
</span><span class="c1"></span>    <span class="nx">VRFProof</span> <span class="nx">Bytes</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<div id="listings__data_structures__message"></div><h3>Message</h3>

<p><code>Message</code> data structures in Filecoin describe operations that can be performed on the Filecoin VM state
(e.g., FIL transactions between accounts).
To facilitate the process of producing secure protocol implementations,
we explicitly distinguish between
<a href="./#algorithms__crypto__signatures">signed and unsigned</a> <code>Message</code> structures.</p>

<p><div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Message</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">UnsignedMessage</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">SignedMessage</span> <span class="mi">1</span>
<span class="p">}</span> <span class="c1">// representation keyed
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnsignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">to</span> <span class="nx">Address</span>
    <span class="nx">from</span> <span class="nx">Address</span>

    <span class="c1">// When receiving a message from a user account the nonce in the message must match
</span><span class="c1"></span>    <span class="c1">// the expected nonce in the &#34;from&#34; actor. This prevents replay attacks.
</span><span class="c1"></span>    <span class="nx">nonce</span> <span class="nx">UInt</span>
    <span class="nx">value</span> <span class="nx">UInt</span>

    <span class="nx">gasPrice</span> <span class="nx">UInt</span>
    <span class="nx">gasLimit</span> <span class="nx">UInt</span>

    <span class="nx">method</span> <span class="nx">Uint</span>
    <span class="nx">params</span> <span class="nx">Bytes</span>  <span class="c1">// Serialized parameters to the method.
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">message</span>   <span class="nx">UnsignedMessage</span>
    <span class="nx">signature</span> <span class="nx">Signature</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MessageReceipt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">exitCode</span> <span class="nx">UInt</span>
    <span class="nx">returnValue</span> <span class="nx">Bytes</span>
    <span class="nx">gasUsed</span> <span class="nx">UInt</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>
</p>

<div id="listings__data_structures__state_tree"></div><h3>State Tree</h3>

<p>The state tree keeps track of the entire state of the <a href="./#subsystems__vm___index"></a> at any given point.
It is a map from <code>Address</code> structures to <code>Actor</code> structures, where each <code>Actor</code>
may also contain some additional <code>ActorState</code> that is specific to a given actor
type.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StateTree</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Address</span><span class="p">]</span><span class="nx">Actor</span>
</code></pre></div>
  
</div>


<div id="listings__data_structures__actor"></div><h3>Actor</h3>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Actor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// CID of the code object for this actor
</span><span class="c1"></span>    <span class="nx">code</span> <span class="nx">CID</span>

    <span class="c1">// Reference to the root of this actor&#39;s state
</span><span class="c1"></span>    <span class="nx">head</span> <span class="o">&amp;</span><span class="nx">ActorState</span>

    <span class="c1">// Counter of the number of messages this actor has sent
</span><span class="c1"></span>    <span class="nx">nonce</span> <span class="nx">UInt</span>

    <span class="c1">// Current Filecoin balance of this actor
</span><span class="c1"></span>    <span class="nx">balance</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<div id="listings__data_structures__signature"></div><h3>Signature</h3>

<p><a href="./#algorithms__crypto__signatures">Cryptographic signatures</a> in Filecoin are represented
as byte arrays, and come with a tag that signifies what key type was used to create
the signature.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Signature</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">Secp256k1Signature</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">Bls12_381Signature</span> <span class="mi">1</span>
<span class="p">}</span> <span class="c1">// representation byteprefix
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Secp256k1Signature</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">Bls12_381Signature</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<div id="listings__data_structures__faultset"></div><h3>FaultSet</h3>

<p><code>FaultSet</code> data structures are used to denote which sectors failed at which block heights.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FaultSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">index</span>    <span class="nx">UInt</span>
    <span class="nx">bitField</span> <span class="nx">BitField</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<p>In order to make the serialization more compact,
the <code>index</code> field denotes a block height offset from the start of the corresponding
miner&rsquo;s proving period.</p>

<div id="listings__data_structures__basic_types"></div><h3>Basic Types</h3>

<p><h4>CID</h4>
  For most objects referenced by Filecoin, a Content Identifier (CID for short) is used.
  This is effectively a hash value, prefixed with its hash function (multihash)
  as well as extra labels to inform applications about how to deserialize the given data.
  For a more detailed specification, we refer the reader to the
  <a href="https://github.com/ipld/cid">IPLD repository</a>.</p>

<p><h4>Timestamp</h4>
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timestamp</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<p><h4>PublicKey</h4>
  The public key type is simply an array of bytes.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PublicKey</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<p><h4>BytesAmount</h4>
  BytesAmount is just a re-typed Integer.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BytesAmount</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<p><h4>PeerId</h4>
  The serialized bytes of a libp2p peer ID.
  <div class="notices todo">
  <strong>TODO</strong>:  Spec incomplete; take a look at <a href="https://github.com/libp2p/specs/pull/100">this PR</a>.
</div></p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PeerId</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<p><h4>Bitfield</h4>
  Bitfields are a set encoded using a custom run length encoding: RLE+.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Bitfield</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<p><h4>SectorSet</h4>
  A sector set stores a mapping of sector IDs to the respective <code>commR</code>s.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectorSet</span> <span class="kd">map</span><span class="p">[</span><span class="nx">SectorID</span><span class="p">]</span><span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<p><div class="notices todo">
  <strong>TODO</strong>:
  Improve on this; see <a href="https://github.com/filecoin-project/specs/issues/116">https://github.com/filecoin-project/specs/issues/116</a>.</p>

<p></div></p>

<p><h4>SealProof</h4>
  SealProof is an opaque, dynamically-sized array of bytes.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SealProof</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<p><h4>PoSTProof</h4>
  PoSTProof is an opaque, dynamically-sized array of bytes.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PoSTProof</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<p><h4>TokenAmount</h4>
  A type to represent an amount of Filecoin tokens.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TokenAmount</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<p><h4>SectorID</h4>
  Uniquely identifies a miner&rsquo;s sector.
  <div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectorID</span> <span class="kt">uint64</span>
</code></pre></div>
  
</div>
</p>

<div id="listings__data_structures__rle_bitset_encoding"></div><h3>RLE&#43; Bitset Encoding</h3>

<p>RLE+ is a lossless compression format based on <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a>.
Its primary goal is to reduce the size in the case of many individual bits, where RLE breaks down quickly,
while keeping the same level of compression for large sets of contiugous bits.</p>

<p>In tests it has shown to be more compact than RLE itself, as well as <a href="https://arxiv.org/pdf/1004.0403.pdf">Concise</a> and <a href="https://roaringbitmap.org/">Roaring</a>.</p>

<h4>Format</h4>

<p>The format consists of a header, followed by a series of blocks, of which there are three different types.</p>

<p>The format can be expressed as the following <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> grammar.</p>

<pre><code>    &lt;encoding&gt; ::= &lt;header&gt; &lt;blocks&gt;
      &lt;header&gt; ::= &lt;version&gt; &lt;bit&gt;
     &lt;version&gt; ::= &quot;00&quot;
      &lt;blocks&gt; ::= &lt;block&gt; &lt;blocks&gt; | &quot;&quot;
       &lt;block&gt; ::= &lt;block_single&gt; | &lt;block_short&gt; | &lt;block_long&gt;
&lt;block_single&gt; ::= &quot;1&quot;
 &lt;block_short&gt; ::= &quot;01&quot; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;
  &lt;block_long&gt; ::= &quot;00&quot; &lt;unsigned_varint&gt;
         &lt;bit&gt; ::= &quot;0&quot; | &quot;1&quot;
</code></pre>

<p>An <code>&lt;unsigned_varint&gt;</code> is defined as specified <a href="https://github.com/multiformats/unsigned-varint">here</a>.</p>

<h5>Header</h5>

<p>The header indicates the very first bit of the bit vector to encode. This means the first bit is always
the same for the encoded and non-encoded form.</p>

<h5>Blocks</h5>

<p>The blocks represent how many bits, of the current bit type there are. As <code>0</code> and <code>1</code> alternate in a bit vector
the inital bit, which is stored in the header, is enough to determine if a length is currently referencing
a set of <code>0</code>s, or <code>1</code>s.</p>

<h6>Block Single</h6>

<p>If the running length of the current bit is only <code>1</code>, it is encoded as a single set bit.</p>

<h6>Block Short</h6>

<p>If the running length is less than <code>16</code>, it can be encoded into up to four bits, which a short block
represents. The length is encoded into a 4 bits, and prefixed with <code>01</code>, to indicate a short block.</p>

<h6>Block Long</h6>

<p>If the running length is <code>16</code> or larger, it is encoded into a varint, and then prefixed with <code>00</code> to indicate
a long block.</p>

<blockquote>
<p><strong>Note:</strong> The encoding is unique, so no matter which algorithm for encoding is used, it should produce
the same encoding, given the same input.</p>
</blockquote>

<h6>Bit Numbering</h6>

<p>For Filecoin, byte arrays representing RLE+ bitstreams are encoded using <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0</a> bit numbering.</p>

<div id="listings__data_structures__other_considerations"></div><h3>Other Considerations</h3>

<ul>
<li>The maximum size of an Object should be 1MB (2^20 bytes). Objects larger than this are invalid.</li>
<li>Hashes should use a blake2b-256 multihash.</li>
</ul>




</div>

  

  
    








<div id="listings__components">

<h2>
  Components
</h2>

<p>TODO</p>




</div>

  

  
    








<div id="listings__libp2p_protocols">

<h2>
  libp2p Protocols
</h2>

<p>TODO</p>




</div>

  


</div>


  
    
    








<div id="glossary">

<h1>
  Glossary
</h1>



<h2 id="updates-to-definitions">Updates to definitions</h2>

<p>To make any updates to these definitions please submit a pull request with the changes, or open an issue and one of the maintainers will do it for you.</p>

<h2 id="notes">Notes</h2>

<ul>
<li>Want to split all repair stuff to separate doc</li>
<li>Let&rsquo;s refer to Filecoin system rather than network. In a sense, the network is an instantiation of the system (this protocol). We can however refer to the Filecoin VM separately which means the system by which we apply changes to the state of the system at a point in time.</li>
<li>Asterisks indicate that the definition requires updating by any affected party.</li>
</ul>

<h2 id="definitions">Definitions</h2>

<h4 id="actor">Actor</h4>

<p>An actor is an on-chain object with its own state and set of methods. An actors state is persisted on-chain in the state tree, keyed by its address. All actors (miner actors, the storage market actor, account actors) have an address. Actors methods are invoked by crafting messages and getting miners to include them in blocks.</p>

<p>Actors are very similar to smart contracts in Ethereum.</p>

<h4 id="address">Address</h4>

<p>An address is an identifier that refers to an actor in the Filecoin state.</p>

<h4 id="ask">Ask</h4>

<h4 id="bid">Bid</h4>

<h4 id="block">Block</h4>

<p>A block in the Filecoin blockchain is a chunk of data appended to the shared history of the network including transactions, messages, etc. and representing the state of the storage network at a given point in time.</p>

<p>See [Data Structures]()</p>

<h4 id="bootstrapping">Bootstrapping</h4>

<h4 id="chain-weight">Chain weight</h4>

<h4 id="challenge-sampling">Challenge sampling</h4>

<h4 id="cid">Cid</h4>

<p>CID is short for Content Identifier, a self describing content address used throughout the ipfs ecosystem. For more detailed information, see <a href="https://github.com/ipld/cid">the github documentation for it</a>.</p>

<h4 id="client">Client</h4>

<p>A client is any user with an account who wishes to store data with a miner. A client&rsquo;s account is used to pay for the storage, and helps to prove the clients ability to pay.</p>

<h4 id="collateral">Collateral</h4>

<p>Collateral is Filecoin tokens pledged by an actor as a commitment to a promise. If the promise is respected, the collateral is returned. If the promise is broken, the collateral is not returned in full. For instance:</p>

<ul>
<li>In becoming a Filecoin storage miner: the miner will put up collateral alongside their SEAL to</li>
<li>In a Filecoin deal: both the miner and client put up collateral to ensure their respect of deal terms.</li>
</ul>

<h4 id="commitment">Commitment</h4>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h4 id="confirmation">Confirmation</h4>

<h4 id="consensus">Consensus</h4>

<h4 id="deal">Deal</h4>

<p>*** *A deal in a Filecoin market is made when a bid and ask are matched, corresponding to an agreement on a service and price between a miner and client.</p>

<h4 id="election-proof">Election Proof</h4>

<p>An <code>ElectionProof</code> is derived from a past <code>ticket</code> and is included in every block header. The <code>ElectionProof</code> proves that the miner was eligible to mine a block at that <code>height</code>.</p>

<h4 id="erasure-coding">Erasure coding</h4>

<p>Erasure coding is a strategy through which messages can be lengthened so as to be made recoverable in spite of errors.</p>

<p>See <a href="https://en.wikipedia.org/wiki/Erasure_code">Wikipedia</a></p>

<h4 id="fault">Fault</h4>

<p>A fault occurs when a proof is not posted in the Filecoin system within the proving period, denoting another malfunction such as loss of network connectivity, storage malfunction, malicious miner, etc.</p>

<h4 id="fair">Fair</h4>

<h4 id="file">File</h4>

<p>Files are what clients bring to the filecoin system to store. A file is split up into <code>pieces</code>, which are what is actually stored by the network.</p>

<h4 id="finality">Finality</h4>

<h4 id="piece-inclusion-proof">Piece Inclusion Proof</h4>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h4 id="gas-fees-prices">Gas, Fees, Prices</h4>

<h4 id="generation-attack-threshold">Generation Attack Threshold</h4>

<p>Security parameter. Number of rounds within which a new Proof-of-Storage must be submitted in order for a miner to retain power in the network (and avoid getting slashed). This number must be be smaller than the minimum time it takes for an adversarial miner to generate a replica of the data (thereby not storing it undetectably for some period of time).</p>

<p>The Generation Attack Threshold is equal to the Polling Time + some Grace Period after which miners get slashed.</p>

<h4 id="ghost">GHOST</h4>

<p><a href="https://eprint.iacr.org/2013/881.pdf">GHOST</a> is an acronym for <code>Greedy Heaviest Observable SubTree</code>, a class of blockchain structures in which multiple blocks can validly be included in the chain at any given height or round. GHOSTy protocols produce blockDAGs rather than blockchains and use a weighting function for fork selection, rather than simply picking the longest chain.</p>

<h4 id="height">Height</h4>

<p><code>Height</code> and <code>round</code> are synonymous and used interchangeably in this spec.</p>

<p><code>Height</code> refers to the number of tickets generated between this <code>TipSet</code> and the genesis block (height 0), counting only the tickets of the block in a TipSet whose final ticket &ndash; the one generated alongside the <code>ElectionProof</code> &ndash; is the smallest.</p>

<p>If a <code>TipSet</code> contains multiple blocks, each block in the TipSet will have the same <code>height</code>. Put another way, there is a new <code>round</code> of leader election attempts at each <code>height</code>. Typically, such an attempt will find a single leader. If a single leader is found, that leader can generate a single block. If multiple leaders are found, they can each generate multiple blocks in the given round. If no leader is found, no block is generated (but a ticket is).</p>

<h4 id="leader">Leader</h4>

<p>A leader, in the context of Filecoin consensus, is a node that is chosen to propose the next block in the blockchain.</p>

<h4 id="leader-election">Leader election</h4>

<p>Leader election is the process by which the Filecoin network agrees who gets to create the next block.</p>

<h4 id="message">Message</h4>

<p>A message is a call to an actor in the Filecoin VM.</p>

<h4 id="miner">Miner</h4>

<p>A miner is an actor in the Filecoin system performing a service in the network for a reward.</p>

<p>There are multiple types of miners in Filecoin:</p>

<ul>
<li>Storage miners - storage miners</li>
<li>Retrieval miners:</li>
<li>Repair miners (to be split out):</li>
</ul>

<h4 id="node">Node</h4>

<p>*** *A node is a communication endpoint that implements the Filecoin protocol. (also mention IPLD Node?)</p>

<h4 id="on-chain-off-chain">On-chain/off-chain</h4>

<h4 id="online-offline">Online/offline</h4>

<h4 id="payment-channel">Payment Channel</h4>

<p>A payment channel is set up between actors in the Filecoin system to enable off-chain payments with on-chain guarantees, making settlement more efficient.</p>

<h4 id="piece">Piece</h4>

<p>A piece is a portion of a file that gets fitted into a sector.</p>

<h4 id="pledge">Pledge</h4>

<p>****The initial commitment of a storage miner to provide a number of sectors to the system.</p>

<h4 id="polling-time">Polling Time</h4>

<p>Security Parameter. Polling time is the time between two online PoReps in a PoSt proof.</p>

<h4 id="power">Power</h4>

<p>See <code>Power Fraction</code>.</p>

<h4 id="power-fraction">Power Fraction</h4>

<p>A miner&rsquo;s <code>Power Fraction</code> or <code>Power</code> is the ratio of their committed storage as of their last PoSt submission over Filecoin&rsquo;s total committed storage as of the current block. It is used in leader election.</p>

<h4 id="power-table">Power table</h4>

<p>The power table is an abstraction provided by the Filecoin storage market that lists the <code>power</code> of every miner in the system.</p>

<h4 id="protocol">Protocol</h4>

<h4 id="proving-period">Proving Period</h4>

<p>The period of time during which storage miners must compute Proofs of Spacetime. At the end of the period they must submit their PoSt. Put another way, it is the duration of a PoSt.</p>

<h4 id="proving-set">Proving Set</h4>

<p>The elements used as input by a proof of Spacetime to enable a proof to be generated.</p>

<p>**** elements necessary to generate a SEAL, or elements necessary to generate a proof</p>

<h4 id="proof-of-replication">Proof of Replication</h4>

<p>Proof that a unique encoding of data exists in physical storage.</p>

<p>Used in the Filecoin system to generate SEALed sectors through which storage miners prove they hold client data.</p>

<h4 id="proof-of-spacetime">Proof of Spacetime</h4>

<p>Proof that a given encoding of data existed in physical storage continuously over a period of time.</p>

<p>Used in the Filecoin system by a storage miner to prove that client data was kept over the contract duration.</p>

<h4 id="random-ness">Random(ness)</h4>

<p>****Source of unpredictability used in the Filecoin system to ensure fairness and prevent malicious actors from gaining an advantage over the system.</p>

<p>TODO add a note to distinguish predictability from randomness</p>

<h4 id="election-randomness-lookback">Election Randomness Lookback</h4>

<p>Security parameter. A number of rounds to sample back from when choosing randomness for use in leader election. A higher number turns a more localized lottery into a more global one since a miner wins or loses on all descendants of a given randomness, but enables miners to look-ahead and know whether they will be elected in the future.</p>

<p>Also referred to as <code>K</code> in consensus settings.</p>

<h4 id="repair">Repair</h4>

<p>Repair refers to the processes and protocols by which the Filecoin network ensures that data that is partially lost (by, for example, a miner disappearing) can be re-constructed and re-added to the network.</p>

<h4 id="round">Round</h4>

<p>See <code>Height</code> for definition. They are synonymous.</p>

<h4 id="seal-unseal">SEAL/UNSEAL</h4>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h4 id="sector">Sector</h4>

<p>A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on.</p>

<h4 id="slashing">Slashing</h4>

<h4 id="smart-contracts">Smart contracts</h4>

<h4 id="storage">Storage</h4>

<p>Storage widely refers to a place in which to store data in a given system.</p>

<p>In the context of:</p>

<ul>
<li>The Filecoin miner: sotrage refers to disk sectors made available to the network.</li>
<li>The Filecoin chain: storage refers to the way in which system state is tracked through time on-chain through blocks.</li>
<li>Actor: the struct that defines an actor.</li>
</ul>

<h4 id="state">State</h4>

<p>****Refers to The shared history of the Filecoin system contains actors and their storage, deals, etc. State is deterministically generated from the initial state and the set of messages generated by the system.</p>

<h4 id="ticket">Ticket</h4>

<p>A <code>ticket</code> is used as a source of randomness in EC leader election. Every block depends on an <code>ElectionProof</code> derived from a <code>ticket</code>. At least one new <code>ticket</code> is produced with every new block. Ticket creation is described <a href="./expected-consensus.md#Ticket-generation">here</a>.</p>

<h4 id="ticket-chain">Ticket Chain</h4>

<p>Each chain in Filecoin can be associated to a given <code>ticket chain</code>. The <code>ticket chain</code> is assembled by taking the tickets (usually one) contained by the block with the smallest final ticket in each of the chain&rsquo;s <code>TipSet</code>s.</p>

<p>Ticket comparison is done by interpreting the tickets&rsquo; Bytes as unsigned integers (little endian representation).</p>

<h4 id="tipset">TipSet</h4>

<p>A <code>TipSet</code> is a set of blocks that have the same parent set and same number of <code>tickets</code>, which implies they will have been mined at the same <code>height</code>. A <code>TipSet</code> can contain multiple blocks if more than one miner successfully mines a block at the same <code>height</code> as another miner.</p>

<h4 id="verifiable">Verifiable</h4>

<p>Something that is verifiable can be checked for correctness by a third party.</p>

<h4 id="vdf">VDF</h4>

<p>A verifiable function that guarantees a time delay given some hardware assumptions and a small set of requirements. These requirements are efficient proof verification, random output, and strong sequentiality. Verifiable delay functions are formally defined by [[BBBF]](<a href="https://eprint.iacr.org/2018/601">https://eprint.iacr.org/2018/601</a>).</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;—- VDF(public parameters, seed)</code></pre></div>
<h4 id="vm">VM</h4>

<p>Virtual Machine. The Filecoin VM refers to the system by which changes are applied to the Filecoin system&rsquo;s state. The VM takes messages as input, and outputs state.</p>

<h4 id="voucher">Voucher</h4>

<p>Held by an actor as part of a payment channel to complete settlement when the counterparty defaults.</p>

<h4 id="vrf">VRF</h4>

<p>A verifiable random function that receives {Secret Key (SK), seed} and outputs {proof of correctness, output value}. VRFs must yield a proof of correctness and a unique &amp; efficiently verifiable output.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;-- VRF(SK, seed)</code></pre></div>
<h4 id="weight">Weight</h4>

<p>Every mined block has a computed <code>weight</code>. Together, the <code>weights</code> of all the blocks in a branch of the chain determines the cumulative <code>weight</code> of that branch. Filecoin&rsquo;s Expected Consensus is a GHOSTy or heaviest-chain protocol, where chain selection is done on the basis of an explicit weighting function. Filecoin’s <code>weight</code> function currently seeks to incentivize collaboration amongst miners as well as the addition of storage to the network. The specific weighting function is defined in <a href="expected-consensus.md#chain-weighting">Chain Weighting</a>.</p>

<h4 id="zksnark">zkSNARK</h4>

<p>Zero Knowledge Succinct ARguments of Knowledge. A way of producing a small &lsquo;proof&rsquo; that convinces a &lsquo;verifier&rsquo; that some computation was done correctly.</p>




</div>


  
    
    








<div id="appendix">

<h1>
  Appendix
</h1>




  
    








<div id="appendix__sharray">

<h2>
  Sharded IPLD Array
</h2>



<p>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.</p>

<h2 id="ipld-representation">IPLD Representation</h2>

<p>Each sharray node is represented by an IPLD node of the following schema:</p>

<pre><code>type Node struct {
  height Int
  items [Item]
} representation tuple
</code></pre>

<p><code>Item</code> may be either a direct value, if <code>height == 0</code>, or the Cid of a child node if <code>height &gt; 0</code>.</p>

<p>(For details on IPLD Schemas, see the <a href="https://github.com/ipld/specs/blob/dcbfb25468092be796bab90e90e3f2535fdeddc7/schema/representations.md">IPLD Schema Spec (draft)</a>)</p>

<p>We use DAG-CBOR for serialization, and blake2b-256 for hashing.</p>

<h2 id="construction">Construction</h2>

<p>The tree must not be sparse.
Given an array of size <code>N</code> and a fixed width of <code>W</code>.
- The left <code>floor(N/W)</code> leaves contain the first <code>N</code> items.
- If <code>N % W != 0</code> the final leaf contains the final remainder.
- The tree is perfectly balanced.
- The height is the distance from the leaves, not the root.
- Leaves (nodes with a height of 0) contain array values.
- Inner nodes (nodes with height greater than zero) contain the cids of their child nodes.</p>

<h2 id="operations">Operations</h2>

<h4 id="create-items"><code>create(items)</code></h4>

<blockquote>
<p>Create a sharray from a given set of items</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">create</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="nx">Item</span><span class="p">)</span> <span class="nx">Cid</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">layer</span> <span class="nx">cidQueue</span>

	<span class="nx">itemQ</span> <span class="o">:=</span> <span class="nf">queue</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">itemQ</span><span class="p">.</span><span class="nf">Empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// get the next &#39;Width&#39; items from the input items
</span><span class="c1"></span>		<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">itemQ</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

		<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
			<span class="nx">height</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="c1">// persist the node to the datastore
</span><span class="c1"></span>		<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

		<span class="nx">layer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">nextLayer</span> <span class="nx">cidQueue</span>
	<span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

			<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
				<span class="nx">height</span><span class="p">:</span> <span class="nx">height</span><span class="p">,</span>
				<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
			<span class="p">}</span>

			<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

			<span class="nx">nextLayer</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">layer</span> <span class="p">=</span> <span class="nx">nextLayer</span>
		<span class="nx">nextLayer</span><span class="p">.</span><span class="nf">ClearItems</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nextLayer</span><span class="p">.</span><span class="nf">First</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="get-i"><code>get(i)</code></h4>

<blockquote>
<p>Get the element at index <code>i</code></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">node</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">childWidth</span> <span class="o">:=</span> <span class="nf">Pow</span><span class="p">(</span><span class="nx">Width</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>

	<span class="nx">child</span> <span class="o">:=</span> <span class="nf">loadNode</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="nx">childWidth</span><span class="p">])</span>
	<span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">childWidth</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>



</div>

  

  
    








<div id="appendix__address">

<h2>
  Address
</h2>



<p>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</p>

<h4 id="design-criteria">Design criteria</h4>

<ol>
<li><strong>Identifiable</strong>: The address must be easily identifiable as a Filecoin address.</li>
<li><strong>Reliable</strong>: Addresses must provide a mechanism for error detection when they might be transmitted outside the network.</li>
<li><strong>Upgradable</strong>: Addresses must be versioned to permit the introduction of new address formats.</li>
<li><strong>Compact</strong>: Given the above constraints, addresses must be as short as possible.</li>
</ol>

<h2 id="specification">Specification</h2>

<p>There are 2 ways a filecoin address can be represented. An address appearing on chain will always be formatted as raw bytes. An address may also be encoded to a string, this encoding includes a checksum and network prefix. An address encoded as a string will never appear on chain, this format is used for sharing among humans.</p>

<h5 id="bytes">Bytes</h5>

<p>When represented as bytes a filecoin address contains the following:</p>

<ul>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>

<li><p>The <strong>payload</strong> used to uniquely identify the actor according to the protocol.</p>

<pre><code>|----------|---------|
| protocol | payload |
|----------|---------|
|  1 byte  | n bytes |
</code></pre></li>
</ul>

<h5 id="string">String</h5>

<p>When encoded to a string a filecoin address contains the following:</p>

<ul>
<li>A <strong>network prefix</strong> character that identifies the network the address belongs to.</li>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>
<li>A <strong>payload</strong> used to uniquely identify the actor according to the protocol.</li>

<li><p>A <strong>checksum</strong> used to validate the address.</p>

<pre><code>|------------|----------|---------|----------|
|  network   | protocol | payload | checksum |
|------------|----------|---------|----------|
| 'f' or 't' |  1 byte  | n bytes | 4 bytes  |
</code></pre></li>
</ul>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Address</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">AddressId</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">AddressSecp256k1</span> <span class="mi">1</span>
    <span class="p">|</span> <span class="nx">AddressActor</span> <span class="mi">2</span>
    <span class="p">|</span> <span class="nx">AddressBLS12_381</span> <span class="mi">3</span>
<span class="p">}</span> <span class="c1">// representation byteprefix
</span><span class="c1"></span>
<span class="c1">// ID
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressId</span> <span class="nx">UInt</span>

<span class="c1">// Blake2b-160 Hash
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressSecp256k1</span> <span class="nx">Bytes</span>

<span class="c1">// Blake2b-160 Hash
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressActor</span> <span class="nx">Bytes</span>

<span class="c1">// 48 byte PublicKey
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressBLS12_381</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h4 id="network-prefix">Network Prefix</h4>

<p>The <strong>network prefix</strong> is prepended to an address when encoding to a string. The network prefix indicates which network an address belongs in. The network prefix may either be <code>f</code> for filecoin mainnet or <code>t</code> for filecoin testnet. It is worth noting that a network prefix will never appear on chain and is only used when encoding an address to a human readable format.</p>

<h4 id="protocol-indicator">Protocol Indicator</h4>

<p>The <strong>protocol indicator</strong> byte describes how a method should interpret the information in the payload field of an address. Any deviation for the algorithms and data types specified by the protocol must be assigned a new protocol number. In this way, protocols also act as versions.</p>

<ul>
<li><code>0</code> : ID</li>
<li><code>1</code> : SECP256K1 Public Key</li>
<li><code>2</code> : Actor</li>
<li><code>3</code> : BLS Public Key</li>
</ul>

<p>An example description in golang:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Protocol byte
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kt">byte</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">ID</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">SECP256K1</span>
	<span class="nx">Actor</span>
	<span class="nx">BLS</span>
<span class="p">)</span></code></pre></div>
<h6 id="protocol-0-ids">Protocol 0: IDs</h6>

<p><strong>Protocol 0</strong> addresses are simple IDs.  All actors have a numeric ID even if they don&rsquo;t have public keys. The payload of an ID address is base10 encoded. IDs are not hashed and do not have a checksum.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------|
| protocol |    payload    |
|----------|---------------|
|    0     | leb128-varint |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------|
|  network   | protocol |    payload    |
|------------|----------|---------------|
| 'f' or 't' |    '0'   | leb128-varint |
                  base10[...............]
</code></pre>

<h6 id="protocol-1-libsecpk1-elliptic-curve-public-keys">Protocol 1: libsecpk1 Elliptic Curve Public Keys</h6>

<p><strong>Protocol 1</strong> addresses represent secp256k1 public encryption keys. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of the public key.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    1     | blake2b-160(PubKey) |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '1'   | blake2b-160(PubKey) |  4 bytes |
                  base32[................................]
</code></pre>

<h6 id="protocol-2-actor">Protocol 2: Actor</h6>

<p><strong>Protocol 2</strong> addresses representing an Actor. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of meaningful data produced as a result of creating the actor.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    2     | blake2b-160(Random) |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|-----------------------|----------|
|  network   | protocol |         payload       | checksum |
|------------|----------|-----------------------|----------|
| 'f' or 't' |    '2'   |  blake2b-160(Random)  |  4 bytes |
                  base32[..................................]
</code></pre>

<h6 id="protocol-3-bls">Protocol 3: BLS</h6>

<p><strong>Protocol 3</strong> addresses represent BLS public encryption keys. The payload field contains the BLS public key.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    3     | 48 byte BLS PubKey  |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '3'   |  48 byte BLS PubKey |  4 bytes |
                  base32[................................]
</code></pre>

<h4 id="payload">Payload</h4>

<p>The payload represents the data specified by the protocol. All payloads except the payload of the ID protocol are <a href="https://tools.ietf.org/html/rfc4648#section-6">base32</a> encoded using the lowercase alphabet when seralized to their human readable format.</p>

<h4 id="checksum">Checksum</h4>

<p>Filecoin checksums are calculated over the address protocol and payload using blake2b-4. Checksums are base32 encoded and only added to an address when encoding to a string. Addresses following the ID Protocol do not have a checksum.</p>

<h4 id="expected-methods">Expected Methods</h4>

<p>All implementations in Filecoin must have methods for creating, encoding, and decoding addresses in addition to checksum creation and validation. The follwing is a golang version of the Address Interface:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span>

<span class="kd">type</span> <span class="nx">Address</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="nx">Network</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Adress</span><span class="p">)</span> <span class="kt">string</span>
	<span class="nf">Decode</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span>
	<span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span></code></pre></div>
<h5 id="new">New()</h5>

<p>New returns an Address for the specified protocol encapsulating corresponding payload. New fails for unknown protocols.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="p">&lt;</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="p">&gt;</span> <span class="nx">BLS</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownType</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="encode">Encode()</h5>

<p>Software encoding a Filecoin address must:</p>

<ul>
<li>produce an address encoded to a known network</li>
<li>produce an address encoded to a known protocol</li>
<li>produce an address with a valid checksum (if applicable)</li>
</ul>

<p>Encodes an Address as a string, prepending the network prefix, calculating the checksum, and encoding the payload and checksum to <a href="https://tools.ietf.org/html/rfc4648">base32</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Invalid Network&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SECP256K1</span><span class="p">,</span> <span class="nx">Actor</span><span class="p">,</span> <span class="nx">BLS</span><span class="p">:</span>
		<span class="nx">cksm</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="o">+</span><span class="nx">cksm</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">ID</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base10</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">leb128</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid address protocol&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="decode">Decode()</h5>

<p>Software decoding a Filecoin address must:
* verify the network is a known network.
* verify the protocol is a number of a known protocol.
* verify the checksum is valid</p>

<p>Decode an Address from a string by removing the network prefix, validating the address is of a know protocol, decoding the payload and checksum, and validating the checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">3</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidLength</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownNetwork</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">protocol</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">raw</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">ID</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
			<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
			<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">leb128</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">base10</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">raw</span> <span class="p">=</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span>
	<span class="nx">payload</span> <span class="p">=</span> <span class="nx">raw</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">Actor</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidBytes</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">cksm</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">:]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">cksm</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidChecksum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="checksum-1">Checksum()</h5>

<p>Checksum produces a byte array by taking the blake2b-4 hash of an address protocol and payload.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nf">blake2b4</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h5 id="validatechecksum">ValidateChecksum()</h5>

<p>ValidateChecksum returns true if the Checksum of data matches the expected checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">expected</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">digest</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">digest</span> <span class="o">==</span> <span class="nx">expected</span>
<span class="p">}</span></code></pre></div>
<h2 id="vectors">Vectors</h2>

<p>These are a set of test vectors that can be used to test an implementation of
this address spec. Test vectors are presented as newline-delimited address/hex
fields. The &lsquo;address&rsquo; field, when parsed, should produce raw bytes that match
the corresponding item in the &lsquo;hex&rsquo; field. For example:</p>

<pre><code>address1
hex1

address2
hex2
</code></pre>

<h3 id="id-type-addresses">ID Type Addresses</h3>

<pre><code>f00
0000

f0150
009601

f01024
008008

f01729
00c10d

f018446744073709551615
00ffffffffffffffffff01
</code></pre>

<h3 id="secp256k1-type-addresses">Secp256k1 Type Addresses</h3>

<pre><code>f17uoq6tp427uzv7fztkbsnn64iwotfrristwpryy
01fd1d0f4dfcd7e99afcb99a8326b7dc459d32c628

f1xcbgdhkgkwht3hrrnui3jdopeejsoatkzmoltqy
01b882619d46558f3d9e316d11b48dcf211327026a

f1xtwapqc6nh4si2hcwpr3656iotzmlwumogqbuaa
01bcec07c05e69f92468e2b3e3bf77c874f2c5da8c

f1wbxhu3ypkuo6eyp6hjx6davuelxaxrvwb2kuwva
01b06e7a6f0f551de261fe3a6fe182b422ee0bc6b6

f12fiakbhe2gwd5cnmrenekasyn6v5tnaxaqizq6a
01d1500504e4d1ac3e89ac891a4502586fabd9b417
</code></pre>

<h3 id="actor-type-addresses">Actor Type Addresses</h3>

<pre><code>f24vg6ut43yw2h2jqydgbg2xq7x6f4kub3bg6as6i
02e54dea4f9bc5b47d261819826d5e1fbf8bc5503b

f25nml2cfbljvn4goqtclhifepvfnicv6g7mfmmvq
02eb58bd08a15a6ade19d0989674148fa95a8157c6

f2nuqrg7vuysaue2pistjjnt3fadsdzvyuatqtfei
026d21137eb4c4814269e894d296cf6500e43cd714

f24dd4ox4c2vpf5vk5wkadgyyn6qtuvgcpxxon64a
02e0c7c75f82d55e5ed55db28033630df4274a984f

f2gfvuyh7v2sx3patm5k23wdzmhyhtmqctasbr23y
02316b4c1ff5d4afb7826ceab5bb0f2c3e0f364053
</code></pre>

<h3 id="bls-type-addresses">BLS Type Addresses</h3>

<p>To aid in readability, these addresses are line-wrapped. Address and hex pairs
are separated by <code>---</code>.</p>

<pre><code>f3vvmn62lofvhjd2ugzca6sof2j2ubwok6cj4xxbfzz
4yuxfkgobpihhd2thlanmsh3w2ptld2gqkn2jvlss4a
---
03ad58df696e2d4e91ea86c881e938ba4ea81b395e12
797b84b9cf314b9546705e839c7a99d606b247ddb4f9
ac7a3414dd

f3wmuu6crofhqmm3v4enos73okk2l366ck6yc4owxwb
dtkmpk42ohkqxfitcpa57pjdcftql4tojda2poeruwa
---
03b3294f0a2e29e0c66ebc235d2fedca5697bf784af
605c75af608e6a63d5cd38ea85ca8989e0efde9188b
382f9372460d

f3s2q2hzhkpiknjgmf4zq3ejab2rh62qbndueslmsdz
ervrhapxr7dftie4kpnpdiv2n6tvkr743ndhrsw6d3a
---
0396a1a3e4ea7a14d49985e661b22401d44fed402d1
d0925b243c923589c0fbc7e32cd04e29ed78d15d37d
3aaa3fe6da33

f3q22fijmmlckhl56rn5nkyamkph3mcfu5ed6dheq53
c244hfmnq2i7efdma3cj5voxenwiummf2ajlsbxc65a
---
0386b454258c589475f7d16f5aac018a79f6c1169d2
0fc33921dd8b5ce1cac6c348f90a3603624f6aeb91b
64518c2e8095

f3u5zgwa4ael3vuocgc5mfgygo4yuqocrntuuhcklf4
xzg5tcaqwbyfabxetwtj4tsam3pbhnwghyhijr5mixa
---
03a7726b038022f75a384617585360cee629070a2d9
d28712965e5f26ecc40858382803724ed34f2720336
f09db631f074
</code></pre>




</div>

  


</div>


  
</div>

</article>

      

      
    </div>

    
  
  


  </main>
  
  
  
</body>

</html>
