<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Filecoin Specification on Filecoin Spec</title>
    <link>/</link>
    <description>Recent content in Filecoin Specification on Filecoin Spec</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About this specification</title>
      <link>/docs/intro/process/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/about/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Address</title>
      <link>/docs/appendix/address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/address/</guid>
      <description>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</description>
    </item>
    
    <item>
      <title>Architecture Diagram</title>
      <link>/docs/intro/arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/arch/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Block Producer</title>
      <link>/docs/subsystems/blockchain/components/block_producer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/blockchain/components/block_producer/</guid>
      <description>Mining Blocks Having registered as a miner, it&amp;rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest TipSets seen on the network.
For additional details around how consensus works in Filecoin, see the expected consensus spec. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how &amp;ldquo;Tickets&amp;rdquo; should be validated during block validation.</description>
    </item>
    
    <item>
      <title>Block Propagator</title>
      <link>/docs/subsystems/blockchain/components/block_propagator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/blockchain/components/block_propagator/</guid>
      <description>The filecoin network needs to broadcast blocks and messages to all peers in the network. This document details how that process works.
Messages and block headers along side the message references are propagated using the gossipsub libp2p pubsub router. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be syntactically validated before being propagated further.
Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it.</description>
    </item>
    
    <item>
      <title>Block Receiver</title>
      <link>/docs/subsystems/blockchain/components/block_receiver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/blockchain/components/block_receiver/</guid>
      <description>A node must decode and perform syntactic validation for every block received before passing it on (e.g. in a lipbp2p pubsub validator).
Syntactic Validation  type Block struct { // Miner is the address of the miner actor that mined this block.  miner Address // Tickets is a chain (possibly singleton) of tickets ending with a winning ticket  // submitted with this block.  tickets [Ticket] // ElectionProof is generated from a past ticket and proves this miner is a leader  // in this block&amp;#39;s round.</description>
    </item>
    
    <item>
      <title>Chain Manager</title>
      <link>/docs/subsystems/blockchain/components/chain_manager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/blockchain/components/chain_manager/</guid>
      <description>Semantic Validation A semantically valid block:
 must be from a valid miner, i.e. has not been slashed must only have valid parents in the tipset, meaning  that each parent itself must be a valid block all parents must be at same height  must have a valid ticket:  the ticket must be the winning ticket the ticket must be generated from the smallest ticket in the parent tipset all tickets in the ticket array must have been generated by the same miner if it includes intermediary losing tickets in the ticket array, the node must confirm that each ticket correctly generates the next in the array  must have a valid timestamp, meaning  must be later than the earliest parent block time plus appreopriate delay, which is BLOCK_DELAY (30s by default) * len(blk.</description>
    </item>
    
    <item>
      <title>Components</title>
      <link>/docs/listings/components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/components/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Contributing to the Filecoin spec</title>
      <link>/docs/intro/process/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/contributing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Data Structures</title>
      <link>/docs/listings/data_structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/data_structures/</guid>
      <description>Address An address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. An address encodes information about:
 Network this address belongs to Type of data the address contains The data itself Checksum (depending on the type of address)  For more detail, see the full address spec.
Block A block header contains information relevant to a particular point in time over which the network may achieve consensus.</description>
    </item>
    
    <item>
      <title>Expected Consensus</title>
      <link>/docs/algorithms/expected_consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/expected_consensus/</guid>
      <description>This spec describes how the expected consensus (EC) protocol works in general. To read more about Filecoin-specific processes, see:
 Mining Blocks on how consensus is used in block mining. Faults on slashing. Storage market on how the power table is created and maintained. Block data structure for details on fields and encoding.  Important concepts and definitions Some important concepts relevant to expected consensus are:
 Verifiable Delay Function (VDF) Verifiable Random Function (VRF) TipSet Ticket Ticket Chain Height  In the realm of EC, it is worth noting that a new ticket must be produced at every height, and consequently the duration of a round is bounded by the duration of the Verifiable Delay Function that is run to generate a ticket.</description>
    </item>
    
    <item>
      <title>Filecoin Improvement Proposals (FIPs)</title>
      <link>/docs/intro/process/fip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/fip/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Filecoin VM</title>
      <link>/docs/intro/filecoin_vm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/filecoin_vm/</guid>
      <description>The majority of Filecoin&amp;rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &amp;lsquo;chain&amp;rsquo; of blocks is the correct one. Each block contains a series of state transitions called messages, and a checkpoint of the current global state after the application of those messages.
The global state here consists of a set of actors, each with their own private state.</description>
    </item>
    
    <item>
      <title>Filecoin VM Actors</title>
      <link>/docs/listings/actors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/actors/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Key Concepts</title>
      <link>/docs/intro/concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/concepts/</guid>
      <description>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:
 Data structures are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).
 Functions are computational procedures that do not depend on external state (i.e., mathematical functions, or programming language functions that do not refer to global variables).
 Components are sets of functionality that are intended to be represented as single software units in the implementation structure.</description>
    </item>
    
    <item>
      <title>libp2p Protocols</title>
      <link>/docs/listings/libp2p_protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/libp2p_protocols/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Network tooling</title>
      <link>/docs/intro/process/related_resources/network_tooling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/network_tooling/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Payment Channels</title>
      <link>/docs/algorithms/payment_channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/payment_channels/</guid>
      <description>Payment Channels In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.
The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &amp;ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Proof Generator</title>
      <link>/docs/subsystems/mining/components/proof_generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/mining/components/proof_generator/</guid>
      <description>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning ticket to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.
The Miner Actor After successfully calling CreateStorageMiner, a miner actor will be created on-chain, and registered in the storage market.</description>
    </item>
    
    <item>
      <title>Proof of Replication</title>
      <link>/docs/algorithms/proof_of_replication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/proof_of_replication/</guid>
      <description>This section describes the specific Proof-of-Replication used in Filecoin called ZigZag. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.
ZigZag has been presented by Ben Fisch at EUROCRYPT19.
Introduction Background on Proof-of-Replication Proof-of-Replication enables a prover P to convince a verifier V that P is storing a replica R, a physically independent copy of some data D, unique to P.</description>
    </item>
    
    <item>
      <title>Proof of Spacetime</title>
      <link>/docs/algorithms/proof_of_spacetime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/proof_of_spacetime/</guid>
      <description>This document describes Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
Rational PoSt Definitions    Name Value Description     POST_PROVING_PERIOD 2880 blocks (~24h) The time interval in which a PoSt has to be submitted.   POST_CHALLENGE_TIME 240 blocks (~2h) The time offset at which the actual work of generating the PoSt can not be started earlier than. This is some delta before the end of the Proving Period, and as such less then a single Proving Period.</description>
    </item>
    
    <item>
      <title>Research portal</title>
      <link>/docs/intro/process/related_resources/research_portal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/research_portal/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Sharded IPLD Array</title>
      <link>/docs/appendix/sharray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/sharray/</guid>
      <description>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.
IPLD Representation Each sharray node is represented by an IPLD node of the following schema:
type Node struct { height Int items [Item] } representation tuple  Item may be either a direct value, if height == 0, or the Cid of a child node if height &amp;gt; 0.</description>
    </item>
    
    <item>
      <title>Signatures</title>
      <link>/docs/algorithms/crypto/signatures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/signatures/</guid>
      <description>Signatures Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.
We use signatures in filecoin to verify something was done by someone.</description>
    </item>
    
    <item>
      <title>Storage Provider</title>
      <link>/docs/subsystems/storage/components/storage_provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/storage/components/storage_provider/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Testing and implementation compliance</title>
      <link>/docs/intro/process/related_resources/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/testing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Verifiable Delay Functions</title>
      <link>/docs/algorithms/vdf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/vdf/</guid>
      <description>TODO: finish</description>
    </item>
    
    <item>
      <title>VM Interpreter</title>
      <link>/docs/subsystems/vm/components/vm_interpreter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/subsystems/vm/components/vm_interpreter/</guid>
      <description>Sending Funds As all messages carry a method ID, the method ID &amp;lsquo;0&amp;rsquo; is reserved for simple transfers of funds. Funds specified by the value field are always transferred, but specifying a method ID of &amp;lsquo;0&amp;rsquo; ensures that no other side effects occur.
State Representation The global state is modeled as a map of actor IDs to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the &amp;lsquo;key&amp;rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the InitActor), and the value is an Actor object with the actors information.</description>
    </item>
    
  </channel>
</rss>