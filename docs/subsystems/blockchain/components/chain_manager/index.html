<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Chain Manager
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../../../../book.min.dd7edd971a70e42d8b77dee6408ce13a65b881f03c3da4d4895f894b428e6946.css">


<link rel="icon" href="../../../../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../../../../css/syntax.css">
<link href="../../../../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../../../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fsubsystems\2f blockchain\2f components\2f chain_manager\2f "] {
      color: #0b3a53;
  }
  </style>


  <div>
  <ul>
    
      
      <li>
        











<a href="../../../../../#intro">    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#intro__arch">    
    
        Architecture Diagram
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#intro__concepts">    
    
        Key Concepts
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#intro__filecoin_vm">    
    
        Filecoin VM
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#intro__process">    
    
        Spec Process
    
</a>



    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../../../#algorithms">    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#algorithms__expected_consensus">    
    
        Expected Consensus
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#algorithms__proof_of_replication">    
    
        Proof of Replication
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#algorithms__proof_of_spacetime">    
    
        Proof of Spacetime
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#algorithms__payment_channels">    
    
        Payment Channels
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#algorithms__vdf">    
    
        Verifiable Delay Functions
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#algorithms__crypto">    
    
        Cryptographic Primitives
    
</a>



    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../../../#subsystems">    
    
    <strong>
    
        Subsystems
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain">    
    
        Blockchain
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain__components">    
    
        Blockchain Components
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain__components__block_receiver">    
    
        Block Receiver
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain__components__block_propagator">    
    
        Block Propagator
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain__components__chain_manager">    
    
        Chain Manager
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain__components__block_producer">    
    
        Block Producer
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__blockchain__libp2p">    
    
        libp2p Protocols
    
</a>


<ul>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__vm">    
    
        Filecoin VM
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__vm__components">    
    
        Filecoin VM Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__vm__components__vm_interpreter">    
    
        VM Interpreter
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__vm__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__vm__actors__standard">    
    
        Standard Actors
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__vm__actors__singleton">    
    
        Singleton Actors
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__storage">    
    
        Storage Market
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../../../#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__storage__components">    
    
        Storage Market Components
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__storage__components__storage_provider">    
    
        Storage Provider
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__storage__libp2p">    
    
        libp2p Protocols
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__retrieval">    
    
        Retrieval Market
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../../../#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__retrieval__components">    
    
        Retrieval Market Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__mining">    
    
        Storage Mining
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#subsystems__mining__actors">    
    
        Storage Mining Actors
    
</a>


<ul>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__mining__components">    
    
        Storage Mining Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__mining__components__proof_generator">    
    
        Proof Generator
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#subsystems__network">    
    
        Network Interface
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../../#subsystems__repository">    
    
        Repository
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../../../#listings">    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../../../#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#listings__data_structures">    
    
        Data Structures
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#listings__components">    
    
        Components
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../../#listings__libp2p_protocols">    
    
        libp2p Protocols
    
</a>


<ul>

</ul>


    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../../../#glossary">    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>


<ul>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../../../#appendix">    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



      </li>
    
  </ul>
</div>








</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../../../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Chain Manager
  
</strong>
</header>

      
<article class="markdown">
  

<div id="subsystems__blockchain__components__chain_manager__semantic_validation"></div><h3>Semantic Validation</h3>

<p>A semantically valid block:</p>

<ul>
<li>must be from a valid miner, i.e. has not been slashed</li>
<li>must only have valid parents in the tipset, meaning

<ul>
<li>that each parent itself must be a valid block</li>
<li>all parents must be at same height</li>
</ul></li>
<li>must have a valid ticket:

<ul>
<li>the ticket must be the winning ticket</li>
<li>the ticket must be generated from the smallest ticket in the parent tipset</li>
<li>all tickets in the ticket array must have been generated by the same miner</li>
<li>if it includes intermediary losing tickets in the ticket array, the node must confirm that each ticket correctly generates the next in the array</li>
</ul></li>
<li>must have a valid timestamp, meaning

<ul>
<li>must be later than the earliest parent block time plus appreopriate delay, which is BLOCK_DELAY (30s by default) * len(blk.Tickets).
see <a href="../mining#block-validation">BLock Validation</a></li>
</ul></li>
<li>must only have valid state transitions:

<ul>
<li>all messages in the block must be valid</li>
<li>the execution of each message, in the order they are in the block, must produce a receipt matching the corresponding one in the receipt set of the block, see <a href="../state-machine">the state machine spec</a>.</li>
</ul></li>
<li>the resulting state root after all messages are applied, must match the one in the block</li>
</ul>

<div class="notices info" >Once the block passes validation, it must be added to the local datastore, regardless whether it is understood as the best tip at this point. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching.</div>

<div class="notices info" >To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.</div>

<h3 id="basic-check">Basic check</h3>

<div class="notices todo" >clarify which of these checks are needed in order to be allowed to validate and propagate a block. This is probably a sub-set of the above mentioned - and thus this paragraph might be moved there - that should be reasonably quick to check and hard to spoof or get around.</div>

<p>A BlockHeader is verifiable on its own, with the last StateTree but without the rest of the Block,
in the following ways:</p>

<ul>
<li>MinerAddress can be validated against current StateTree</li>
<li>ConsensusTickets can be validated</li>
<li>ConsensusElectionProof can be validated</li>
<li>Parents can be checked</li>
<li>BlockSignature can be verified</li>
<li>ParentWeight can be calculated and verified</li>
<li>BlockHeight can be checked against the height of the parents</li>
<li>Timestamp can be checked to be greater than the parents&rsquo; timestamp, by around one block time,
and smaller than the current time.</li>
</ul>

<p>The following requires having and processing (executing) the messages</p>

<ul>
<li>Messages can be checked by verifying the messages hash correctly to the value.</li>
<li>MessageAggregateSig can be checked by verifying the messages sign correctly</li>
<li>MessageReceipts can only be checked by executing the messages</li>
<li>StateRoot is the result of the execution of the messages, and can only be verified by executing them</li>
</ul>

<h3 id="receiving-blocks">Receiving Blocks</h3>

<p>When receiving blocks from the network (via <a href="../data-propagation">block propagation</a>), a miner must do the following:</p>

<ol>
<li>Check their validity (see <a href="#block-validation">below</a>).</li>
<li>Assemble a TipSet with all valid blocks with common parents and the same number of tickets in their <code>Tickets</code> array.</li>
</ol>

<p>A miner may sometimes receive blocks belonging to different TipSets (i.e. whose parents are not the same). In that case, they must choose which TipSet to mine on.</p>

<p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier TipSet rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="../expected-consensus#chain-selection">chain selection</a> in the Expected Consensus spec.</p>

<h3 id="block-validation">Block Validation</h3>

<p>The block structure and serialization is detailed in <a href="../data-structures#block">the datastructures spec - block</a>. Check there for details on fields and types.</p>

<p>In order to validate a block coming in from the network at height <code>N</code> was well mined a miner must do the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">VerifyBlock</span><span class="p">(</span><span class="nx">blk</span> <span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 1. Verify Signature
</span><span class="c1"></span>    <span class="nx">pubk</span> <span class="o">:=</span> <span class="nf">GetPublicKey</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Miner</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">BlockSig</span><span class="p">,</span> <span class="nx">pubk</span><span class="p">,</span> <span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid block signature&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 2. Verify Timestamp
</span><span class="c1"></span>    <span class="c1">// first check that it is not in the future
</span><span class="c1"></span>    <span class="c1">// allowing for some small grace period to deal with small asynchrony
</span><span class="c1"></span>    <span class="c1">// a potential default for ALLOWABLE_CLOCK_DRIFT could be 2/3*blockTime
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">GetTime</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nf">networkTime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">ALLOWABLE_CLOCK_DRIFT</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;block was generated too far in the future&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// next check that it is appropriately delayed from its parents including
</span><span class="c1"></span>    <span class="c1">// null blocks.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">GetTime</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">minParentTime</span><span class="p">()</span><span class="o">+</span><span class="p">(</span><span class="nx">BLOCK_DELAY</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Tickets</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;block was generated too soon&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3. Verify ParentWeight
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">blk</span><span class="p">.</span><span class="nx">ParentWeight</span> <span class="o">!=</span> <span class="nf">ComputeWeight</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Parents</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid parent weight&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 4. Verify Tickets
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">VerifyTickets</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;tickets were invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 5. Verify ElectionProof
</span><span class="c1"></span>    <span class="c1">// Note that this step must explicitly check that the
</span><span class="c1"></span>    <span class="c1">// miner has not been slashed or is not late to submitting a PoSt
</span><span class="c1"></span>    <span class="c1">// i.e. that this is still a valid miner
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">VerifyElectionProof</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;election was invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 6. Verify Message Signatures
</span><span class="c1"></span>    <span class="nx">state</span> <span class="o">:=</span> <span class="nf">GetParentState</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Parents</span><span class="p">)</span>
    <span class="nx">blsMessages</span> <span class="o">:=</span> <span class="nf">LoadMessages</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">Messages</span><span class="p">.</span><span class="nx">blsMsgs</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">blsPubKeys</span> <span class="p">[]</span><span class="nx">PublicKey</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blsMessages</span> <span class="p">{</span>
          <span class="nx">blsPubKeys</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nf">LookupPublicKey</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateBLSSignature</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">BLSAggregate</span><span class="p">,</span> <span class="nx">blsMessages</span><span class="p">,</span> <span class="nx">blsPubKeys</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;aggregated bls signature failed to validate&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">secpkMessages</span> <span class="o">:=</span> <span class="nf">LoadMessages</span><span class="p">(</span><span class="nx">bls</span><span class="p">.</span><span class="nx">Messages</span><span class="p">.</span><span class="nx">secpkMessages</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">secpkMessages</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;secpk message %d had invalid signature&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 7. Validate State Transitions
</span><span class="c1"></span>    <span class="nx">receipts</span> <span class="o">:=</span> <span class="nf">LoadReceipts</span><span class="p">(</span><span class="nx">blk</span><span class="p">.</span><span class="nx">MessageReceipts</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blsMessages</span> <span class="p">{</span>
        <span class="nx">receipt</span> <span class="o">:=</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">receipt</span> <span class="o">!=</span> <span class="nx">receipts</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;message receipt mismatch&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">secpkMessages</span> <span class="p">{</span>
      <span class="nx">receipt</span> <span class="o">:=</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">receipt</span> <span class="o">!=</span> <span class="nx">receipts</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">blsMessages</span><span class="p">)]</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;message receipt mismatch&#34;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nf">Cid</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">blk</span><span class="p">.</span><span class="nx">StateRoot</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;state roots mismatch&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">state</span> <span class="nx">StateTree</span><span class="p">)</span> <span class="nf">LookupPublicKey</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">PubKey</span> <span class="p">{</span>
    <span class="nx">act</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">act</span><span class="p">.</span><span class="nx">Code</span> <span class="o">==</span> <span class="nx">AccountActor</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only account actors have public keys&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">ast</span> <span class="o">:=</span> <span class="nf">LoadAccountActorState</span><span class="p">(</span><span class="nx">act</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">act</span><span class="p">.</span><span class="nx">Address</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">BLS</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">ExtractBLSPubKey</span><span class="p">(</span><span class="nx">act</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;can only look up public keys for BLS controlled accounts&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Get the canonical randomness from a block.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">ticket</span> <span class="o">:=</span> <span class="nf">minTicket</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">ticket</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>If all of this lines up, the block is valid. The miner repeats this for all blocks in a TipSet, and for all TipSets formed from incoming blocks.</p>

<p>Once they&rsquo;ve ensured all blocks in the heaviest TipSet received were properly mined, they can mine on top of it. If they weren&rsquo;t, the miner may need to ensure the next heaviest <code>Tipset</code> was properly mined. This might mean the same <code>Tipset</code> with invalid blocks removed, or an altogether different one.</p>

<p>If no valid blocks are received, a miner may run leader election again (see <a href="../expected-consensus#ticket-generation">ticket generation</a>).</p>

<h3 id="ticket-validation">Ticket Validation</h3>

<p>For ticket generation, see <a href="../expected-consensus#ticket-generation">ticket generation</a>.</p>

<p>A ticket can be verified to have been generated in the appropriate number of rounds by looking at the <code>Tickets</code> array, and ensuring that each subsequent ticket (leading to the final ticket in that array) was generated using the previous one in the array (or in the prior block if the array is empty). Note that this has implications on block size, and client memory requirements, though on expectation, the <code>Tickets</code> array should only contain one Ticket. Put another way, each Ticket should be generated from the prior one in the ticket-chain.</p>

<p>Succinctly, the process of verifying a block&rsquo;s tickets is as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: received block, storage market actor S, miner&#39;s public key PK, a public VDF validation key vk
Output: 0, 1

0. Get the tickets
    i. tickets &lt;-- block.tickets
For each ticket, idx: tickets
1. Verify its VRF Proof
    i. # get the appropriate parent
        if idx == 0:
            # the first was derived from the prior block&#39;s last ticket
            parent = parentBlock.lastTicket
        else:
            parent = tickets[idx - 1]
    ii. # generate the VRFInput
        input &lt;-- VRFPersonalization.Ticket | parent.VDFOutput
    iii. # verify the VRF
        VRFState &lt;-- ECVRF_Verify(PK, ticket.VRFProof, input)
        if VRFState == &#34;INVALID&#34;:
            return 0
2. Verify its VDF Proof
    i. # generate the VDF input
        VRFOutput &lt;-- ECVRF_proof_to_hash(ticket.VRFProof)
    ii. # verify
        VDFState &lt;-- VDF_verify(vk, VRFOutput, ticket.VDFOutput, ticket.VDFProof)
        if VDFState == &#34;NO&#34;:
            return 0
3. Return results
    return 1</code></pre></div>
<p>Notice that there is an implicit check that all tickets in the <code>Tickets</code> array are signed by the same miner.</p>

<h3 id="election-validation">Election Validation</h3>

<p>For election proof generation, see <a href="../expected-consensus#checking-election-results">checking election results</a>.</p>

<p>In order to determine that the mined block was generated by an eligible miner, one must check its <code>ElectionProof</code>.</p>

<p>Succinctly, the process of verifying a block&rsquo;s election proof at round N, is as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Input: received block, storage market actor S, miner&#39;s public key PK, a public parameter K
Output: 0, 1

0. Get the election proof, total power, miner power
        i. electionProof &lt;-- block.electionProof
        ii. # get total market power
            S &lt;-- storageMarket(N)
            p_n &lt;-- S.GetTotalStorage()
        iii. # get miner power
            p_m &lt;-- GetMinersPowerAt(N, PK)
1. Ensure the miner was not slashed or late: in that case, their power would be 0 and can just abort.
        i. # Check for a reported fault or late submission
            if p_m == 0
                return 0
2. Determine the miner&#39;s power fraction
        i. # Get power fraction
              p_f &lt;-- p_m/p_n
3. Ensure that the scratched ticket is a winner
        i. # get the deterministic output from the election proof
            VRFOutput &lt;-- ECVRF_proof_to_hash(electionProof.VRFProof)
        ii. # map p_f onto [0, 2^HashLen]
            normalized_power &lt;-- p_f * 2^HashLen
          iii. # Compare the miner&#39;s scratchValue to the miner&#39;s normalized power fraction
              if readLittleEndian(VRFOutput) &gt; normalized_power:
                return 0
4. Get the appropriate ticket from the ticket chain
        i. # Get the tipset K rounds back
            appropriateTipset &lt;-- lookback(K)
        ii. # Take its min ticket (already validated)
            scratchedTicket &lt;-- appropriateTipset.minTicket()
5. Verify Election Proof validity
        i. # generate the VRFInput from the scratched ticket
            input &lt;-- VRFPersonalization.ElectionProof | scratchedTicket.VDFOutput
        ii. # Check that the election proof was correctly generated by the miner
            # using the appropriate ticket
            VRFState &lt;-- ECVRF_Verify(miner.PK, electionProof.VRFProof, input)
            if VRFState == &#34;INVALID&#34;:
                return 0
5. Everything checks out, it&#39;s a valid election proof
        return 1</code></pre></div>
<h3 id="chaintipsmanager">ChainTipsManager</h3>

<p>The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.</p>

<p>The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current &lsquo;best&rsquo; tipset is.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns the ticket that is at round &#39;r&#39; in the chain behind &#39;head&#39;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TicketFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Returns the tipset that contains round r (Note: multiple rounds&#39; worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TipsetFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// GetBestTipset returns the best known tipset. If the &#39;best&#39; tipset hasn&#39;t changed, then this
</span><span class="c1">// will return the previous best tipset.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetBestTipset</span><span class="p">()</span>

<span class="c1">// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddLosingTicket</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Ticket</span><span class="p">)</span></code></pre></div>
</article>

      

      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#basic-check">Basic check</a></li>
<li><a href="#receiving-blocks">Receiving Blocks</a></li>
<li><a href="#block-validation">Block Validation</a></li>
<li><a href="#ticket-validation">Ticket Validation</a></li>
<li><a href="#election-validation">Election Validation</a></li>
<li><a href="#chaintipsmanager">ChainTipsManager</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
