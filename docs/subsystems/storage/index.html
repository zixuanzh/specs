<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    
    Storage Market
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../../book.min.dd7edd971a70e42d8b77dee6408ce13a65b881f03c3da4d4895f894b428e6946.css">


<link rel="icon" href="../../../favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="../../../docs/subsystems/storage/index.xml" title="Filecoin Spec" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../../css/syntax.css">
<link href="../../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fsubsystems\2fstorage\2f "] {
      color: #0b3a53;
  }
  </style>


  <div>
  <ul>
    
      
      <li>
        











<a href="../../../#intro">    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../#intro__arch">    
    
        Architecture Diagram
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#intro__concepts">    
    
        Key Concepts
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#intro__filecoin_vm">    
    
        Filecoin VM
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#intro__process">    
    
        Spec Process
    
</a>



    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../#algorithms">    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../#algorithms__expected_consensus">    
    
        Expected Consensus
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#algorithms__proof_of_replication">    
    
        Proof of Replication
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#algorithms__proof_of_spacetime">    
    
        Proof of Spacetime
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#algorithms__payment_channels">    
    
        Payment Channels
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#algorithms__vdf">    
    
        Verifiable Delay Functions
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#algorithms__crypto">    
    
        Cryptographic Primitives
    
</a>



    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../#subsystems">    
    
    <strong>
    
        Subsystems
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__blockchain">    
    
        Blockchain
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__blockchain__components">    
    
        Blockchain Components
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__blockchain__components__block_receiver">    
    
        Block Receiver
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__blockchain__components__block_propagator">    
    
        Block Propagator
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__blockchain__components__chain_manager">    
    
        Chain Manager
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__blockchain__components__block_producer">    
    
        Block Producer
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__blockchain__libp2p">    
    
        libp2p Protocols
    
</a>


<ul>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__vm">    
    
        Filecoin VM
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__vm__components">    
    
        Filecoin VM Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../#subsystems__vm__components__vm_interpreter">    
    
        VM Interpreter
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__vm__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__vm__actors__standard">    
    
        Standard Actors
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__vm__actors__singleton">    
    
        Singleton Actors
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__storage">    
    
        Storage Market
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__storage__components">    
    
        Storage Market Components
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__storage__components__storage_provider">    
    
        Storage Provider
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__storage__libp2p">    
    
        libp2p Protocols
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__retrieval">    
    
        Retrieval Market
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__retrieval__components">    
    
        Retrieval Market Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__mining">    
    
        Storage Mining
    
</a>


<ul>

    <li>
    
      











<a href="../../../#subsystems__mining__actors">    
    
        Storage Mining Actors
    
</a>


<ul>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__mining__components">    
    
        Storage Mining Components
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../#subsystems__mining__components__proof_generator">    
    
        Proof Generator
    
</a>


<ul>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#subsystems__network">    
    
        Network Interface
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../#subsystems__repository">    
    
        Repository
    
</a>


<ul>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../#listings">    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>


<ul>

    <li>
    
      











<a href="../../../#listings__actors">    
    
        Filecoin VM Actors
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#listings__data_structures">    
    
        Data Structures
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#listings__components">    
    
        Components
    
</a>


<ul>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../#listings__libp2p_protocols">    
    
        libp2p Protocols
    
</a>


<ul>

</ul>


    
    </li>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../#glossary">    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>


<ul>

</ul>


      </li>
    
      
      <li>
        











<a href="../../../#appendix">    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



      </li>
    
  </ul>
</div>








</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    
    Storage Market
  
</strong>
</header>

      
<article class="markdown">

<h2 id="the-filecoin-storage-market">The Filecoin Storage Market</h2>

<p>The Filecoin <code>storage market</code> is the underlying system used to discover, negotiate and form <code>storage contracts</code> between clients and storage providers called <code>storage miners</code> in a Filecoin network. The <code>storage market</code> itself is an <code>actor</code> that helps to mediate certain operations in the market, including adding new miners, and punishing faulty ones, it does not directly mediate any actual storage deals. The <code>storage contracts</code> between clients and miners specify that a given <code>piece</code> will be stored for a given time duration. It is assumed that the <code>client</code>, or some delegate of the client, remains online to monitor the <code>storage miner</code> and <code>slash</code> it in the case that the agreed upon data is removed from the miners proving set before the deal is finished.</p>

<p>The creation of such a storage market is motivated by the need to provide a fast, reliable and inexpensive solution to data generated worldwide. The cost and difficulty involved in starting datacenters around the world make a decentralized solution attractive here, enabling clients and miners to interact directly, forming agreements for storage ad-hoc around the world. Geography is only one such aspect in which a decentralized market can be made competitive. You can read more about the underlying motivations for building a storage market <a href="https://www.youtube.com/watch?v=EClPAFPeXIQ">here</a>.</p>

<p>In the current design of the <code>storage market</code>, <code>storage miners</code> post <code>asks</code> indicating the price they are willing to accepts, and <code>clients</code> select (either manually, or via some locally run algorithm) a set of storage miners to store their data with. They then contact the <code>storage miners</code> who programmatically either accept or deny their <code>deal proposals</code>. In the future, we may allow miners to search for clients and propose deals to them, but for now, for simplicity, we stick with the model described above.</p>

<h3 id="visualization-of-the-filecoin-storage-market">Visualization of the Filecoin Storage Market</h3>

<p>TODO: This is a high level overview of how the storage market interacts with components</p>

<h2 id="the-market-interface">The Market Interface</h2>

<p>This interface, written using Go type notation, defines the set of methods that are callable on the storage market actor. The storage market actor is a built-in network actor. For more information about Actors, see <a href="actors.md">actors.md</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StorageMarket</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// CreateStorageMiner registers a new storage miner with the given public key and a
</span><span class="c1"></span>	<span class="c1">// pledge of the given size. The miners collateral is set by the value in the message.
</span><span class="c1"></span>	<span class="c1">// The public key must match the private key used to sign off on blocks created
</span><span class="c1"></span>	<span class="c1">// by this miner. This key is the &#39;worker&#39; key for the miner.
</span><span class="c1"></span>	<span class="c1">// The libp2p peer ID specified should reference the libp2p identity that the
</span><span class="c1"></span>	<span class="c1">// miner is operating. This is the ID that clients will connect to to propose deals
</span><span class="c1"></span>	<span class="c1">// TODO: maybe rename to &#39;RegisterStorageMiner&#39;?
</span><span class="c1"></span>	<span class="nf">CreateStorageMiner</span><span class="p">(</span><span class="nx">pubk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">pledge</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span><span class="p">)</span> <span class="nx">Address</span>

	<span class="c1">// SlashConsensusFault is used to slash a misbehaving miner who submitted two different
</span><span class="c1"></span>	<span class="c1">// blocks at the same block height. The signatures on each block are validated
</span><span class="c1"></span>	<span class="c1">// and the offending miner has their entire collateral slashed, including the
</span><span class="c1"></span>	<span class="c1">// invalidation of any any all storage they are providing. The caller is rewarded
</span><span class="c1"></span>	<span class="c1">// a small amount to compensate for gas fees (TODO: maybe it should be more?)
</span><span class="c1"></span>	<span class="nf">SlashConsensusFault</span><span class="p">(</span><span class="nx">blk1</span><span class="p">,</span> <span class="nx">blk2</span> <span class="nx">BlockHeader</span><span class="p">)</span>

	<span class="c1">// SlashStorageFault slashes a storage miner for not submitting their PoSTs within
</span><span class="c1"></span>	<span class="c1">// the correct [time window](#TODO-link-to-faulty-submission). This may be called by anyone who detects the faulty behavior.
</span><span class="c1"></span>	<span class="c1">// The slashed miner then loses all of their staked collateral, and also loses all
</span><span class="c1"></span>	<span class="c1">// of their power, and as a result, is no longer a candidate leader for extending the chain.
</span><span class="c1"></span>	<span class="nf">SlashStorageFault</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">Address</span><span class="p">)</span>

	<span class="c1">// UpdateStorage is called by a miner to adjust the storage market actors
</span><span class="c1"></span>	<span class="c1">// accounting of the total storage in the storage market.
</span><span class="c1"></span>	<span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">delta</span> <span class="nx">BytesAmount</span><span class="p">)</span>

	<span class="c1">// GetTotalStorage returns the total committed storage in the system. This number is
</span><span class="c1"></span>	<span class="c1">// also used as the &#39;total power&#39; in the system for the purposes of the power table
</span><span class="c1"></span>	<span class="nf">GetTotalStorage</span><span class="p">()</span> <span class="nx">BytesAmount</span>
<span class="p">}</span></code></pre></div>
<h2 id="the-filecoin-storage-market-operation">The Filecoin Storage Market Operation</h2>

<p>The Filecoin storage market operates as follows. Miners providing storage submit ask orders, asking for a certain price for their available storage space, and clients with files to store look through the asks and select a miner they wish to use. Clients negotiate directly with the storage miner that owns that ask, off-chain. Storage is priced in terms of Filecoin per byte per block (note: we may change the units here).</p>

<h3 id="market-datastructures">Market Datastructures</h3>

<p>The storage market contains the following data:</p>

<ul>
<li>StorageMiners - The storage market keeps track of the set of the addresses of all storage miners in the storage market. All miners referenced here were created by the storage market via the <code>CreateStorageMiner</code> method.</li>
<li>TotalComittedStorage - This is a tally of all the committed storage in the network. This is both a nice metric to see how much data is being stored by the filecoin network, and a critical piece of information used by mining routine to compute each miners storage ratio.</li>
</ul>

<h2 id="market-flow">Market Flow</h2>

<p>This section describes the flow required to store a single piece with a single storage miner. Most use-cases will involve performing this process for multiple pieces, with different miners.</p>

<h4 id="before-deal">Before Deal</h4>

<ol>
<li><strong>Data Preparation:</strong> The client prepares their input data. See <a href="client-data.md">client data</a> for more details.</li>
<li><strong>Miner Selection:</strong> The client looks at asks on the network, and then selects a storage miner to store their data with.

<ul>
<li>Note: this is currently a manual process.</li>
</ul></li>
<li><strong>Payment Channel Setup:</strong> The client calls <a href="#payments"><code>Payment.Setup</code></a> with the piece and the funds they are going to pay the miner with. All payments between clients and storage providers use payment channels.</li>
</ol>

<h4 id="deal">Deal</h4>

<p>Note: The details of this protocol including formats, datastructures, and algorithms, can be found <a href="network-protocols.md#storage-deal">here</a>.</p>

<ol>
<li><p><strong>Storage Deal Staging:</strong> The client now runs the <a href="network-protocols.md#storage-deal">&lsquo;make storage deal&rsquo;</a> protocol, as follows:</p>

<ul>
<li>The client sends a <code>StorageDealProposal</code> for the piece in question</li>
<li>This contains updates for the payment channel that the client may close at any time, unless the piece gets confirmed (see next section), in which case the miner is able to extend the channel.</li>
<li>The miner decides whether or not to accept the deal and sends back a <code>StorageDealResponse</code></li>
<li>Note: Different implementations may come up with different ways of making a decision on a given deal.</li>
<li>If the miner accepts, the client now sends the data to the miner</li>
<li>Once the miner receives the data:</li>
<li>They validate that the data matches the storage market hash claimed by the client</li>
<li>They stage it into a sector and set the deal state to <code>Staged</code></li>
</ul></li>

<li><p><strong>Storage Deal Start</strong>: Clients makes sure data is in a <a href="definitions.md#sector">sector</a></p>

<ul>
<li><strong>PieceInclusionProof:</strong> Once the miner seals the sector, they update the PieceInclusionProof in the deal state, which the client then gets the next time they query that state.

<ul>
<li>The PieceInclusionProof proves that the piece in the deal is contained in a sector whose commitment is on chain. The <code>commP</code> hash from earlier is used here. See <a href="proofs.md#piece-inclusion-proof">piece inclusion proof for more details</a></li>
</ul></li>
<li>Note: a client that is not interested in staying online to wait for PieceInclusionProof can leave immediately, however, they run the risk that their files don&rsquo;t actually get stored (but if their data is not stored, the miner will not be able to claim payment for it).

<ul>
<li>Note: In order to provide the piece inclusion proof, the miner needs to fill the sector. This may take some time. So there is a wait between the time the data is transferred to the miner, and when the piece inclusion proof becomes available.</li>
</ul></li>
<li><strong>Mining</strong>: Miner posts <code>seal commitment</code> and associated proof on chain by calling <code>CommitSector</code> and starts running <code>proofs of spacetime</code>. See <a href="mining.md#storage-mining-cycle">storage mining cycle</a> for more details.</li>
</ul></li>

<li><p><strong>Storage Deal Abort:</strong> If the miner doesn&rsquo;t provide the PieceInclusionProof, the client can invalidate the payment channel.</p>

<ul>
<li>This is done by invoking the &lsquo;close&rsquo; method on the channel on-chain. This process starts a timer that, on finishing, will release the funds to the client.</li>
<li>If a client attempts to abort a deal that they have actually made with a miner, the miner can submit a payment channel update to force the channel to stay open for the length of the agreement.</li>
</ul></li>

<li><p><strong>Storage Deal Complete:</strong> The client periodically queries the miner for the deals status until the deal is &lsquo;complete&rsquo;, at which point the client knows that the data is properly replicated.</p>

<ul>
<li>The client should store the returned &lsquo;PieceInclusionProof&rsquo; for later validation.</li>
</ul></li>
</ol>

<p>TODO: &lsquo;complete&rsquo; isnt really the right word here, as it implies that the deal is over.</p>

<ol>
<li><strong>Income Withdrawal</strong>: When the miner wishes to withdraw funds, they call <a href="#payments"><code>Payment.RedeemVoucher</code></a>.</li>
</ol>

<h2 id="the-power-table">The Power Table</h2>

<p>The <code>power table</code> is exported by the storage market for use by consensus. There isn&rsquo;t actually a concrete object that is the power table (though the concept is conceptually helpful), instead, the <a href="actors.md#storage-market-actor">storage market actor</a> exports the <code>GetTotalStorage</code> and <code>PowerLookup</code>  methods which can be used to lookup total network power and a miner&rsquo;s power, respectively.
Each individual miner reports its power through their actor.</p>

<p>To check the power of a given miner, use the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetMinersPowerAt</span><span class="p">(</span><span class="nx">ts</span> <span class="nx">TipSet</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">Integer</span> <span class="p">{</span>
  <span class="nx">curState</span> <span class="o">:=</span> <span class="nf">GetStateTree</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
  <span class="nx">miner</span> <span class="o">:=</span> <span class="nx">curState</span><span class="p">.</span><span class="nf">GetMiner</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">IsSlashed</span><span class="p">()</span> <span class="o">||</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">IsLate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
  
  <span class="err">#</span> <span class="nx">lookback</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">last</span> <span class="nx">valid</span> <span class="nx">PoSt</span> <span class="nx">put</span> <span class="nx">up</span> <span class="nx">by</span> <span class="nx">the</span> <span class="nx">miner</span>
  <span class="nx">lookbackTipset</span> <span class="o">:=</span> <span class="nf">WalkBack</span><span class="p">(</span><span class="nx">ts</span><span class="p">,</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">provingPeriodEnd</span> <span class="o">-</span> <span class="nf">provingPeriodDuration</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">))</span>
  <span class="nx">lbState</span> <span class="o">:=</span> <span class="nf">GetStateTree</span><span class="p">(</span><span class="nx">lookbackTipset</span><span class="p">)</span>
  
  <span class="nx">sm</span> <span class="o">:=</span> <span class="nx">lbState</span><span class="p">.</span><span class="nf">GetStorageMarket</span><span class="p">()</span>
  
  <span class="k">return</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">PowerLookup</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h3 id="power-updates">Power Updates</h3>

<p>Whenever a new <a href="proofs.md">PoSt</a> or <a href="faults.md">Fault</a> makes it on chain, the storage market updates the underlying power values appropriately.</p>

<p>Specifically, a miner&rsquo;s power is initialized/maintained when they <a href="actors.md#submitPoSt">submit a valid PoSt</a> to the chain, and decreases if they are slashed (for a <a href="actors.md#slashStorageFault">storage fault</a> or a <a href="actors.md#slashConsensusFault">consensus fault</a>).</p>

<p>Power is deducted when miners remove sectors by reporting the sector &lsquo;missing&rsquo; or &lsquo;done&rsquo; in a PoSt.</p>

<h2 id="payments">Payments</h2>

<p>The storage market expects a payments system to allow clients to pay miners for storage. Any payments system that has the following capabilities may be used:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Payments</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Setup sets up a payment from the caller to the target address. The payment
</span><span class="c1"></span>	<span class="c1">// MUST be contingent on the miner being able to prove that they have the data
</span><span class="c1"></span>	<span class="c1">// referenced by &#39;piece&#39;. The total amount of Filecoin that may be transfered by
</span><span class="c1"></span>	<span class="c1">// this payment is specified by &#39;value&#39;
</span><span class="c1"></span>	<span class="nf">Setup</span><span class="p">(</span><span class="nx">target</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">piece</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">ID</span>

	<span class="c1">// MakeVouchers creates a set of vouchers redeemable by the target of the
</span><span class="c1"></span>	<span class="c1">// previously created payment. It creates &#39;count&#39; vouchers, each of which is
</span><span class="c1"></span>	<span class="c1">// redeemable only after an certain block height, evenly spaced out between
</span><span class="c1"></span>	<span class="c1">// start and end. Each voucher should be redeemable for proportionally more
</span><span class="c1"></span>	<span class="c1">// Filecoin, up to the total amount specified during the payment setup.
</span><span class="c1"></span>	<span class="nf">MakeVouchers</span><span class="p">(</span><span class="nx">id</span> <span class="nx">ID</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="nx">BlockHeight</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Voucher</span>

	<span class="c1">// Redeem voucher is called by the target of a given payment to claim the
</span><span class="c1"></span>	<span class="c1">// funds represented by it. The voucher can only be redeemed after the block
</span><span class="c1"></span>	<span class="c1">// height that is attributed to the voucher, and also only if the proof given
</span><span class="c1"></span>	<span class="c1">// proves that the target is correctly storing the piece referenced in the
</span><span class="c1"></span>	<span class="c1">// payment setup.
</span><span class="c1"></span>	<span class="nf">RedeemVoucher</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Voucher</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">Proof</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>For details on the implementation of the payments system, see <a href="payments.md">the payments doc</a>.</p>

<h2 id="future-protocol-improvements">Future Protocol Improvements</h2>

<ul>
<li>Slashable Commitments

<ul>
<li>When miners initially receive the data for a deal with a client, that signed response statement can be used to slash the miner in the event that they never include that data in a sector.</li>
</ul></li>
</ul>

<h1 id="open-questions">Open questions</h1>

<ul>
<li>Storage time should likely be designated in terms of proving period. Where a proving period is the number of blocks in which every miner must submit a proof for their sectors. Not doing this makes accounting hard: &ldquo;when exactly did this sector fail?&rdquo;</li>
</ul>

<h2 id="storage-deal-make">Storage Deal Make</h2>

<ul>
<li><strong>Name</strong>: Storage Deal Make</li>
<li><strong>Protocol ID</strong>: <code>/fil/storage/mk/1.0.0</code></li>
</ul>

<blockquote>
<p>The storage deal protocol is used by any client to store data with a storage miner.</p>
</blockquote>

<p>The protocol starts with storage client (which in this case may be a normal storage client, or a broker). It is assumed that the client has their data already prepared into a <code>piece</code> prior to executing this protocol. For more details on initial data processing, see <a href="client-data.md">client data</a>.</p>

<p>First the client sends a <code>SignedStorageDealProposal</code> to the storage miner:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Commitment Bytes</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SerializationMode enum <span class="o">{</span>
     <span class="p">|</span> <span class="s2">&#34;UnixFs&#34;</span>
    <span class="c1">## no transformations applied</span>
    <span class="p">|</span> <span class="s2">&#34;Raw&#34;</span>
    <span class="c1">## Serialized as IPLD, encoding is specified in the CID stored in `pieceRef`</span>
    <span class="p">|</span> <span class="s2">&#34;IPLD&#34;</span>
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageDealProposal struct <span class="o">{</span>
	<span class="c1">## PieceRef is the hash of the data in native structure. This will be used for</span>
	<span class="c1">## certifying the data transfer.</span>
    <span class="c1">## Reference for transit.</span>
	pieceRef String

	<span class="c1">## Specifies how the graph referenced by &#39;PieceRef&#39; gets transformed</span>
	<span class="c1">## into the data that will be packed into a sector.</span>
	serializationMode SerializationMode

	<span class="c1">## The data hashed in a form that is compatible with the proofs system.</span>
    <span class="c1">## Reference for actual storage in a sector.</span>
	commP Commitment

	size BytesAmount

	totalPrice TokenAmount

	<span class="c1">## Duration is how long the file should be stored for</span>
	Duration NumBlocks

	<span class="c1">## A reference to the mechanism that the proposer will use to pay the miner. It should be</span>
    <span class="c1">## verifiable by the miner using on-chain information.</span>
	payment PaymentInfo

	<span class="c1">## MinerAddress is the address of the storage miner in the deal proposal</span>
	minerAddress Address

	clientAddress Address
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SignedStorageDealProposal struct <span class="o">{</span>
	proposal StorageDealProposal

	<span class="c1">## Signature over the the encoded StorageDealProposal signed by the client.</span>
	signature Signature
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentInfo struct <span class="o">{</span>
	<span class="c1">## The address of the payment channel actor that will be used to facilitate payments.</span>
	payChActor Address

	<span class="c1">## Reference to the message used to create the payment channel. This allows the miner to wait until the</span>
	<span class="c1">## channel is accepted on chain. (optional)</span>
	channelMessage <span class="p">&amp;</span>Message

  <span class="c1">## Set of payments from the client to the miner that can be cashed out contingent on the agreed</span>
  <span class="c1">## upon data being provably within a live sector in the miners control on-chain.</span>
	vouchers <span class="o">[</span>SignedVoucher<span class="o">]</span>
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> DealState enum <span class="o">{</span>
    <span class="c1">## Signifies an unknown negotiation.</span>
    <span class="p">|</span> Unknown <span class="m">0</span>
    <span class="c1">## The deal was rejected for some reason.</span>
    <span class="p">|</span> Rejected <span class="m">1</span>
    <span class="c1">## The deal was accepted but hasn&#39;t yet started.</span>
    <span class="p">|</span> Accepted <span class="m">2</span>
    <span class="c1">## The deal has started and the transfer is in progress.</span>
    <span class="p">|</span> Started <span class="m">3</span>
    <span class="c1">## The deal has failed for some reason.</span>
    <span class="p">|</span> Failed <span class="m">4</span>
    <span class="c1">## The data has been received and staged into a sector, but is not sealed yet.</span>
    <span class="p">|</span> Staged <span class="m">5</span>
    <span class="c1">## The data is being sealed and a `PieceInclusionProof` is available.</span>
    <span class="p">|</span> Sealing <span class="m">6</span>
    <span class="c1">## Deal is complete, and the sector that the deal is contained in has been sealed and its</span>
    <span class="c1">## commitment posted on chain.</span>
    <span class="p">|</span> Complete <span class="m">7</span>
<span class="o">}</span></code></pre></div>
<div class="notices todo" ><strong>TODO</strong>: possibly also include a starting block height here, to indicate when this deal may be started (implying you could select a value in the future). After the first response, both parties will have signed agreeing that the deal started at that point. This could possibly be used to challenge either party in the event of a stall. This starting block height also gives the miner time to seal and post the commitment on chain. Otherwise a weird condition exists where a client could immediately slash a miner for not having their data stored.</div>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageDealResponse union <span class="o">{</span>
    <span class="p">|</span> UnknownParams
    <span class="p">|</span> RejectedParams
    <span class="p">|</span> AcceptedParams
    <span class="p">|</span> StartedParams
    <span class="p">|</span> FailedParams
    <span class="p">|</span> StagedParams
    <span class="p">|</span> SealingParams
    <span class="p">|</span> CompleteParams
<span class="o">}</span> representation keyed

<span class="nb">type</span> UnknownParams struct <span class="o">{</span>
	<span class="c1">## Message is an optional message to add context to any given response</span>
	message optional String
<span class="o">}</span>

<span class="nb">type</span> RejectedParams struct <span class="o">{</span>
    message optional String

	<span class="c1">## A reference to the proposal this is the response to.</span>
    proposal <span class="p">&amp;</span>SignedStorageDealProposal
<span class="o">}</span>

<span class="nb">type</span> AcceptedParams RejectedParams
<span class="nb">type</span> FailedParams RejectedParams
<span class="nb">type</span> StagedParams RejectedParams

<span class="nb">type</span> SealingParams struct <span class="o">{</span>
	<span class="c1">## The proof needed to convince the client that the miner has sealed the data into a sector.</span>
	<span class="c1">## Note: the miner doesnt necessarily have to have committed the sector at this point</span>
	<span class="c1">## they just need to have staged it into a sector, and be committed to putting it at</span>
	<span class="c1">## that place in the sector.</span>
	pieceInclusionProof PieceInclusionProof
<span class="o">}</span>

<span class="nb">type</span> CompleteParams struct <span class="o">{</span>
	<span class="c1">## A reference to the message that was sent to submit the sector containing this data to the chain.</span>
	sectorCommitMessage <span class="p">&amp;</span>Message
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SignedStorageDealResponse struct <span class="o">{</span>
	response StorageDealResponse

	<span class="c1">## Signature is a signature from the miner over the cbor encoded response</span>
	signature Signature
<span class="o">}</span></code></pre></div>
<h3 id="process">Process</h3>

<ol>
<li>[Client] send <code>SignedStorageDealProposal</code>.</li>
<li>[Miner]  send <code>SignedStorageDealResponse</code>, either accepting or rejecting the deal.</li>
<li>[Client] If <code>response.state</code> is <code>Accepted</code> then transfer the data in question.</li>
<li>[Miner] Once the miner receives all the data they validate it. On success they set the <code>DealState</code> to <code>Staged</code> (internally).</li>
<li>[Miner] When the sector gets sealed, the state gets set to <code>Sealing</code>.</li>
<li>[Miner] When the commitment is posted on chain, the state gets set to <code>Complete</code>.</li>
<li>[Client] Once the deal makes it to the <code>Sealing</code> state, they are able to query and get the <code>PieceInclusionProof</code> that they need to verify that the miner is indeed storing their data.</li>
</ol>

<p>At any point in time the client can query (using the query protocol) the miner to get the current state of the deal.</p>

<div class="notices Note" ><strong>Note:</strong> The data transfer operation happens out of band from this protocol, and can be a simple bitswap transfer at first. Support for other more &lsquo;exotic&rsquo; &lsquo;protocols&rsquo; such as mailing hard drives is an explicit goal.</div>

<h2 id="storage-deal-query">Storage Deal Query</h2>

<ul>
<li><strong>Name</strong>: Storage Deal Query</li>
<li><strong>Protocol ID</strong>: <code>/fil/storage/qry/1.0.0</code></li>
</ul>

<p>This is the basic protocol for querying the current state of a given storage deal.
At any point, the client in this flow may query the miner for the state of a given proposal. To query, they send a <code>StorageDealQuery</code> that looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageDealQuery struct <span class="o">{</span>
	<span class="c1">## ProposalCid is the cid of the proposal for the deal that we are querying</span>
	<span class="c1">## the state of</span>
	proposal <span class="p">&amp;</span>SignedStorageDealProposal

	baseState DealState
<span class="o">}</span></code></pre></div>
<p>If <code>baseState</code> is <code>Unset</code> or a terminal state (<code>Complete</code>, <code>Rejected</code>, or <code>Failed</code>) then the current state of the deal in question is returned. If the <code>baseState</code> is different than the current state of the deal, the current state of the deal is also returned immediately. In the case that the <code>baseState</code> matches the current state of the deal, then the stream is held open until the state changes, at which point the new state of the deal is returned.</p>

<div class="notices Note" ><strong>Note:</strong> In the future we may want something more complex that is able to multiplex waiting for notifications about a large set of deals over a single stream simultaneously. Upgrading to that from this should be relatively simple, so for now, we do the simple thing.</div>

<h2 id="piece-commitment">Piece Commitment</h2>

<h3 id="commp">commP</h3>

<p>A piece commitment (<code>commP</code>) is the root hash of a piece that a client wants to store in Filecoin. It is generated using <code>RepHash</code> (as described in <a href="zigzag-porep.md">Proof-of-Replication</a>) on some raw data which has been zero-padded to a multiple of 127 bytes, then preprocessed yielding <code>Fr32 padded</code> data which is a multiple of 128 bytes.</p>

<h2 id="transfer-formats">Transfer formats</h2>

<p>The transfer format is the format to transfer a file over the network. This format SHALL be used for the initial transfer (from clients to storage miners) and for later retrievals (from storage miners to the clients).</p>

<p>The default transfer format is <code>unixfsv1</code>. Cliens MAY agree to use other formats of their preference.</p>

<h3 id="unixfsv1"><code>unixfsv1</code></h3>

<p>The default transfer format is Unixfsv1 with the following parameters:</p>

<ul>
<li>Chunking: Fixed, 1MB</li>
<li>Leaf Format: Raw</li>
<li>Max Branch Width: 1024</li>
</ul>

<p>For details on how UnixfsV1 works, see its spec <a href="https://github.com/ipfs/specs/tree/master/unixfs">here</a>.</p>

<h2 id="storage-formats">Storage Formats</h2>

<p>The Storage Format MUST be use for generating Filecoin proofs and hashing sectors data.</p>

<p>The current required storage format is <code>paddedfr32v1</code>.</p>

<h3 id="paddedfr32v1"><code>paddedfr32v1</code></h3>

<p>A correctly formatted <code>paddedfr32v1</code> data must have:</p>

<ul>
<li><strong>Fr32 Padding</strong>: Every 32 bytes blocks MUST contain two zeroes in the most significant bits (every 254 bits must be followed by 2 zeroes if interpreted as little-endian number). That is, for each block, <code>0x11000000 &amp; block[31] == 0</code>.</li>
<li><strong>Piece Padding</strong>: In order to generate minimal <code>PieceInclusionProofs</code>, blocks of 32 zero bytes MUST be added so that the total number of blocks (including <em>piece padding</em>) is a power of two. <strong>Piece Padding</strong> can be omitted if the prover wishes to generate unaligned proofs. [NOTE: not yet fully specified.]</li>
</ul>

<p><strong>Why do we need a special Storage Encoding Format?</strong> In the Filecoin proofs we do operations in an arithmetic field of size <code>p</code>, where <code>p</code> is a prime of size <code>2^255</code>, hence the size of the data blocks must be smaller than <code>p</code>. We cautiously decide to have data blocks of size 254 to avoid possible overflows (data blocks numerical representation is bigger than <code>p</code>).</p>

<h2 id="miners-claiming-earnings">Miners Claiming Earnings</h2>

<p>Storage Miners claim their Storage Market earnings via payment channels.</p>

<p>The client proposes the cadence of the earnings for a deal by creating <code>SignedVoucher</code>-s. Each vouchers specify how often Storage Miners can claim earnings and how much each earning should be, more precisely, each voucher has some tokens assigned and can be redeemed only at a particular block height. The vouchers are part of the <code>PaymentInfo</code> included in the <code>StorageDealProposal</code>. When receiving a proposal, a Storage Miner can review and accept these terms by completing the deal protocol.</p>

<p>After the block defined in each <code>SignedVoucher</code> is passed, the Storage Miner could claim the earning by updating the payment channel calling <code>UpdateChannelState</code> on the <code>PaymentChannel</code> actor for a particular <code>SignedVoucher</code>. This call passes if the Storage Miner is still storing the piece in sector and if the Storage Miner is not late in their PoSt submission and if the time specified in the <code>SignedVoucher</code> has passed.</p>

<h2 id="storage-miner-payments">Storage Miner Payments</h2>

<p>TODO: these bits were pulled out of a different doc, and describe strategies by which client payments to a miner might happen. We need to organize &lsquo;clients paying miners&rsquo; better, unclear if it should be the same doc that talks about payment channel constructions.</p>

<ol>
<li><strong>Updates Contingent on Inclusion Proof</strong>

<ul>
<li>In this case, the miner must provide an inclusion proof that shows the client data is contained in one of the miners sectors on chain, and submit that along with the payment channel update.</li>
<li>This can be pretty expensive for smaller files, and ideally, we make it to one of the latter two options</li>
<li>This option does however allow clients to upload their files and leave.</li>
</ul></li>
<li><strong>Update Contingent on CommD Existence</strong>

<ul>
<li>For this, the client needs to wait around until the miner finishes packing a sector, and computing its commD. The client then signs a set of payment channel updates that are contingent on the given commD existing on chain.</li>
<li>This route makes it difficult for miners to re-seal smaller files (really, small files just suck)</li>
</ul></li>
<li><strong>Reconciled Payment</strong>

<ul>
<li>In either of the above cases, the miner may go back to the client and say &ldquo;Look, these payment channel updates you gave me are able to be cashed in right now, could you take them all and give me back a single update for a slightly smaller amount?&rdquo;.</li>
<li>The slightly smaller amount could be the difference in transaction fees, meaning the client saves money, and the miner gets the same amount.</li>
</ul></li>
</ol>
</article>

      

      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#the-filecoin-storage-market">The Filecoin Storage Market</a>
<ul>
<li><a href="#visualization-of-the-filecoin-storage-market">Visualization of the Filecoin Storage Market</a></li>
</ul></li>
<li><a href="#the-market-interface">The Market Interface</a></li>
<li><a href="#the-filecoin-storage-market-operation">The Filecoin Storage Market Operation</a>
<ul>
<li><a href="#market-datastructures">Market Datastructures</a></li>
</ul></li>
<li><a href="#market-flow">Market Flow</a>
<ul>
<li>
<ul>
<li><a href="#before-deal">Before Deal</a></li>
<li><a href="#deal">Deal</a></li>
</ul></li>
</ul></li>
<li><a href="#the-power-table">The Power Table</a>
<ul>
<li><a href="#power-updates">Power Updates</a></li>
</ul></li>
<li><a href="#payments">Payments</a></li>
<li><a href="#future-protocol-improvements">Future Protocol Improvements</a></li>
</ul></li>
<li><a href="#open-questions">Open questions</a>
<ul>
<li><a href="#storage-deal-make">Storage Deal Make</a>
<ul>
<li><a href="#process">Process</a></li>
</ul></li>
<li><a href="#storage-deal-query">Storage Deal Query</a></li>
<li><a href="#piece-commitment">Piece Commitment</a>
<ul>
<li><a href="#commp">commP</a></li>
</ul></li>
<li><a href="#transfer-formats">Transfer formats</a>
<ul>
<li><a href="#unixfsv1"><code>unixfsv1</code></a></li>
</ul></li>
<li><a href="#storage-formats">Storage Formats</a>
<ul>
<li><a href="#paddedfr32v1"><code>paddedfr32v1</code></a></li>
</ul></li>
<li><a href="#miners-claiming-earnings">Miners Claiming Earnings</a></li>
<li><a href="#storage-miner-payments">Storage Miner Payments</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
